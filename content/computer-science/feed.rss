<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Computer Science</title><link>https://readrust.net/</link><description>Computer Science posts on Read Rust</description><item><title>Sealed Rust</title><link>https://ferrous-systems.com/blog/sealed-rust-the-pitch/</link><description><![CDATA[This is the first post in a series detailing Ferrous System's plan to qualify the Rust Language and Compiler for use in the Safety Critical domain. We call this effort Sealed Rust.]]></description><guid isPermaLink="false">b3f6b505-fb93-4330-a039-d97e148e80d5</guid><pubDate>Thu,  6 Jun 2019 02:21:00 +0000</pubDate><dc:creator>James Munns</dc:creator></item><item><title>The design and implementation of a lock-free ring-buffer with contiguous reservations</title><link>https://ferrous-systems.com/blog/lock-free-ring-buffer/</link><description><![CDATA[Berlin based technology consultancy specialising in the rust programming language and related services.]]></description><guid isPermaLink="false">c12ced69-039d-4d8a-99f3-ed518947537a</guid><pubDate>Wed,  5 Jun 2019 03:02:00 +0000</pubDate><dc:creator>Andrea Lattuada and James Munns</dc:creator></item><item><title>State of Machine Learning in Rust</title><link>https://ehsanmkermani.com/2019/05/13/state-of-machine-learning-in-rust/</link><description><![CDATA[Every once in a while this topic comes up on a social media or Rust user channel. Iâ€™d like to describe briefly the way I see where things are going by a little bit of history as well as some information about existing flux of Machine Learning/Deep Learning frameworks and major recent trends.]]></description><guid isPermaLink="false">5d09aa3e-28c5-4535-9d07-cc3cafbb2ca2</guid><pubDate>Tue, 14 May 2019 00:48:37 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>A Practical Analysis of Rust&apos;s Concurrency Story</title><link>https://arxiv.org/abs/1904.12210</link><description><![CDATA[Rust is a recent programming language from Mozilla that attempts to solve these intertwined issues by detecting data-races at compile time. Rust's type system encodes a data-structure's ability to be shared between threads in the type system, which in turn allows the compiler to reject programs where threads directly mutate shared state without locks or other protection mechanisms. In this work, we examine how this aspect of Rust's type system impacts the development and refinement of a concurrent data structure, as well as its ability to adapt to situations where correctness is guaranteed by lower-level invariants (e.g., in lock-free algorithms) that are not directly expressible in the type system itself. We detail the implementation of a concurrent lock-free hashmap in order to describe these traits of the Rust language.]]></description><guid isPermaLink="false">d9831a1a-f79f-4c0b-af9e-b4c5b65cd74f</guid><pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Aditya Saligrama, Andrew Shen, Jon Gjengset</dc:creator></item><item><title>Refactoring Varisat 5: Incremental Solving and Proofs</title><link>https://jix.one/refactoring-varisat-5-incremental-solving-and-proofs/</link><description><![CDATA[This is the fifth and final post in my series about refactoring varisat. In the last post varisat gained the heuristics needed to solve some non-trivial instances. In this post weâ€™ll add incremental solving and proof generation. This brings varisat to feature parity with the old version.]]></description><guid isPermaLink="false">0d66bab5-b38a-4f8a-8c6f-2c7c2cd41fab</guid><pubDate>Fri, 26 Apr 2019 16:12:54 +0200</pubDate><dc:creator>Jannis Harder</dc:creator></item><item><title>Writing a Compiler in Rust</title><link>http://thume.ca/2019/04/18/writing-a-compiler-in-rust/</link><description><![CDATA[During my final term at UWaterloo I took the CS444 compilers class with a project to write a compiler from a substantial subset of Java to x86, with a language and two teammates of your choice. My group of three chose to write our compiler in Rust and it was a fun experience. We spent time coming to design decisions that worked out really well and used Rustâ€™s strengths. Our compiler ended up being around 6800 lines of Rust and I personally put in around 60 hours of solid coding and more on code review and design. In this post Iâ€™ll go over some of the design decisions we made and some thoughts on what it was like using Rust.]]></description><guid isPermaLink="false">61255817-6eef-43ce-9eea-24a8aedbd9f2</guid><pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Tristan Hume</dc:creator></item><item><title>Idiomatic monads in Rust</title><link>https://varkor.github.io/blog/2019/03/28/idiomatic-monads-in-rust.html</link><description><![CDATA[A pragmatic new design for high-level abstractions In this post, Iâ€™m going to describe a new approach to express monads in Rust. It is the most minimal design I have seen proposed and is, in my eyes, the first plausible design for such abstractions â€” those commonly known as â€œhigher-kinded typesâ€. This approach depends on a very minimal extension to Rustâ€™s type system. In particular, this approach avoids the need for either higher-kinded types (e.g. as in this design) or full abstraction over traits (e.g. â€œtraits for traitsâ€). Most of the design challenges are tackled directly using existing features.]]></description><guid isPermaLink="false">42678207-257f-4a9c-868a-ab556d18f9d1</guid><pubDate>Thu, 28 Mar 2019 00:00:28 +0000</pubDate><dc:creator>varkor</dc:creator></item><item><title>Face Detection with Tensorflow Rust</title><link>https://cetra3.github.io/blog/face-detection-with-tensorflow-rust/</link><description><![CDATA[One of the promises of machine learning is to be able to use it for object recognition in photos. This includes being able to pick out features such as animals, buildings and even faces. This article will step you through using some existing models to accomplish face detection using rust and tensorflow.]]></description><guid isPermaLink="false">d10fabc1-ddeb-4ac3-ab03-824bff125807</guid><pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate><dc:creator>cetra3</dc:creator></item><item><title>Using the IOMMU for Safe and Secure User Space Network Drivers</title><link>https://www.net.in.tum.de/members/emmericp/</link><description><![CDATA[Commonly used user space network drivers such as DPDK or Snabb currently have effectivelyfull access to the main memory via the unrestricted Direct Memory Access (DMA) capabilities of the PCI Express (PCIe) device they are controlling. This can be a security issue, as the driver can use the PCIe devices DMA access to read and / or write to main memory. In this thesis, support for using the IOMMU via the vfio-pci driver from the Linux kernel for the user space network driver ixy was implemented in C and Rust and the IOMMU and its impact on the drivers were investigated.]]></description><guid isPermaLink="false">6af41799-4171-46ca-ab1f-572b8669da6e</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Stefan Huber</dc:creator></item><item><title>Generalizing Seqlocks</title><link>https://mtak-blog.github.io/generalizing-seqlocks</link><description><![CDATA[swym is a very performant Software Transactional Memory (STM) library. It uses a variation on the per-object Transactional Locking II algorithm. The paper does an excellent job explaining the algorithm, but it is not required reading for this article. swym is a generalization of seqlocks - one the TL2 paper almost achieves, but does not for whatever reason.]]></description><guid isPermaLink="false">b78c276e-61fa-41c0-90db-b706fe5864e3</guid><pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate><dc:creator>mtak-</dc:creator></item><item><title>Refactoring Varisat: 4. Heuristics</title><link>https://jix.one/refactoring-varisat-4-heuristics/</link><description><![CDATA[This is the fourth post in my series about refactoring varisat. In the last post we saw how conflict driven clause learning works, in this post weâ€™re going to make it fast. To get there we add several smaller features that were already present in varisat 0.1. While there are still some things missing that varisat 0.1 supports, these are features like proof generation or incremental solving that donâ€™t affect the solving performance.]]></description><guid isPermaLink="false">7f497632-cdeb-48fc-b03b-8abe30f7ac6e</guid><pubDate>Thu, 21 Mar 2019 11:46:30 +0100</pubDate><dc:creator>Jannis Harder</dc:creator></item><item><title>Refactoring Varisat: 3. Conflict Driven Clause Learning</title><link>https://jix.one/refactoring-varisat-3-cdcl/</link><description><![CDATA[This is the third post in my series about refactoring varisat. In this post the new code base turns into a working SAT solver. While you can use the command line tool or the library to solve some small and easy SAT problems now, there is still a lot ahead to gain feature and performance parity with varisat 0.1.

In the last post we saw how unit propagation is implemented. When some variables are known, unit propagation allows us to derive the values of new variables or finds a clause that cannot be satisfied. Unit propagation alone isnâ€™t enough though, as there is no guarantee to make progress. To continue the search for a satisfying solution after propagating all assignments, it is necessary to make a guess. A natural way to handle this would be recursion and backtracking. This would give us a variant of the DPLL algorithm from which conflict driven clause learning evolved.]]></description><guid isPermaLink="false">da916659-e0c2-4c4c-a793-b4f7273dcd1f</guid><pubDate>Mon, 18 Mar 2019 20:00:53 +0100</pubDate><dc:creator>Jannis Harder</dc:creator></item><item><title>Scientific computing: a Rust adventure [Part 1 - Zero-cost abstractions]</title><link>https://www.lpalmieri.com/posts/2019-03-12-scientific-computing-a-rust-adventure-part-1-zero-cost-abstractions/</link><description><![CDATA[We left, at the end of the previous episode, with an intuitive understanding of Rustâ€™s ownership system: we worked with vectors of integers, Vec<i32>, and we came up with a naive - but surprisingly fast! - scalar product implementation followed by a very simple sort function using the bubble sort algorithm.

In this episode we will implement a generic version of the same scalar product routine. This will require the introduction of several key concepts concerning Rustâ€™s type system: generics, traits, operators, associated types, Copy.]]></description><guid isPermaLink="false">e448a9b1-396d-4b48-8cba-40419fc3cce6</guid><pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Luca Palmieri</dc:creator></item><item><title>Building fast interpreters in Rust</title><link>https://blog.cloudflare.com/building-fast-interpreters-in-rust/</link><description><![CDATA[we created a configurable Rust library for writing and executing WiresharkÂ®-like filters in different parts of our stack written in Go, Lua, C, C++ and JavaScript Workers. We have now open-sourced this library under our Github account: https://github.com/cloudflare/wirefilter. This post will dive into its design, explain why we didnâ€™t use a parser generator and how our execution engine balances security, runtime performance and compilation cost for the generated filters.]]></description><guid isPermaLink="false">7fa900ce-52d1-494e-b770-ed5ef64aea61</guid><pubDate>Mon,  4 Mar 2019 16:00:00 +0000</pubDate><dc:creator>Ingvar Stepanyan</dc:creator></item><item><title>Oxide: The Essence of Rust</title><link>https://arxiv.org/abs/1903.00982</link><description><![CDATA[Rust is a major advancement in industrial programming languages due in large part to its success in bridging the gap between low-level systems programming and high-level application programming. This success has ultimately empowered programmers to more easily build reliable and efficient software, and at its heart lies a novel approach to ownership that balances type system expressivity with usability.

In this work, we set out to capture the essence of this model of ownership by developing a type systems account of Rust's borrow checker. To that end, we present Oxide, a formalized programming language close to source-level Rust (but with fully-annotated types). This presentation takes a new view of lifetimes as approximate provenances of references, and our type system is able to automatically compute this information through a flow-sensitive substructural typing judgment for which we prove syntactic type safety using progress and preservation. The result is a simpler formulation of borrow checking - including recent features such as non-lexical lifetimes - that we hope researchers will be able to use as the basis for work on Rust.]]></description><guid isPermaLink="false">eac014e1-98a8-4913-9050-5e7a073b8611</guid><pubDate>Sun,  3 Mar 2019 20:22:37 +0000</pubDate><dc:creator>Aaron Weiss, Daniel Patterson, Nicholas D. Matsakis, Amal Ahmed</dc:creator></item><item><title>luster: An experimental Lua VM implemented in pure Rust</title><link>https://www.reddit.com/r/rust/comments/awx9cy/github_kyrenluster_an_experimental_lua_vm/</link><description><![CDATA[ What I want to talk about though (and what I will eventually write a blog post about) is the technique that I'm using in luster for safe garbage collection. Inside luster are two libraries called "gc-arena" and "gc-sequence", and they represent a new (I believe novel?) system for safe garbage collection in Rust. There have been several attempts here before such as rust-gc and shifgrethor, and this represents another attempt with... different? limitations more appropriate for implementing language runtimes like Lua.]]></description><guid isPermaLink="false">17e95b5e-6cd8-4f98-8030-c923e69897cb</guid><pubDate>Mon,  4 Mar 2019 06:26:29 +1100</pubDate><dc:creator>Catherine West</dc:creator></item><item><title>Refactoring Varisat: 2. Clause Storage and Unit Propagation</title><link>https://jix.one/refactoring-varisat-2-clause-storage-and-unit-propagation/</link><description><![CDATA[This is the second post in my series about refactoring varisat. Since the last post I started implementing some of the core data structures and algorithms of a CDCL based SAT solver: clause storage and unit propagation. In this post I will explain how the these parts work and the rationale behind some of the decisions I made.]]></description><guid isPermaLink="false">31d81292-5ae5-4462-8f26-ca156d625f40</guid><pubDate>Sat,  2 Mar 2019 18:18:04 +0100</pubDate><dc:creator>Jannis Harder</dc:creator></item><item><title>Scientific computing: a Rust adventure [Part 0 - Vectors]</title><link>https://www.lpalmieri.com/posts/2019-02-23-scientific-computing-a-rust-adventure-part-0-vectors/</link><description><![CDATA[My daily work revolves around building Machine Learning applications, while a lot of my evenings have been spent experimenting with Rust, getting more and more fascinated and in love with the language.

It couldnâ€™t be helped: I started to have a look at what the Rust ecosystem had to offer for Machine Learning, Big Data and scientific computing at large. I quickly found out that there is a lot to be done and a lot of potential (see here or here). It got me really fired up ðŸ”¥]]></description><guid isPermaLink="false">8d4c090f-e6e3-4975-abe7-385479579cfa</guid><pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Luca Palmieri</dc:creator></item><item><title>Procedural Generation with Wave Function Collapse</title><link>https://gridbugs.org/wave-function-collapse/</link><description><![CDATA[Wave Function Collapse is a procedural generation algorithm which produces images by arranging a collection of tiles according to rules about which tiles may be adjacent to each other tile, and relatively how frequently each tile should appear. The algorithm maintains, for each pixel of the output image, a probability distribution of the tiles which may be placed there. It repeatedly chooses a pixel to â€œcollapseâ€ - choosing a tile to use for that pixel based on its distribution. WFC gets its name from quantum physics. The goal of this post is to build an intuition for how and why the WFC algorithm works.]]></description><guid isPermaLink="false">2c967b7c-6987-45ae-96b1-776ee6c51011</guid><pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Stephen Sherratt</dc:creator></item><item><title>Scannerless parsing of boolean grammars with derivatives in Rust</title><link>https://github.com/jameysharp/weighted-regexp-rs/blob/master/README.md</link><description><![CDATA[This is yet another library for writing parsers in Rust. What makes this one different is that I've combined some existing academic work in a way that I think is novel. The result is an unusually flexible parsing library while still offering competitive performance and memory usage.]]></description><guid isPermaLink="false">ad9d038f-52e6-4860-a264-61a795428b87</guid><pubDate>Sun,  6 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Jamey Sharp</dc:creator></item><item><title>Leveraging Rust types for modular specification and verification</title><link>https://www.research-collection.ethz.ch/handle/20.500.11850/311092</link><description><![CDATA[Rustâ€™s type system ensures memory safety: well-typed Rust programs are guaranteed to not exhibit problems such as dangling pointers, data races, and unexpected side effects through aliased references. Going beyond memory safety, for instance, to guarantee the absence of assertion failures or functional correctness, requires static program verification. Formal verification of system software is notoriously difficult and requires complex specifications and logics to reason about pointers, aliasing, and side effects on mutable state. This complexity is a major obstacle to a more widespread verification of system software.

In this paper, we present a novel verification technique that leverages Rustâ€™s type system to greatly simplify the specification and verification of Rust programs. We analyse information from the Rust compiler and synthesise a corresponding core proof for the program in a flavour of separation logic tailored to automation. Crucially, our proofs are constructed and checked automatically; users of our work never work with the underlying formal logic. Users can add specifications at the abstraction level of Rust expressions; we show how to interweave these to extend our core proof to prove modularly whether these specifications are correct. We have implemented our technique for a subset of Rust; our initial evaluation on two thousand functions from widely-used Rust crates demonstrates its effectiveness]]></description><guid isPermaLink="false">d282adbf-dce7-4fbb-86e5-2d33df229932</guid><pubDate>Mon, 17 Dec 2018 07:00:47 +0000</pubDate><dc:creator>Astrauskas, Vytautas; MÃ¼ller, Peter; Poli, Federico; Summers, Alexander</dc:creator></item><item><title>The Swiss Army Knife of Hashmaps</title><link>https://blog.waffles.space/2018/12/07/deep-dive-into-hashbrown/</link><description><![CDATA[A while back, there was a discussion comparing the performance of using the hashbrown crate (based on Googleâ€™s SwissTable implementation) in the Rust compiler. In the last RustFest, Amanieu was experimenting on integrating his crate into stdlib, which turned out to have some really promising results. As a result, itâ€™s being planned to move the crate into stdlib.

While the integration is still ongoing, thereâ€™s currently no blog post out there explaining SwissTable at the moment. So, I thought Iâ€™d dig deeper into the Rust implementation to try and explain how its (almost) identical twin hashbrown::HashMap works.]]></description><guid isPermaLink="false">4ea6d02a-6279-4eef-af2f-bd67424d6de8</guid><pubDate>Fri,  7 Dec 2018 16:58:46 +0000</pubDate><dc:creator>Ravi Shankar</dc:creator></item><item><title>Shifgrethor IV: Tracing</title><link>https://boats.gitlab.io/blog/post/shifgrethor-iv/</link><description><![CDATA[The post before this one covered how shifgrethor handles rooting: how we track for the garbage collector that this object is alive. That isnâ€™t sufficient for implementing a tracing garbage collector though: the idea of a tracing garbage collector is that we can trace from rooted objects through all of the objects they reference. That way, instead of having to root everything you use, you can only root a few objects from which all of the live objects can be traced.]]></description><guid isPermaLink="false">57fd5a7a-0eb0-43fd-bf99-5b8a6a0e782c</guid><pubDate>Wed, 31 Oct 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Shifgrethor III: Rooting</title><link>https://boats.gitlab.io/blog/post/shifgrethor-iii/</link><description><![CDATA[After the digression in the previous post, itâ€™s time to get back to what I promised in the first post: a look at how shifgrethor handles rooting. Shifgrethorâ€™s solution is somewhat novel and takes advantage of some of Rustâ€™s specific features, so I want to start by looking briefly at some of the other options.]]></description><guid isPermaLink="false">88e3b29b-1f9a-41a2-bb8a-9f73310c0352</guid><pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Shifgrethor I: Garbage collection as a Rust library</title><link>https://boats.gitlab.io/blog/post/shifgrethor-i/</link><description><![CDATA[Iâ€™m really excited to share with you an experiment that Iâ€™ve been working on for the past 5 or 6 weeks. Itâ€™s a Rust library called shifgrethor. shifgrethor implements a garbage collector in Rust with an API I believe to be properly memory safe.
Iâ€™ll be going through all of the technical details in future blog posts, so I want to kick this series off with a high level overview of the projectâ€™s purpose and design decisions.]]></description><guid isPermaLink="false">b138af7a-2e74-44c1-b362-03af475f050b</guid><pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Noria: dynamic, partially-stateful data-flow for high-performance web applications</title><link>https://www.usenix.org/conference/osdi18/presentation/gjengset</link><description><![CDATA[We introduce partially-stateful data-flow, a new streaming data-flow model that supports eviction and reconstruction of data-flow state on demand. By avoiding state explosion and supporting live changes to the data-flow graph, this model makes data-flow viable for building long-lived, low-latency applications, such as web applications. Our implementation, Noria, simplifies the backend infrastructure for read-heavy web applications while improving their performance.

A Noria application supplies a relational schema and a set of parameterized queries, which Noria compiles into a data-flow program that pre-computes results for reads and incrementally applies writes. Noria makes it easy to write high-performance applications without manual performance tuning or complex-to-maintain caching layers. Partial statefulness helps Noria limit its in-memory state without prior data-flow systemsâ€™ restriction to windowed state, and helps Noria adapt its data-flow to schema and query changes while on-line. Unlike prior data-flow systems, Noria also shares state and computation across related queries, eliminating duplicate work.

On a real web applicationâ€™s queries, our prototype scales to 5Ã— higher load than a hand-optimized MySQL baseline. Noria also outperforms a typical MySQL/memcached stack and the materialized views of a commercial database. It scales to tens of millions of reads and millions of writes per second over multiple servers, outperforming a state-of-the-art streaming data-flow system.]]></description><guid isPermaLink="false">b2cb0409-6147-4d84-8261-734f17fda39c</guid><pubDate>Tue,  9 Oct 2018 11:14:00 +0000</pubDate><dc:creator>Jon Gjengset, Malte Schwarzkopf, Jonathan Behrens, and Lara TimbÃ³ AraÃºjo</dc:creator></item><item><title>Travel The World Using Partially-Mapped (PMX) Crossover in Rust And JavaScript</title><link>https://blog.x5ff.xyz/blog/ai-rust-javascript-pmx/</link><description><![CDATA[Implementing a genetic algorithm in JavaScript and Rust.]]></description><guid isPermaLink="false">f7523f30-31c4-4699-9071-ec6f7ccd1049</guid><pubDate>Sun, 26 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Claus</dc:creator></item><item><title>So You Want to Build a Language VM in Rustâ€Š-â€ŠPart 00</title><link>https://medium.com/iridium-vm/so-you-want-to-build-a-language-vm-part-0-f9132f611a1b</link><description><![CDATA[Hi there! This is the prelude to a series of posts to detailing how to build a language VM. If you are familiar with terms like registers, program counter, and assembly, feel free to skip this post. If not, read on. Please note this is nowhere near comprehensive, but enough to understand what weâ€™re building.]]></description><guid isPermaLink="false">f025d0a3-cc4c-45c7-9587-71057b3d9cbf</guid><pubDate>Fri, 17 Aug 2018 19:59:12 +0000</pubDate><dc:creator>Fletcher Haynes</dc:creator></item><item><title>Rust needs BFGS. What is BFGS?</title><link>https://paulkernfeld.com/2018/08/06/rust-needs-bfgs.html</link><description><![CDATA[There is no general â€œbestâ€ way to minimize a function; different kinds of functions require different strategies. However, Pythonâ€™s scipy and Râ€™s optim both prominently feature an algorithm called BFGS. Iâ€™ll explain what BFGS stands for, the problem that it solves, and how it solves it.]]></description><guid isPermaLink="false">1af176be-1d98-419b-85d5-dfbf78cb74df</guid><pubDate>Mon,  6 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Verifying Rust Programs with SMACK</title><link>http://soarlab.org/2018/07/atva2018-bhr/</link><description><![CDATA[Rust is an emerging systems programming language with guaranteed memory safety and modern language features that has been extensively adopted to build safety-critical software. However, there is currently a lack of automated software verifiers for Rust. In this work, we present our experience extending the SMACK verifier to enable its usage on Rust programs. We evaluate SMACK on a set of Rust programs to demonstrate a wide spectrum of language features it supports.]]></description><guid isPermaLink="false">2ff6e0ef-6a4a-4644-bb22-e6e7858955f9</guid><pubDate>Mon, 30 Jul 2018 20:39:49 +0000</pubDate><dc:creator>Marek Baranowski, Shaobo He, Zvonimir Rakamaric</dc:creator></item><item><title>So You Want to Build a Language VM - Part 00</title><link>https://blog.subnetzero.io/post/building-language-vm-part-00/</link><description><![CDATA[A Brief Course in Computer Hardware. This is the prelude to a series of posts to detailing how to build a language VM. If you are familiar with terms like registers, program counter, and assembly, feel free to skip this post. If not, read on.]]></description><guid isPermaLink="false">c7f57579-ce36-4d54-86a4-9aa4a6c1cadd</guid><pubDate>Mon, 16 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Fletcher Haynes</dc:creator></item><item><title>Logistic Regression in Rust</title><link>http://paulkernfeld.com/2018/07/01/logistic-regression-in-rust.html</link><description><![CDATA[This weekend, I implemented logistic regression in Rust. For me, the most interesting parts were learning how to implement a stopping condition and how to automatically set a step size.]]></description><guid isPermaLink="false">b63f8372-7dbc-4bf5-9ab3-e13a95a011be</guid><pubDate>Sun,  1 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Genetic Algorithms in Rust for Autonomous Agents: An Introduction</title><link>https://medium.com/coinmonks/genetic-algorithms-in-rust-for-autonomous-agents-an-introduction-ac182de32aee</link><description><![CDATA[This article discusses a possible genetic algorithm implementation in Rust applied to the travelling salesman problem.]]></description><guid isPermaLink="false">16b43079-6e0d-4c7e-9ea3-00cf0405bf49</guid><pubDate>Sat, 30 Jun 2018 14:09:48 +0000</pubDate><dc:creator>Mithi</dc:creator></item><item><title>[1807.00067] Josephine: Using JavaScript to safely manage the lifetimes of Rust data</title><link>https://arxiv.org/abs/1807.00067</link><description><![CDATA[This paper is about the interface between languages which use a garbage collector and those which use fancy types for safe manual memory management. Garbage collection is the traditional memory management scheme for functional languages, whereas type systems are now used for memory safety in imperative languages. We use existing techniques for linear capabilities to provide safe access to copyable references, but the application to languages with a tracing garbage collector, and to data with explicit lifetimes is new. This work is related to mixed linear/non-linear programming, but the languages being mixed are Rust and JavaScript.]]></description><guid isPermaLink="false">04445b84-5c91-467e-840c-45df1765c4e6</guid><pubDate>Fri, 29 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Alan Jeffrey</dc:creator></item><item><title>How Usable are Rust Cryptography APIs?</title><link>https://arxiv.org/abs/1806.04929</link><description><![CDATA[Poor usability of cryptographic APIs is a severe source of vulnerabilities. Aim: We wanted to find out what kind of cryptographic libraries are present in Rust and how usable they are. Method: We explored Rust's cryptographic libraries through a systematic search, conducted an exploratory study on the major libraries and a controlled experiment on two of these libraries with 28 student participants. Results: Only half of the major libraries explicitly focus on usability and misuse resistance, which is reflected in their current APIs. We found that participants were more successful using rust-crypto which we considered less usable than ring before the experiment. Conclusion: We discuss API design insights and make recommendations for the design of crypto libraries in Rust regarding the detail and structure of the documentation, higher-level APIs as wrappers for the existing low-level libraries, and selected, good-quality example code to improve the emerging cryptographic libraries of Rust.]]></description><guid isPermaLink="false">ab3d6484-4107-4555-a9b0-0f1aa6ae9a18</guid><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Kai Mindermann, Philipp Keck, Stefan Wagner</dc:creator></item><item><title>Generic associated types in iterators</title><link>https://boiethios.gitlab.io/blog/2018-06-21_GATs_iterators.html</link><description><![CDATA[In this article, I want to explain the term Generic Associated Types through a concrete example. I noticed that people (especially in video games development) need some tools to iterate in various manners mutably, efficiently and safely. I tried to write some convenient iterators over vectors and slices that solve those problems, but finally, I understood that some tools cannot be written with std::iter::Iterator. Doing so led me to the comprehension of generic associated types that I will abbreviate as GATs in this article. I will explain here what GATs are and why they are needed.]]></description><guid isPermaLink="false">6c71975e-3550-410a-99e7-2ee9635fb0e6</guid><pubDate>Thu, 21 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Boiethios</dc:creator></item><item><title>Rust Distilled: An Expressive Tower of Languages</title><link>https://arxiv.org/abs/1806.02693</link><description><![CDATA[Rust represents a major advancement in production programming languages because of its success in bridging the gap between high-level application programming and low-level systems programming. At the heart of its design lies a novel approach to ownership that remains highly programmable.

In this talk, we will describe our ongoing work on designing a formal semantics for Rust that captures how programmers can understand ownership and borrowing without trying to grasp the details of lifetime analysis.]]></description><guid isPermaLink="false">a07d66f5-dfd3-41d4-b2d8-16bf1b0f4886</guid><pubDate>Thu,  7 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Weiss, Daniel Patterson, Amal Ahmed</dc:creator></item><item><title>Modern Parser Generator</title><link>https://matklad.github.io/2018/06/06/modern-parser-generator.html</link><description><![CDATA[During the last couple of years, Iâ€™ve spent a lot of time writing parsers and parser generators, and I want to write down my thoughts about this topic. Specifically, I want to describe some properties of a parser generator that I would enjoy using. Note that this is not an â€œintroduction to parsingâ€ blog post, some prior knowledge is assumed.]]></description><guid isPermaLink="false">6f104d56-9b00-4748-a04f-0c77ec89a1d2</guid><pubDate>Wed,  6 Jun 2018 16:03:25 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>TensorScript Type Inference: Hindley-Milner in Rust</title><link>http://rickyhan.com/jekyll/update/2018/05/26/hindley-milner-tutorial-rust.html</link><description><![CDATA[Type-inferred gradually typed languages are a joy to use: easy to write, analyze, and refactor. In this blog post, I will showcase to the other dozen of programmers who are interested in the obscure art of programming language type inference.]]></description><guid isPermaLink="false">bfb80762-37e6-4337-83c9-52f371839e60</guid><pubDate>Sat, 26 May 2018 04:00:00 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>Implement Raft in Rust</title><link>https://pingcap.com/blog/implement-raft-in-rust/</link><description><![CDATA[Consensus is one of the most important challenges in designing and building distributed systemsâ€“how to make sure multiple nodes (or agents, processes, threads, tasks, participants, etc.) in a group agree on a specific value proposed by at least one of the nodes. As an open-source distributed scalable HTAP database, TiDB uses the Raft Consensus Algorithm in its distributed transactional key-value storage engine, TiKV, to ensure data consistency, auto-failover, and fault tolerance.]]></description><guid isPermaLink="false">91a4f766-391d-43fc-a2ce-66354ac78bd4</guid><pubDate>Tue, 22 May 2018 00:00:00 +0000</pubDate><dc:creator>Siddon Tang</dc:creator></item><item><title>Oblix: An Efficient Oblivious Search Index [pdf]</title><link>https://people.eecs.berkeley.edu/~raluca/oblix.pdf</link><description><![CDATA[Abstractâ€”Search indices are fundamental building blocks of many systems, and there is great interest in running them on encrypted data. Unfortunately, many known schemes that enable search queries on encrypted data achieve efficiency at the expense of security, as they reveal access patterns to the encrypted data.  In this paper we present Oblix, a search index for encrypted data that is oblivious (provably hides access patterns), is dynamic (supports inserts and deletes), and has good efficiency.  Oblix relies on a combination of novel oblivious-access tech- niques and recent hardware enclave platforms (e.g., Intel SGX).  In particular, a key technical contribution is the design and implementation of doubly-oblivious data structures, in which the clientâ€™s accesses to its internal memory are oblivious, in addition to accesses to its external memory at the server. These algorithms are motivated by hardware enclaves like SGX, which leak access patterns to both internal and external memory.  We demonstrate the usefulness of Oblix in several applications: private contact discovery for Signal, private retrieval of public keys for Key Transparency, and searchable encryption that hides access patterns and result sizes.]]></description><guid isPermaLink="false">e2724828-a6e9-4383-9614-bea31e743784</guid><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate><dc:creator>Pratyush Mishra, Rishabh Poddar, Jerry Chen, Alessandro Chiesa, Raluca Ada Popa</dc:creator></item><item><title>Cannoli: A Python Compiler Written in Rust [pdf]</title><link>https://github.com/joncatanio/cannoli/raw/master/resources/papers/cannoli-thesis-paper.pdf</link><description><![CDATA[I just finished my Master's Thesis and part of it was writing a Python compiler in Rust. The goal of the thesis was to evaluate language features of Python that were hypothesized to cause performance issues. Quantifying the cost of these features could be valuable to language designers moving forward. Some interesting results were observed when implementing compiler optimizations for Python. An average speedup of 51% was achieved across a number of benchmarks.]]></description><guid isPermaLink="false">c7a4923a-2a12-4f88-82fc-4b99b94080e9</guid><pubDate>Thu, 17 May 2018 16:00:59 +0000</pubDate><dc:creator>Jonathan Catanio</dc:creator></item><item><title>Bulletproof Multi-Party Computation in Rust with Session Types</title><link>https://blog.chain.com/bulletproof-multi-party-computation-in-rust-with-session-types-b3da6e928d5d</link><description><![CDATA[In Rust, objects are either owned or borrowed. While there can be multiple borrows of the same object, each object has a unique owner. When objects are passed by value, ownership is transferred to the new scope, and the old scope can no longer access it. This makes it possible to implement â€œconsumingâ€ methods which take self by value, and therefore can only be called once. In the party and dealer types, such methods consume the previous state and return the next state in the protocol.]]></description><guid isPermaLink="false">0308ada3-604c-4240-8e94-2f9d23bc2934</guid><pubDate>Fri, 11 May 2018 22:25:19 +0000</pubDate><dc:creator>Cathie Yun</dc:creator></item><item><title>KRust: A Formal Executable Semantics of Rust</title><link>https://arxiv.org/abs/1804.10806</link><description><![CDATA[Rust is a new and promising high-level system programming language. It provides both memory safety and thread safety through its novel mechanisms such as ownership, moves and borrows. Ownership system ensures that at any point there is only one owner of any given resource. The ownership of a resource can be moved or borrowed according to the lifetimes. The ownership system establishes a clear lifetime for each value and hence does not necessarily need garbage collection. These novel features bring Rust high performance, fine low-level control of C and C++, and unnecessity in garbage collection, which differ Rust from other existing prevalent languages. For formal analysis of Rust programs and helping programmers learn its new mechanisms and features, a formal semantics of Rust is desired and useful as a fundament for developing related tools. In this paper, we present a formal executable operational semantics of a realistic subset of Rust, called KRust. The semantics is defined in K, a rewriting-based executable semantic framework for programming languages. The executable semantics yields automatically a formal interpreter and verification tools for Rust programs. KRust has been thoroughly validated by testing with hundreds of tests, including the official Rust test suite.]]></description><guid isPermaLink="false">0c0d7114-9e80-4e4f-868d-51de6778bed1</guid><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Feng Wang, Fu Song, Min Zhang, Xiaoran Zhu, Jun Zhang</dc:creator></item><item><title>QCGPU - Hardware Accelerated Quantum Computer Simulation</title><link>https://qcgpu.github.io/</link><description><![CDATA[A software library for high performance and hardware accelerated simulation of Quantum Computers and Algorithms. Written with Rust and OpenCL.]]></description><guid isPermaLink="false">ed19c2a7-fe9d-465b-b41a-71480e6b978a</guid><pubDate>Wed, 11 Apr 2018 06:47:00 +1000</pubDate><dc:creator>QCGPU</dc:creator></item><item><title>Safe Intrusive Collections with Pinning</title><link>https://www.ralfj.de/blog/2018/04/10/safe-intrusive-collections-with-pinning.html</link><description><![CDATA[In my last post, I talked about the new â€œpinned referencesâ€ which guarantee that the data at the memory it points to will not, ever, be moved elsewhere. I explained how they enable giving a safe API to code that could previously only be exposed with unsafe, and how one could go about proving such a thing. This post is about another application of pinned referencesâ€”another API whose safety relies on the pinning guarantees: Intrusive collections. It turns out that pinned references can almost be used for this, but not quite. However, this can be fixed by extending the guarantees provided by pinned references, as suggested by @cramertj.]]></description><guid isPermaLink="false">68ff8b22-500f-4674-b9f0-b70414db12d8</guid><pubDate>Tue, 10 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Writing a recursive ascent parser by hand</title><link>https://www.abubalay.com/blog/2018/04/08/recursive-ascent</link><description><![CDATA[Iâ€™ve been exploring various ways to write parsers. For a long time, Iâ€™ve used hand-written recursive descent for its straightforwardness, flexibility, and performance. There is another wayâ€”parser generators like Menhir, LALRPOP, or the venerable Bison use the bottom-up LR algorithm. I decided I would try an experiment: write an LR parser by hand, and see how readable I could make it.]]></description><guid isPermaLink="false">66851aee-1bf3-4b18-b1aa-50f79ce773f4</guid><pubDate>Sun,  8 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Russell Johnston</dc:creator></item><item><title>im - Immutable Data Structures for Rust</title><link>https://docs.rs/im/10.0.0/im/</link><description><![CDATA[This library implements several of the more commonly useful immutable data structures for Rust. They rely on structural sharing to keep most operations fast without needing to mutate the underlying data store, leading to more predictable code without necessarily sacrificing performance.]]></description><guid isPermaLink="false">318f9d08-d86a-4799-ac08-75014d089475</guid><pubDate>Fri,  6 Apr 2018 21:06:00 +0000</pubDate><dc:creator>Bodil Stokke</dc:creator></item><item><title>Sound and ergonomic specialization for Rust</title><link>http://aturon.github.io/2018/04/05/sound-specialization/</link><description><![CDATA[Specialization holds the dubious honor of being among the oldest post-1.0 features remaining in unstable limbo. Thatâ€™s for good reason, though: until recently, we did not know how to make it sound.]]></description><guid isPermaLink="false">e01d9c09-e66d-4fea-94e3-95db24137dd6</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Writing the Perfect &apos;Collect&apos; Trait</title><link>https://mtak-blog.github.io/the_perfect_collect_trait</link><description><![CDATA[Iâ€™ve been spending some time thinking about garbage collection in rust. I know, shame on me, itâ€™s a systems language, we hate garbage collection, butâ€¦ even in a systems programming language, garbage collection is still pretty damn useful.]]></description><guid isPermaLink="false">4812042b-1d2a-4171-9a77-d2f0a0c44b91</guid><pubDate>Thu,  5 Apr 2018 00:00:00 +0000</pubDate><dc:creator>mtak-blog</dc:creator></item><item><title>Number Theory using Rust&apos;s type system</title><link>https://shingtaklam1324.github.io/number-theory-rust/</link><description><![CDATA[Rust does not have dependent types, or GADTs like Haskell, but with a few tricks, we can use Rust's type system to emulate an Idris-like number system.]]></description><guid isPermaLink="false">465a729e-a243-4cd7-bee8-e0c7d5d09fbd</guid><pubDate>Sun, 18 Mar 2018 00:00:00 +1100</pubDate><dc:creator>shingtaklam1324</dc:creator></item><item><title>stencil; abstract stencil calculation</title><link>https://dev.to/termoshtt/stencil-abstract-stencil-calculation-i2m</link><description><![CDATA[I am developing a library for stencil calculation in Rust.]]></description><guid isPermaLink="false">17b6e878-388f-40c5-93a0-cf3da64a1078</guid><pubDate>Sat, 17 Mar 2018 00:00:00 +0000</pubDate><dc:creator>termoshtt</dc:creator></item><item><title>Fast Search Through Metric Spaces with Rust and BK Trees</title><link>https://www.innoq.com/en/blog/looks-the-same-to-me/</link><description><![CDATA[In the previous post, pHash helped us to summarize our photo album. Now itâ€™s time to employ BK-trees and efficiently search through the metric space of perceptual hashes. Letâ€™s roll up the sleeves; more Rust awaits!]]></description><guid isPermaLink="false">d377bc0d-a127-456d-81fa-926fe634de0f</guid><pubDate>Thu,  1 Mar 2018 00:00:00 +0100</pubDate><dc:creator>Jan StÄ™pieÅ„</dc:creator></item><item><title>Reasoning with Types in Rust</title><link>https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html</link><description><![CDATA[Rust is a modern programming language which is marketed primarily on the basis of its very nice type system, and Iâ€™d like to tell you about how you can use this type system to reason about your programs in interesting ways. Most of the time when its type system is discussed, the focus is on its guarantee of data race freedom and ability to enable so-called fearless concurrency (and rightfully soâ€”this is a place where Rust truly shines!). Today, I have a different focus in mind, characterized perhaps most succinctly as follows:]]></description><guid isPermaLink="false">5e572868-98d0-4944-b897-14cca13a39a4</guid><pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Weiss</dc:creator></item><item><title>Combine 3 - Partial parsing in Rust</title><link>https://marwes.github.io/2018/02/08/combine-3.html</link><description><![CDATA[Combine is a parser combinator library for the Rust programming language. I first announced version 3 of Combine back in August and back then I definitely expected to have a stable version by now. However other projects (cough gluon cough) got in the way and Combine fell to the wayside. It didnâ€™t help that I didnâ€™t have a killer feature for 3.0 either, user-defined error types make it possible to define parsers usable in #[no_std] crates which is great when you need it but it is still a fairly niche use-case.]]></description><guid isPermaLink="false">29eb1ede-d551-4b8d-aeec-c673aafb7e8f</guid><pubDate>Thu,  8 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Markus Westerlind</dc:creator></item><item><title>Memory Safety in Rust: A Case Study with C</title><link>http://willcrichton.net/notes/rust-memory-safety/</link><description><![CDATA[To demonstrate the value of Rust's memory safety rules, I contrast the implementation of a simple vector library in C and Rust, highlighting where and how Rust's static analysis can prevent tricky memory errors.]]></description><guid isPermaLink="false">d2fc34d4-c1ec-4c3d-8e39-b420b8f20fe8</guid><pubDate>Fri,  2 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Will Crichton</dc:creator></item></channel></rss>