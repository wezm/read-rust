{
  "version": "https://jsonfeed.org/version/1",
  "title": "Read Rust - DevOps and Deployment",
  "home_page_url": "https://readrust.net/",
  "feed_url": "https://readrust.net/devops-and-deployment/feed.json",
  "description": "DevOps and Deployment posts on Read Rust",
  "author": {
    "name": "Wesley Moore",
    "url": "http://www.wezm.net/"
  },
  "items": [
    {
      "id": "1f771485-fadd-4dfe-8730-1a4b81a856d0",
      "title": "SpO‚ÇÇ the little dynamic monitoring tool",
      "content_text": "At Meili, we needed a tool that allows us to monitor our pods, we already have vigil which health checks our front page and backend, but the number of these services is limited. We do not pop new front or backend servers dynamically (for now). When we create new search engines for the user we instanciate a kubernetes pod, we need to monitor the health of this service. Adding each of those URLs by hand in the vigil config file is not a solution.\n\nSo we decided that we needed a simple tool, a tool that can accept HTTP requests to register/unregister URLs to health check. We use the new async/await Rust syntax along with tide for the http server, no big deal here.",
      "url": "https://blog.meilisearch.com/spo2-the-little-dynamic-monitoring-tool/",
      "date_published": "2019-10-18T15:53:16+00:00",
      "author": {
        "name": "Cl√©ment Renault",
        "url": "https://blog.meilisearch.com/author/clement/"
      },
      "tags": [
        "DevOps and Deployment",
        "Web and Network Services"
      ]
    },
    {
      "id": "46223027-91fb-4320-a25a-02df60a68461",
      "title": "How to publish your Rust project on Homebrew",
      "content_text": "Last week I finally released the first version of espanso, a cross-platform, system-wide Text Expander written in Rust. I‚Äôve built many projects in my life, but this time I wanted to create something people would actually use. Therefore, one of the key aspects to consider was the installation process: it has to be easy. Being a cross-platform tool, I had to consider the best installation method for each platform and when it comes to macOS, the de-facto way to install a cli tool is by using Homebrew. In this article I will show you the publishing process I used for my tool, espanso.",
      "url": "https://federicoterzi.com/blog/how-to-publish-your-rust-project-on-homebrew/",
      "date_published": "2019-10-06T00:00:00+00:00",
      "author": {
        "name": "Federico Terzi",
        "url": "https://federicoterzi.com/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "4250d5cd-9d22-43c1-b613-b8efaf94a3ee",
      "title": "GitHub Actions for Rust",
      "content_text": "A few weeks ago I got beta access to the GitHub CI/CD platform called Actions. For my own Rust projects I was using Travis CI mostly before and had started migrating to the Azure Pipelines recently, but now I‚Äôm considering moving to the Actions instead.\n\nConfiguration syntax is a bit nicer comparing to Azure one, there are Linux, macOS and Windows environments available (pretty much as everywhere now) and integration with other GitHub parts is just amazing. But the most important thing there for me is a possibility to create ‚ÄúActions‚Äù ‚Äî custom tasks to be executed in the CI workflow.",
      "url": "https://svartalf.info/posts/2019-09-16-github-actions-for-rust/",
      "date_published": "2019-09-16T00:00:00+00:00",
      "author": {
        "name": "Nikita Kuznetsov",
        "url": "https://svartalf.info/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "bce3d472-5591-44cc-b52a-2573bf8d9f55",
      "title": "Compiling Rust Apps for Termux with nix-shell",
      "content_text": "I've been building a program to track how I spend my time, and a couple of the requirements are an interface on my phone, and sync between multiple devices. Since I haven't built an android app in forever, I decided to target termux, at least initially. This will allow me to use the app and test out the synchronization protocol without a ton of upfront effort into building a graphical user interface.",
      "url": "https://blog.geemili.xyz/blog/rust-app-on-termux-with-nix/",
      "date_published": "2019-06-29T06:54:28-05:00",
      "author": {
        "name": "LeRoyce Pearson",
        "url": "https://geemili.xyz/blog/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "dd7226ff-eb20-4edf-b420-9e6bdecf4ddc",
      "title": "Automating Rust and NodeJS deployment on AWS Lambda using layers",
      "content_text": "Part of our stack at Clevy is written in Rust, and we use Neon to ease the bindings with other parts of the stack written in NodeJS. Recently, we needed to deploy this stack on AWS Lambda, which runs a very specific NodeJS runtime, not cross-compatible with our existing stack. Since we struggled a little bit with getting Lambda/Rust/Node to play nicely together, I figured I would post a short how-to of what we found worked well for us. You can of course take this as a base and change it to your liking!",
      "url": "https://medium.com/clevyio/automating-rust-and-nodejs-deployment-on-aws-lambda-using-layers-2d47d129a6bc",
      "date_published": "2019-06-06T11:28:57.140+00:00",
      "author": {
        "name": "Francois Falala-Sechet",
        "url": "https://medium.com/@frsechet"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "c26ac9a2-3fbe-4cb3-b845-58e08b05502c",
      "title": "A generic kubernetes client",
      "content_text": "It‚Äôs been about a month since we released kube, a new rust client library for kubernetes. We covered the initial release, but it was full of naive optimism and uncertainty. Would the generic setup work with native objects? How far would it extend? Non-standard objects? Patch handling? Event handling? Surely, it‚Äôd be a fools errand to write an entire client library?",
      "url": "https://clux.github.io/probes/post/2019-06-04-towards-a-generic-kube-client/",
      "date_published": "2019-06-04T00:00:00+00:00",
      "author": {
        "name": "clux",
        "url": "https://clux.github.io/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "2c6b8329-385a-4e19-ba91-4c84b1ebf4bc",
      "title": "How to Package Rust Applications Into Minimal Docker Containers",
      "content_text": "In the Go world, it is common to use docker‚Äôs multi-stage build feature to produce the app‚Äôs docker image in two stages. The first stage uses the golang image and is where we build the application into a statically-linked binary. Once built, we copy the binary into a scratch container in the second stage. The result is a rather small image that has nothing other than the application.\n\nI was looking to do the same thing for my Rust application. While I was at it, I also wanted to leverage the docker build cache to avoid having to download crates on every docker build.",
      "url": "https://alexbrand.dev/post/how-to-package-rust-applications-into-minimal-docker-containers/",
      "date_published": "2019-06-01T09:00:00-04:00",
      "author": {
        "name": "Alexander Brand",
        "url": "https://alexbrand.dev/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "350dfd1b-e2c5-4a2b-9b2d-015d933e7a78",
      "title": "Rust caching on CircleCI using sccache",
      "content_text": "If you are working in a team that‚Äôs writing Rust code and your crates have a good amount of dependencies, you have probably noticed that the Rust compilation phase takes a non-trivial amount of time in comparison to actually running your tests: it is indeed one of the top recurring complains that gets reported to the language team.\n\nIn a CI environment, it gets worse as the testing container starts building pretty much from scratch and everything gets recompiled. One way to alleviate that problem is to cache Rust compiled intermediate objects",
      "url": "https://medium.com/@edouard.oger/rust-caching-on-circleci-using-sccache-c996344f0115",
      "date_published": "2019-05-03T21:42:28.171+00:00",
      "author": {
        "name": "Edouard Oger",
        "url": "https://medium.com/@edouard.oger"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "bd254733-37d6-4ef1-959d-67ca2ccfc2ca",
      "title": "Rust: How to build a Docker image with private Cargo dependencies",
      "content_text": "In this article, I‚Äôm going to show you how to fetch private Cargo dependencies and source them when building a Docker image. This solves a key issue with Docker of not copying over SSH keys when building an image.",
      "url": "https://medium.com/@c_ameron/rust-how-to-build-a-docker-image-with-private-cargo-dependencies-ab91c25c4301",
      "date_published": "2019-05-01T04:08:50.966+00:00",
      "author": {
        "name": "Cameron",
        "url": "https://medium.com/@c_ameron"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "b4cd814f-2f84-4e4d-b3a1-bba98d6a24f2",
      "title": "Kubernetes operators in Rust",
      "content_text": "Writing light weight cloud services without Go.",
      "url": "https://clux.github.io/probes/post/2019-04-29-rust-on-kubernetes/",
      "date_published": "2019-04-29T00:00:00+00:00",
      "author": {
        "name": "clux",
        "url": "https://clux.github.io/probes/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "ef4b2e3e-406a-4553-9c49-3676c83eae96",
      "title": "Leveraging Travis-CI for Continuous Deployment to Publish Compiled Binaries to GitHub",
      "content_text": "Recently I wrote a binary called \"Watchdog\" in Rust on my Mac that I wanted to take with me to Linux systems I frequent, but I couldn't bring a Rust compiler to these systems for unrelated reasons. This meant I had to cross-compile my application and ship just the binary.",
      "url": "https://dev.to/hawkinjs/leveraging-travis-ci-for-continuous-deployment-to-publish-compiled-binaries-to-github-2k06",
      "date_published": "2019-04-25T00:00:00+00:00",
      "author": {
        "name": "Josh Hawkins",
        "url": "https://dev.to/hawkinjs"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "a82e8094-4499-4915-9b77-0d40cce84878",
      "title": "Cross Compiling Rust for FreeBSD With Docker",
      "content_text": "For a little side project I‚Äôm working on I want to be able to produce pre-compiled binaries for a variety of platforms, including FreeBSD. With a bit of trial and error I have been able to successfully build working FreeBSD binaries from a Docker container, without using (slow) emulation/virtual machines. This post describes how it works and how to add it to your own Rust project.",
      "url": "https://www.wezm.net/technical/2019/03/cross-compile-freebsd-rust-binary-with-docker/",
      "date_published": "2019-03-25T04:45:00+00:00",
      "author": {
        "name": "Wesley Moore",
        "url": "http://www.wezm.net/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "9082061f-b4a4-4aed-81e6-71a0c7e49b1a",
      "title": "Packaging up a Rust Binary for Linux",
      "content_text": "How does one package a Rust app? I would check out creating a snap package (https://t.co/UYibrbPN7c). It worked alright for me, even though the format encourages sandboxing of apps which takes a bit to wrap your mind a bit. Or create a deb using cargo-deb and use the alien utility to transform that to a rpm.",
      "url": "https://dorianpula.ca/2019/03/15/packaging-up-a-rust-binary-for-linux/",
      "date_published": "2019-03-15T21:48:17+00:00",
      "author": {
        "name": "Dorian Pula",
        "url": "https://dorianpula.ca/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "784ce8bf-55af-48fc-9893-23f28a38c999",
      "title": "Hands-on IoT applications with OpenWhisk and Rust",
      "content_text": "In this article, we‚Äôll explore Apache OpenWhisk (which we‚Äôll refer to simply as OpenWhisk), an open-source, distributed serverless platform that allows us to execute functions in response to events. OpenWhisk supports a lot of languages out of the box and can be extended to use other languages. In our case, we are going to use Rust as our main primary language.",
      "url": "https://medium.com/the-theam-journey/hands-on-iot-applications-with-openwhisk-and-rust-acb9ef5bc166",
      "date_published": "2019-03-22T13:41:31.677+00:00",
      "author": {
        "name": "Roberto D√≠az",
        "url": "https://medium.com/@roberto_85185"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "5288ae7c-b0a5-4e98-b6ad-512af05f04e4",
      "title": "Azure Pipelines for Rust Projects",
      "content_text": "In this post I will detail why I believe that Azure Pipelines can be a great CI / CD platform for open source Rust projects on Github. The catch is that there are some rough spots on Azure Pipelines and in the rust ecosystem, but everything can be worked around. In writing this post, I hope to detail examples one can copy and paste into their projects.",
      "url": "https://nbsoftsolutions.com/blog/azure-pipelines-for-rust-projects",
      "date_published": "2019-02-28T00:00:00+00:00",
      "author": {
        "name": "Nick Babcock",
        "url": "https://nbsoftsolutions.com/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "a60ffa53-800e-42b3-a0df-feadc7a9e931",
      "title": "GitHub Actions: An introductory look and first impressions",
      "content_text": "I cover first impressions on GitHub actions using Rust as well as how to make it do a simple merge with a comment!",
      "url": "https://mgattozzi.com/github-actions-an-introductory-look-and-first-impressions/",
      "date_published": "2018-12-04T23:21:39+00:00",
      "author": {
        "name": "Michael Gattozzi",
        "url": "https://mgattozzi.com/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "164aa143-a832-491e-b1c0-304913959b8d",
      "title": "Serverless Rust: Revisited",
      "content_text": "A refreshing new story for running Rust on AWS Lambda.",
      "url": "https://medium.com/@softprops/serverless-rust-revisited-f2c79f4039bb",
      "date_published": "2018-12-22T15:43:04.617+00:00",
      "author": {
        "name": "Doug Tangren",
        "url": "https://medium.com/@softprops"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "f0df7d96-1aae-46ea-b454-d4d2ce7d3efd",
      "title": "Azure Functions written in Rust",
      "content_text": "A few days ago, we discussed how to write AWS Lambdas in Rust. Today, we‚Äôre going to learn how to create and deploy an Azure Function using Rust and the azure-functions-sdk library.",
      "url": "https://robertohuertas.com/2018/12/22/azure-function-rust/",
      "date_published": "2018-12-22T00:00:00+00:00",
      "author": {
        "name": "Roberto Huertas",
        "url": "https://robertohuertas.com/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "0ee5d609-1891-4f10-9085-93696f564382",
      "title": "Kubernetes config management in Rust",
      "content_text": "At babylon health we have a ton of microservices running on kubernetes that are, in turn, controlled by hundreds of thousands of lines of autogenerated yaml. So for our own sanity, we built shipcat - a standardisation tool (powered by rust-lang and serde) to control the declarative format and lifecycle of every microservice.",
      "url": "https://clux.github.io/probes/post/2018-12-15-config-management-in-rust/",
      "date_published": "2018-12-15T00:00:00+00:00",
      "author": {
        "name": "clux",
        "url": "https://clux.github.io/probes/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "00b55ed6-da3d-4c6a-90ed-ebea6191afd8",
      "title": "Dynamically Generating Dockerfiles for K8s",
      "content_text": "Hello everyone! Today I am excited to announce that DocQL is open-sourcing a Rust crate (a library) which we built internally called‚Ä¶",
      "url": "https://medium.com/docql/dynamically-generating-dockerfiles-for-k8s-d2baf7bfef5a",
      "date_published": "2018-12-10T19:43:10.002+00:00",
      "author": {
        "name": "Anthony Dodd",
        "url": "https://medium.com/@doddzilla0"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "50e86e16-57e4-4740-8251-b7eb6340d9ad",
      "title": "Firecracker: Secure and Fast microVM for Serverless Computing",
      "content_text": "In the fall of 2017, we decided to write Firecracker in Rust, a modern programming language that guarantees thread and memory safety and prevents buffer overflows and many other types of memory safety errors that can lead to security vulnerabilities. Read more details about the features and architecture of the Firecracker VMM at Firecracker Design.\n\nFirecracker microVMs improve efficiency and utilization with a low memory overhead of < 5 MiB per microVMs. This means that you can pack thousands of microVMs onto a single machine. You can use an in-process rate limiter to control, with fine granularity, how network and storage resources are shared, even across thousands of microVMs. All hardware compute resources can be safely oversubscribed, to maximize the number of workloads that can run on a host.",
      "url": "https://aws.amazon.com/blogs/opensource/firecracker-open-source-secure-fast-microvm-serverless/",
      "date_published": "2018-11-27T05:02:08+00:00",
      "author": {
        "name": "Arun Gupta",
        "url": "https://aws.amazon.com/blogs/opensource/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "97715a00-432f-4cfa-9c11-92f0d74ff60e",
      "title": "Running Rust natively in AWS Lambda and testing it locally",
      "content_text": "Abusing Go runtime in AWS to run Rust binaries",
      "url": "https://medium.com/@bernardo.belchior1/running-rust-natively-in-aws-lambda-and-testing-it-locally-57080421426d",
      "date_published": "2018-11-12T14:23:33.534+00:00",
      "author": {
        "name": "Bernardo Belchior",
        "url": "https://medium.com/@bernardo.belchior1"
      },
      "tags": [
        "DevOps and Deployment",
        "Web and Network Services"
      ]
    },
    {
      "id": "b49cc876-bb7e-4861-a0d6-34b4396b3600",
      "title": "Rust Nightly, Travis CI and Code Coverage",
      "content_text": "How to setup test a Rust Nightly project with a workspace in Travis CI and collect coverage information with kcov and Codecov.",
      "url": "https://baptiste.gelez.xyz/~/Rust/rust-nightly-travis-ci-and-code-coverage/",
      "date_published": "2018-11-01T00:00:00+00:00",
      "author": {
        "name": "Baptiste Gelez",
        "url": "https://baptiste.gelez.xyz/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "96f12355-f732-45f5-9ca2-d2e68bc741ab",
      "title": "Plumbing the Deps of the Crate: Caching Rust Docker Builds",
      "content_text": "Learn how to cache your Docker builds with Rust better so you don't keep downloading and building your deps over and over and over again!",
      "url": "https://mgattozzi.com/caching-rust-docker-builds/",
      "date_published": "2018-10-23T03:32:10+00:00",
      "author": {
        "name": "Michael Gattozzi",
        "url": "https://mgattozzi.com/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "fac60173-70f5-4682-a698-716cf05306ce",
      "title": "korq: Kubernetes Dynamic Log Tailing Utility",
      "content_text": "K‚àÖRQ is used for tailing pod logs concurrently and following groups at once. It was basically a need to follow logs during deployment and see how instances behave during and after deployment. This is the main motive behind K‚àÖRQ.",
      "url": "https://vertexclique.github.io/korq/",
      "date_published": "2018-10-23T00:00:00+00:00",
      "author": {
        "name": "Mahmut Bulut",
        "url": "https://vertexclique.github.io/"
      },
      "tags": [
        "DevOps and Deployment",
        "Tools and Applications"
      ]
    },
    {
      "id": "90da273a-d430-4fd5-891c-1aa33bc00588",
      "title": "Beware the rust cache on Travis",
      "content_text": "Today, I was working on optimizing my travis builds to speed them up, especially in the direction of caching. Travis allows you to set cache: cargo in your .travis.yml to enable caching for rust projects and caching is cool: it avoids having to rebuild all dependencies all the time, speeding up the builds.",
      "url": "https://levans.fr/rust_travis_cache.html",
      "date_published": "2018-09-05T17:00:00+02:00",
      "author": {
        "name": "Victor \"Levans\" Berger",
        "url": "https://levans.fr/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "ecb8cd2e-5804-4876-a5c6-c30cbf1c93fa",
      "title": "Cross compiling Rust for ARM (e.g. Raspberry Pi) using any OS!",
      "content_text": "Here is a small walkthrough, on how to use Mac OSx, Linux or even Windows (hey not tested but I am sure you can make it work, the tools are the same) to compile your Rust marvellousness and run the binary directly on the Raspberry Pi (2/3/3+).",
      "url": "https://medium.com/@wizofe/cross-compiling-rust-for-arm-e-g-raspberry-pi-using-any-os-11711ebfc52b",
      "date_published": "2018-07-07T21:54:26.332+00:00",
      "author": {
        "name": "ioannis valasakis",
        "url": "https://medium.com/@wizofe"
      },
      "tags": [
        "DevOps and Deployment",
        "Embedded"
      ]
    },
    {
      "id": "924567bd-54c7-429d-84a6-db7b8b9221f1",
      "title": "How to run Rust in OpenFaaS",
      "content_text": "OpenFaaS is an open source implementation of Function as a Service (Serverless Functions, microservices) that you can self host. Rather than list all the various offerings in this space, I'll refer you to the Cloud Native Computing Foundation, in particular the interactive Landscape.\n\nYou can either deploy existing functions or create new ones. If you create new ones, there's a big list of officially supported languages. Alternative you could turn a CLI into function.\n\nOnce I'd given Python and Ruby a go as an introduction, I wanted to see how easy it would be to create a Rust template.",
      "url": "https://booyaa.wtf/2018/run-rust-in-openfaas/",
      "date_published": "2018-08-04T00:00:00+00:00",
      "author": {
        "name": "Mark Sta Ana",
        "url": "https://booyaa.wtf/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "14507477-073a-4055-a2de-b0e4c4fd2ad5",
      "title": "Announcing Vagga 0.8.1 ‚Äì PaulColomiets",
      "content_text": "We are excited to announce the next version of vagga, the containerization tool that makes setting up development environments easy and fun. This release brings local overrides for vagga commands, support of ubuntu bionic, better CI support, space reuse between multiple projects, and more.",
      "url": "https://medium.com/@paulcolomiets/announcing-vagga-0-8-1-5e1fd44ee6fa",
      "date_published": "2018-07-31T19:39:25.963+00:00",
      "author": {
        "name": "PaulColomiets",
        "url": "https://medium.com/@paulcolomiets"
      },
      "tags": [
        "Tools and Applications",
        "DevOps and Deployment"
      ]
    },
    {
      "id": "0c4246e6-b2cb-42fa-930f-b32ed84c8880",
      "title": "Conduit 0.5.0 and the future of Conduit",
      "content_text": "Today we‚Äôre very happy to announce Conduit 0.5.0, which introduces zero-config automatic TLS between mesh‚Äôd pods (including certificate creation and distribution). This means that most Kubernetes users can now encrypt internal HTTP communication between their service in just two simple commands.\n\nWe‚Äôre also happy to announce that 0.5.0 will be the last major release of Conduit. Conduit is graduating into the Linkerd project to become the basis of Linkerd 2.0. Read on for what this means!",
      "url": "https://blog.conduit.io/2018/07/06/conduit-0-5-and-the-future/",
      "date_published": "2018-07-06T16:41:57+00:00",
      "author": {
        "name": "Oliver Gould",
        "url": "https://blog.conduit.io/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "5f84b8db-7379-4c08-9cae-d2a901caaab1",
      "title": "Linux Container Internals (Part II)",
      "content_text": "Containers are moving the world. Each passing day more and more organizations are embracing containers as first-class citizens for distribution and deployment of software components. Containers represent the core of the cloud native paradigm.",
      "url": "https://rabbitstack.github.io/operating%20systems/containers/linux-container-internals-part-ii/",
      "date_published": "2018-07-13T18:10:04+02:00",
      "author": {
        "name": "Nedim ≈†abiƒá",
        "url": "https://rabbitstack.github.io"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "f53d06d7-6b22-4cb8-95f1-66f8ae0bdb8f",
      "title": "Deploying Rust with Docker and Kubernetes",
      "content_text": "Using a tiny Rust app to demonstrate deploying Rust with Docker and Kubernetes.",
      "url": "https://www.fpcomplete.com/blog/2018/07/deploying-rust-with-docker-and-kubernetes",
      "date_published": "2018-07-17T21:36:08+00:00",
      "author": {
        "name": "Chris Allen",
        "url": "https://www.fpcomplete.com/blog"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "fbdcd657-aab5-4d28-aa3a-ab04294f49eb",
      "title": "Multi target Rust builds with auto deployment in Travis-CI",
      "content_text": "This is just a small build script to automatically compile and create Rust binaries for your i86 32 and 64 bit machine and your Raspberry Pi(ARM) with Travis-CI. On the right side I added a little explanation of the following script.",
      "url": "https://medium.com/@tyrf/multi-target-rust-builds-with-auto-deployment-in-travis-ci-ab5214fb73ba",
      "date_published": "2018-07-13T18:44:17.418+00:00",
      "author": {
        "name": "Hendrik Teuber",
        "url": "https://medium.com/@tyrf"
      },
      "tags": [
        "DevOps and Deployment",
        "Embedded"
      ]
    },
    {
      "id": "f8a137b7-ce7d-4553-bcec-6170350dc1f2",
      "title": "Rust with Rocket + Elm running on Heroku",
      "content_text": "I had this goal of making a web app that was very fast, stable and easy to deploy. This is what I was hoping to accomplish: strongly typed server-side and client-side languages (Rust & Elm respectively), push-button deployments to the cloud with free hosting initially, and sub-second response times for API calls and page loads. With this setup, I think I'm well on my way to accomplishing each of these.",
      "url": "http://ethanfrei.com/posts/rust-with-rocket-elm-running-on-heroku.html",
      "date_published": "2018-06-24T00:00:00+00:00",
      "author": {
        "name": "Ethan Frei",
        "url": "http://ethanfrei.com/"
      },
      "tags": [
        "Web and Network Services",
        "DevOps and Deployment"
      ]
    },
    {
      "id": "451beac2-903e-4bff-ada5-dc478a19e2c1",
      "title": "Even faster rust builds in Gitlab CI",
      "content_text": "tl;dr - I applied a few patterns I‚Äôve used on other projects to a Gitlab CI-powered rust project to achieve <2min builds. Basically just caching at different layers ‚Äì caching via the docker image builder pattern at the docker level, aggressive caching with Gitlab CI at the CI runner level, also one more step of combining some build steps (probably unnecessarily).",
      "url": "https://vadosware.io/post/even-faster-rust-builds-in-gitlab-ci/",
      "date_published": "2018-05-30T17:09:59+09:00",
      "author": {
        "name": "Vados",
        "url": "https://vadosware.io/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "5b534e6e-4e12-4860-95d6-1317b8903d4e",
      "title": "Setting up gitlab-ci for Rust",
      "content_text": "We're going to create a multi-stage pipeline based on the one I'm using at work, featuring: a build image, linting, test & release builds, and docker containers",
      "url": "https://not.plhk.ru/gitlab-ci-rust/",
      "date_published": "2018-05-14T00:00:00+00:00",
      "author": {
        "name": "Alexander Polakov",
        "url": "https://not.plhk.ru/"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "c35de4ff-df45-4774-998f-f56ddb57b5d2",
      "title": "Building and Deploying Rust with VSTS",
      "content_text": "Since I started at Microsoft about 6 months ago, I had to catch up on their (our) tech: Azure, .NET, Visual Studio. Yet as an avid GitHub user I overlooked one thing completely: Visual Studio Team Services! Turns out it‚Äôs quite the hidden gem and after a colleague showed me some of its power, I had to look into it more deeply. Turns out it‚Äôs an easy and free resource for any project. Can it help your project? Yes! How? Find out below üòä",
      "url": "https://blog.x5ff.xyz/blog/rust-ci-cd-vsts/",
      "date_published": "2018-03-02T00:00:00+00:00",
      "author": {
        "name": "Claus",
        "url": "https://blog.x5ff.xyz/blog"
      },
      "tags": [
        "DevOps and Deployment"
      ]
    },
    {
      "id": "ab076ead-649f-47ff-8fa2-a7c243ba3dca",
      "title": "Docker Multi-Stage Build",
      "content_text": "On June 13, 2017 took place the Paris Container Day. They unveiled a new docker feature: multi-stage build. That's the subject of this article.",
      "url": "https://blog.jawg.io/docker-multi-stage-build/",
      "date_published": "2018-03-01T14:00:00+00:00",
      "author": {
        "name": "Jones Magloire",
        "url": "http://blog.jawg.io/"
      },
      "tags": [
        "Language",
        "DevOps and Deployment"
      ]
    },
    {
      "id": "d001ce02-fbfb-4a08-8389-0f713b09bf72",
      "title": "My Rust Dockerfile",
      "content_text": "Lets deploy small docker images for Rust",
      "url": "https://blog.sedrik.se/posts/my-docker-setup-for-rust/",
      "date_published": "2018-02-26T00:00:00+00:00",
      "author": {
        "name": "Fredrik Park",
        "url": "https://blog.sedrik.se/"
      },
      "tags": [
        "Language",
        "DevOps and Deployment"
      ]
    }
  ]
}