<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - DevOps and Deployment</title><link>https://readrust.net/</link><description>DevOps and Deployment posts on Read Rust</description><item><title>Hands-on IoT applications with OpenWhisk and Rust</title><link>https://medium.com/the-theam-journey/hands-on-iot-applications-with-openwhisk-and-rust-acb9ef5bc166</link><description><![CDATA[In this article, weâ€™ll explore Apache OpenWhisk (which weâ€™ll refer to simply as OpenWhisk), an open-source, distributed serverless platform that allows us to execute functions in response to events. OpenWhisk supports a lot of languages out of the box and can be extended to use other languages. In our case, we are going to use Rust as our main primary language.]]></description><guid isPermaLink="false">784ce8bf-55af-48fc-9893-23f28a38c999</guid><pubDate>Fri, 22 Mar 2019 13:41:31 +0000</pubDate><dc:creator>Roberto DÃ­az</dc:creator></item><item><title>Packaging up a Rust Binary for Linux</title><link>https://dorianpula.ca/2019/03/15/packaging-up-a-rust-binary-for-linux/</link><description><![CDATA[How does one package a Rust app? I would check out creating a snap package (https://t.co/UYibrbPN7c). It worked alright for me, even though the format encourages sandboxing of apps which takes a bit to wrap your mind a bit. Or create a deb using cargo-deb and use the alien utility to transform that to a rpm.]]></description><guid isPermaLink="false">9082061f-b4a4-4aed-81e6-71a0c7e49b1a</guid><pubDate>Fri, 15 Mar 2019 21:48:17 +0000</pubDate><dc:creator>Dorian Pula</dc:creator></item><item><title>Azure Pipelines for Rust Projects</title><link>https://nbsoftsolutions.com/blog/azure-pipelines-for-rust-projects</link><description><![CDATA[In this post I will detail why I believe that Azure Pipelines can be a great CI / CD platform for open source Rust projects on Github. The catch is that there are some rough spots on Azure Pipelines and in the rust ecosystem, but everything can be worked around. In writing this post, I hope to detail examples one can copy and paste into their projects.]]></description><guid isPermaLink="false">5288ae7c-b0a5-4e98-b6ad-512af05f04e4</guid><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Nick Babcock</dc:creator></item><item><title>Serverless Rust: Revisited</title><link>https://medium.com/@softprops/serverless-rust-revisited-f2c79f4039bb</link><description><![CDATA[A refreshing new story for running Rust on AWS Lambda.]]></description><guid isPermaLink="false">164aa143-a832-491e-b1c0-304913959b8d</guid><pubDate>Sat, 22 Dec 2018 15:43:04 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Azure Functions written in Rust</title><link>https://robertohuertas.com/2018/12/22/azure-function-rust/</link><description><![CDATA[A few days ago, we discussed how to write AWS Lambdas in Rust. Today, weâ€™re going to learn how to create and deploy an Azure Function using Rust and the azure-functions-sdk library.]]></description><guid isPermaLink="false">f0df7d96-1aae-46ea-b454-d4d2ce7d3efd</guid><pubDate>Sat, 22 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Roberto Huertas</dc:creator></item><item><title>Kubernetes config management in Rust</title><link>https://clux.github.io/probes/post/2018-12-15-config-management-in-rust/</link><description><![CDATA[At babylon health we have a ton of microservices running on kubernetes that are, in turn, controlled by hundreds of thousands of lines of autogenerated yaml. So for our own sanity, we built shipcat - a standardisation tool (powered by rust-lang and serde) to control the declarative format and lifecycle of every microservice.]]></description><guid isPermaLink="false">0ee5d609-1891-4f10-9085-93696f564382</guid><pubDate>Sat, 15 Dec 2018 00:00:00 +0000</pubDate><dc:creator>clux</dc:creator></item><item><title>Dynamically Generating Dockerfiles for K8s</title><link>https://medium.com/docql/dynamically-generating-dockerfiles-for-k8s-d2baf7bfef5a</link><description><![CDATA[Hello everyone! Today I am excited to announce that DocQL is open-sourcing a Rust crate (a library) which we built internally calledâ€¦]]></description><guid isPermaLink="false">00b55ed6-da3d-4c6a-90ed-ebea6191afd8</guid><pubDate>Mon, 10 Dec 2018 19:43:10 +0000</pubDate><dc:creator>Anthony Dodd</dc:creator></item><item><title>GitHub Actions: An introductory look and first impressions</title><link>https://mgattozzi.com/github-actions-an-introductory-look-and-first-impressions/</link><description><![CDATA[I cover first impressions on GitHub actions using Rust as well as how to make it do a simple merge with a comment!]]></description><guid isPermaLink="false">a60ffa53-800e-42b3-a0df-feadc7a9e931</guid><pubDate>Tue,  4 Dec 2018 23:21:39 +0000</pubDate><dc:creator>Michael Gattozzi</dc:creator></item><item><title>Firecracker: Secure and Fast microVM for Serverless Computing</title><link>https://aws.amazon.com/blogs/opensource/firecracker-open-source-secure-fast-microvm-serverless/</link><description><![CDATA[In the fall of 2017, we decided to write Firecracker in Rust, a modern programming language that guarantees thread and memory safety and prevents buffer overflows and many other types of memory safety errors that can lead to security vulnerabilities. Read more details about the features and architecture of the Firecracker VMM at Firecracker Design.

Firecracker microVMs improve efficiency and utilization with a low memory overhead of < 5 MiB per microVMs. This means that you can pack thousands of microVMs onto a single machine. You can use an in-process rate limiter to control, with fine granularity, how network and storage resources are shared, even across thousands of microVMs. All hardware compute resources can be safely oversubscribed, to maximize the number of workloads that can run on a host.]]></description><guid isPermaLink="false">50e86e16-57e4-4740-8251-b7eb6340d9ad</guid><pubDate>Tue, 27 Nov 2018 05:02:08 +0000</pubDate><dc:creator>Arun Gupta</dc:creator></item><item><title>Running Rust natively in AWS Lambda and testing it locally</title><link>https://medium.com/@bernardo.belchior1/running-rust-natively-in-aws-lambda-and-testing-it-locally-57080421426d</link><description><![CDATA[Abusing Go runtime in AWS to run Rust binaries]]></description><guid isPermaLink="false">97715a00-432f-4cfa-9c11-92f0d74ff60e</guid><pubDate>Mon, 12 Nov 2018 14:23:33 +0000</pubDate><dc:creator>Bernardo Belchior</dc:creator></item><item><title>Rust Nightly, Travis CI and Code Coverage</title><link>https://baptiste.gelez.xyz/~/Rust/rust-nightly-travis-ci-and-code-coverage/</link><description><![CDATA[How to setup test a Rust Nightly project with a workspace in Travis CI and collect coverage information with kcov and Codecov.]]></description><guid isPermaLink="false">b49cc876-bb7e-4861-a0d6-34b4396b3600</guid><pubDate>Thu,  1 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Baptiste Gelez</dc:creator></item><item><title>Plumbing the Deps of the Crate: Caching Rust Docker Builds</title><link>https://mgattozzi.com/caching-rust-docker-builds/</link><description><![CDATA[Learn how to cache your Docker builds with Rust better so you don't keep downloading and building your deps over and over and over again!]]></description><guid isPermaLink="false">96f12355-f732-45f5-9ca2-d2e68bc741ab</guid><pubDate>Tue, 23 Oct 2018 03:32:10 +0000</pubDate><dc:creator>Michael Gattozzi</dc:creator></item><item><title>korq: Kubernetes Dynamic Log Tailing Utility</title><link>https://vertexclique.github.io/korq/</link><description><![CDATA[Kâˆ…RQ is used for tailing pod logs concurrently and following groups at once. It was basically a need to follow logs during deployment and see how instances behave during and after deployment. This is the main motive behind Kâˆ…RQ.]]></description><guid isPermaLink="false">fac60173-70f5-4682-a698-716cf05306ce</guid><pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Mahmut Bulut</dc:creator></item><item><title>Beware the rust cache on Travis</title><link>https://levans.fr/rust_travis_cache.html</link><description><![CDATA[Today, I was working on optimizing my travis builds to speed them up, especially in the direction of caching. Travis allows you to set cache: cargo in your .travis.yml to enable caching for rust projects and caching is cool: it avoids having to rebuild all dependencies all the time, speeding up the builds.]]></description><guid isPermaLink="false">90da273a-d430-4fd5-891c-1aa33bc00588</guid><pubDate>Wed,  5 Sep 2018 17:00:00 +0200</pubDate><dc:creator>Victor &quot;Levans&quot; Berger</dc:creator></item><item><title>How to run Rust in OpenFaaS</title><link>https://booyaa.wtf/2018/run-rust-in-openfaas/</link><description><![CDATA[OpenFaaS is an open source implementation of Function as a Service (Serverless Functions, microservices) that you can self host. Rather than list all the various offerings in this space, I'll refer you to the Cloud Native Computing Foundation, in particular the interactive Landscape.

You can either deploy existing functions or create new ones. If you create new ones, there's a big list of officially supported languages. Alternative you could turn a CLI into function.

Once I'd given Python and Ruby a go as an introduction, I wanted to see how easy it would be to create a Rust template.]]></description><guid isPermaLink="false">924567bd-54c7-429d-84a6-db7b8b9221f1</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Mark Sta Ana</dc:creator></item><item><title>Announcing Vagga 0.8.1 â€“ PaulColomiets</title><link>https://medium.com/@paulcolomiets/announcing-vagga-0-8-1-5e1fd44ee6fa</link><description><![CDATA[We are excited to announce the next version of vagga, the containerization tool that makes setting up development environments easy and fun. This release brings local overrides for vagga commands, support of ubuntu bionic, better CI support, space reuse between multiple projects, and more.]]></description><guid isPermaLink="false">14507477-073a-4055-a2de-b0e4c4fd2ad5</guid><pubDate>Tue, 31 Jul 2018 19:39:25 +0000</pubDate><dc:creator>PaulColomiets</dc:creator></item><item><title>Deploying Rust with Docker and Kubernetes</title><link>https://www.fpcomplete.com/blog/2018/07/deploying-rust-with-docker-and-kubernetes</link><description><![CDATA[Using a tiny Rust app to demonstrate deploying Rust with Docker and Kubernetes.]]></description><guid isPermaLink="false">f53d06d7-6b22-4cb8-95f1-66f8ae0bdb8f</guid><pubDate>Tue, 17 Jul 2018 21:36:08 +0000</pubDate><dc:creator>Chris Allen</dc:creator></item><item><title>Multi target Rust builds with auto deployment in Travis-CI</title><link>https://medium.com/@tyrf/multi-target-rust-builds-with-auto-deployment-in-travis-ci-ab5214fb73ba</link><description><![CDATA[This is just a small build script to automatically compile and create Rust binaries for your i86 32 and 64 bit machine and your Raspberry Pi(ARM) with Travis-CI. On the right side I added a little explanation of the following script.]]></description><guid isPermaLink="false">fbdcd657-aab5-4d28-aa3a-ab04294f49eb</guid><pubDate>Fri, 13 Jul 2018 18:44:17 +0000</pubDate><dc:creator>Hendrik Teuber</dc:creator></item><item><title>Linux Container Internals (Part II)</title><link>https://rabbitstack.github.io/operating%20systems/containers/linux-container-internals-part-ii/</link><description><![CDATA[Containers are moving the world. Each passing day more and more organizations are embracing containers as first-class citizens for distribution and deployment of software components. Containers represent the core of the cloud native paradigm.]]></description><guid isPermaLink="false">5f84b8db-7379-4c08-9cae-d2a901caaab1</guid><pubDate>Fri, 13 Jul 2018 18:10:04 +0200</pubDate><dc:creator>Nedim Å abiÄ‡</dc:creator></item><item><title>Cross compiling Rust for ARM (e.g. Raspberry Pi) using any OS!</title><link>https://medium.com/@wizofe/cross-compiling-rust-for-arm-e-g-raspberry-pi-using-any-os-11711ebfc52b</link><description><![CDATA[Here is a small walkthrough, on how to use Mac OSx, Linux or even Windows (hey not tested but I am sure you can make it work, the tools are the same) to compile your Rust marvellousness and run the binary directly on the Raspberry Pi (2/3/3+).]]></description><guid isPermaLink="false">ecb8cd2e-5804-4876-a5c6-c30cbf1c93fa</guid><pubDate>Sat,  7 Jul 2018 21:54:26 +0000</pubDate><dc:creator>ioannis valasakis</dc:creator></item><item><title>Conduit 0.5.0 and the future of Conduit</title><link>https://blog.conduit.io/2018/07/06/conduit-0-5-and-the-future/</link><description><![CDATA[Today weâ€™re very happy to announce Conduit 0.5.0, which introduces zero-config automatic TLS between meshâ€™d pods (including certificate creation and distribution). This means that most Kubernetes users can now encrypt internal HTTP communication between their service in just two simple commands.

Weâ€™re also happy to announce that 0.5.0 will be the last major release of Conduit. Conduit is graduating into the Linkerd project to become the basis of Linkerd 2.0. Read on for what this means!]]></description><guid isPermaLink="false">0c4246e6-b2cb-42fa-930f-b32ed84c8880</guid><pubDate>Fri,  6 Jul 2018 16:41:57 +0000</pubDate><dc:creator>Oliver Gould</dc:creator></item><item><title>Rust with Rocket + Elm running on Heroku</title><link>http://ethanfrei.com/posts/rust-with-rocket-elm-running-on-heroku.html</link><description><![CDATA[I had this goal of making a web app that was very fast, stable and easy to deploy. This is what I was hoping to accomplish: strongly typed server-side and client-side languages (Rust & Elm respectively), push-button deployments to the cloud with free hosting initially, and sub-second response times for API calls and page loads. With this setup, I think I'm well on my way to accomplishing each of these.]]></description><guid isPermaLink="false">f8a137b7-ce7d-4553-bcec-6170350dc1f2</guid><pubDate>Sun, 24 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Ethan Frei</dc:creator></item><item><title>Even faster rust builds in Gitlab CI</title><link>https://vadosware.io/post/even-faster-rust-builds-in-gitlab-ci/</link><description><![CDATA[tl;dr - I applied a few patterns Iâ€™ve used on other projects to a Gitlab CI-powered rust project to achieve <2min builds. Basically just caching at different layers â€“ caching via the docker image builder pattern at the docker level, aggressive caching with Gitlab CI at the CI runner level, also one more step of combining some build steps (probably unnecessarily).]]></description><guid isPermaLink="false">451beac2-903e-4bff-ada5-dc478a19e2c1</guid><pubDate>Wed, 30 May 2018 17:09:59 +0900</pubDate><dc:creator>Vados</dc:creator></item><item><title>Setting up gitlab-ci for Rust</title><link>https://not.plhk.ru/gitlab-ci-rust/</link><description><![CDATA[We're going to create a multi-stage pipeline based on the one I'm using at work, featuring: a build image, linting, test & release builds, and docker containers]]></description><guid isPermaLink="false">5b534e6e-4e12-4860-95d6-1317b8903d4e</guid><pubDate>Mon, 14 May 2018 00:00:00 +0000</pubDate><dc:creator>Alexander Polakov</dc:creator></item><item><title>Building and Deploying Rust with VSTS</title><link>https://blog.x5ff.xyz/blog/rust-ci-cd-vsts/</link><description><![CDATA[Since I started at Microsoft about 6 months ago, I had to catch up on their (our) tech: Azure, .NET, Visual Studio. Yet as an avid GitHub user I overlooked one thing completely: Visual Studio Team Services! Turns out itâ€™s quite the hidden gem and after a colleague showed me some of its power, I had to look into it more deeply. Turns out itâ€™s an easy and free resource for any project. Can it help your project? Yes! How? Find out below ðŸ˜Š]]></description><guid isPermaLink="false">c35de4ff-df45-4774-998f-f56ddb57b5d2</guid><pubDate>Fri,  2 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Claus</dc:creator></item><item><title>Docker Multi-Stage Build</title><link>https://blog.jawg.io/docker-multi-stage-build/</link><description><![CDATA[On June 13, 2017 took place the Paris Container Day. They unveiled a new docker feature: multi-stage build. That's the subject of this article.]]></description><guid isPermaLink="false">ab076ead-649f-47ff-8fa2-a7c243ba3dca</guid><pubDate>Thu,  1 Mar 2018 14:00:00 +0000</pubDate><dc:creator>Jones Magloire</dc:creator></item><item><title>My Rust Dockerfile</title><link>https://blog.sedrik.se/posts/my-docker-setup-for-rust/</link><description><![CDATA[Lets deploy small docker images for Rust]]></description><guid isPermaLink="false">d001ce02-fbfb-4a08-8389-0f713b09bf72</guid><pubDate>Mon, 26 Feb 2018 00:00:00 +0000</pubDate><dc:creator>Fredrik Park</dc:creator></item><item><title>Deploying A Rust Server to Google App Engine with Travis CI &amp; Docker</title><link>https://medium.com/@gallantmrgn/deploying-rust-server-to-google-app-engine-with-travis-ci-docker-b80acfce2ce5</link><description><![CDATA[I woke up this morning with one goal: to convert my website (morgangallant.com) into a Rust web server. I have been a long time fan ofâ€¦]]></description><guid isPermaLink="false">2b698c99-99e0-4fad-8716-b58dbd9c255c</guid><pubDate>Sun, 11 Feb 2018 00:07:43 +0000</pubDate><dc:creator>Morgan A. Gallant</dc:creator></item></channel></rss>