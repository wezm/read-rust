{
  "version": "https://jsonfeed.org/version/1",
  "title": "Read Rust - Language",
  "home_page_url": "https://readrust.net/",
  "feed_url": "https://readrust.net/language/feed.json",
  "description": "Language posts on Read Rust",
  "author": {
    "name": "Wesley Moore",
    "url": "http://www.wezm.net/"
  },
  "items": [
    {
      "id": "b6cc68e0-c563-4eb0-a374-7c11dad01824",
      "title": "The Demystifying Asynchronous Rust Book",
      "content_text": "This book is targeted towards experienced programmers that already feel somewhat comfortable with vanilla Rust (you definitely do not need to be an \"expert\" though, I certainly am not) and would like to dip their toes into its async ecosystem.\n\nAs the title indicates, this is not so much a book about how to use async Rust as much as it is about trying to build a solid understanding of how it all works under the hood. From there, efficient usage should come naturally.",
      "url": "https://teh-cmc.github.io/rust-async/html/",
      "date_published": "2019-11-11T00:00:00+00:00",
      "author": {
        "name": "Clement Rey",
        "url": "https://teh-cmc.github.io/rust-async/html/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0878c302-d2e1-43c2-9ab4-1338d657fe69",
      "title": "Parsing with crate LALRPOP",
      "content_text": "How to write a parser using rust and lalrpop crate? In this article, we are going to walk through the implementation of parsing a string like this:\n\nThis is a {dog, cat}.\n\nAnd we want to expand this string into the following two strings:\n\n This is a dog.\nThis is a cat.",
      "url": "https://tensor.sh/parsing-with-crate-lalrpop",
      "date_published": "2019-09-02T00:00:00+00:00",
      "author": {
        "name": "Will",
        "url": "https://tensor.sh/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "225f7f8a-4d16-4eee-9022-bbb1d35e26a9",
      "title": "How Swift Achieved Dynamic Linking Where Rust Couldn't",
      "content_text": "For those who don't follow Swift's development, ABI stability has been one of its most ambitious projects and possibly it's defining feature, and it finally shipped in Swift 5. The result is something I find endlessly fascinating, because I think Swift has pushed the notion of ABI stability farther than any language without much compromise.\n\nSo I decided to write up a bunch of the interesting high-level details of Swift's ABI. This is not a complete reference for Swift's ABI, but rather an abstract look at its implementation strategy. If you really want to know exactly how it allocates registers or mangles names, look somewhere else.\n\nAlso for context on why I'm writing this, I'm just naturally inclined to compare the design of Swift to Rust, because those are the two languages I have helped develop. Also some folks like to complain that Rust doesn't bother with ABI stability, and I think looking at how Swift does helps elucidate why that is.",
      "url": "https://gankra.github.io/blah/swift-abi/",
      "date_published": "2019-11-07T00:00:00+00:00",
      "author": {
        "name": "Alexis Beingessner",
        "url": "https://gankra.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a09f683f-9aec-46cc-83e8-0aa1acf20f31",
      "title": "Simple data stitching",
      "content_text": "I found myself in a situation where I had a number of CSV files that all shared some key data, and all had to be put together to a larger dataset. I figured that the easiest way to do this would be to deserialize the files, then stitch them together using a portion of their data as a key.\n\nI decided to try my hand at writing a macro to solve the issue, and I ended up with two of them; one for one-to-one relations, and one for one-to-many.",
      "url": "http://segfaultsourcery.s3-website.eu-central-1.amazonaws.com/snippets/rust/stitching/landing.html#simple-data-stitching",
      "date_published": "2019-11-07T00:00:00+00:00",
      "author": {
        "name": "Kim H√•",
        "url": "https://github.com/segfaultsourcery"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9d326b39-4675-4c5f-9509-d388a4e41486",
      "title": "Rust once and share it with Android, iOS and Flutter",
      "content_text": "What if I told you that you could use the same very performant code in Android, iOS or even in Flutter. In this article, we‚Äôll see how to achieve this with Rust.",
      "url": "https://robertohuertas.com/2019/10/27/rust-for-android-ios-flutter/",
      "date_published": "2019-10-27T00:00:00+00:00",
      "author": {
        "name": "Roberto Huertas",
        "url": "https://robertohuertas.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "155c1b1a-4660-4feb-8ab9-3dc8c211afb2",
      "title": "Rust concurrency patterns: condvars and locks",
      "content_text": "I‚Äôve spent quite a lot of time extolling the virtues of message-passing in concurrent Rust. However, there are times when shared-state is the right approach, sometimes just because it‚Äôs the historical approach chosen in a module and you want to add something to it without refactoring the whole thing. So today we‚Äôre going to talk about using shared-state, with the help of condvars and locks.",
      "url": "https://medium.com/@polyglot_factotum/rust-concurrency-patterns-condvars-and-locks-e278f18db74f",
      "date_published": "2019-11-04T14:52:14.727+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3e6e0860-0ced-48d0-9f44-a2cfe3355a63",
      "title": "mrustc 0.9 - Now with rust 1.29.0 support",
      "content_text": "I'm finally happy to announce that I've \"finished\" the 1.29 branch of mrustc (for those who don't know, mrustc is my attempt at making a rust compiler, primarily for breaking the bootstrap chain).\n\nThis version is capable of compiling both rustc 1.29 (and packaged cargo) AND rustc 1.19, both of which can compile their successors (1.20 and 1.30 - and 1.30 results in a binary equal output).",
      "url": "https://www.reddit.com/r/rust/comments/dqi1u1/mrustc_09_now_with_rust_1290_support/",
      "date_published": "2019-11-02T00:00:00+00:00",
      "author": {
        "name": "John Hodge (Mutabah)",
        "url": "https://github.com/thepowersgang"
      },
      "tags": [
        "Tools and Applications",
        "Language"
      ]
    },
    {
      "id": "bf08077b-89c9-4880-9b0b-5b869fd21252",
      "title": "Quantum computing in Rust, part 1",
      "content_text": "What is a ket? How do traits work? Implementing a quantum computer simulator in Rust.",
      "url": "https://walther.guru/blog/impl-quantum-part-1/",
      "date_published": "2019-10-28T00:00:00+00:00",
      "author": {
        "name": "Veeti Haapsamo",
        "url": "https://walther.guru/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c7f41ce0-3664-4696-90a6-16b5b025820e",
      "title": "Advent of Code in Rust: lessons learned",
      "content_text": "Last December, I decided to solve the Advent of Code (AoC) programming puzzles in Rust. This website is an advent calendar proposing a new algorithmic problem of varying difficulty every day throughout December, so it‚Äôs a great way to learn and practice a programming language. There is also a leaderboard for the fastest people to solve them, but the past problems remain available forever, so don‚Äôt worry if you‚Äôre too slow or busy in December, you can try them any time of the year - as this overdue blog post shows!\n\nI already have some experience in Rust programming, but I felt that I could learn more about idiomatic Rust. Given the short time to solve each problem, it was a perfect opportunity to avoid reinventing the wheel but use the standard library as much as possible.\n\nHere are the most useful Rust features that I learned and used during this challenge.",
      "url": "https://gendignoux.com/blog/2019/08/25/rust-advent-of-code.html",
      "date_published": "2019-08-25T00:00:00+00:00",
      "author": {
        "name": "Guillaume Endignoux",
        "url": "https://gendignoux.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1bfa39d0-d652-4587-b229-7e40041f0764",
      "title": "Scratching NASDAQ's ITCH",
      "content_text": "I am building yet another order book tool in Rust, which requires me to parse L3 (full) market data feed from NASDAQ. In the words of one experienced trading systems developer writing a feed handler is boooooring, but does not build an order book, so I searched if someone else has implemented it already. Thankfully, adwhit has implemented a library to parse ITCH 5.0 feeds from files, which is one line away from importing to my Cargo.toml.",
      "url": "http://petr-tik.github.io/posts/itch_parser_debugging/",
      "date_published": "2019-10-23T00:00:00+00:00",
      "author": {
        "name": "petr-tik",
        "url": "http://petr-tik.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "cef4b4b5-5c64-4da9-a91a-89155efd377f",
      "title": "Rust error handling with Result and Option (WebAssembly ABI)",
      "content_text": "In our last adventure we looked at C++ exceptions in WebAssembly with the emscripten compiler. Now we‚Äôre taking a look at the main error handling system for another language targeting WebAssembly, Rust. Rust has a ‚Äúpanic‚Äù/‚Äùunwind‚Äù system similar to C++ exceptions, but it‚Äôs generally recommended against catching panics.",
      "url": "https://brionv.com/log/2019/10/27/rust-error-handling-with-result-and-option-webassembly-abi/",
      "date_published": "2019-10-27T19:59:33+00:00",
      "author": {
        "name": "Brion Vibber",
        "url": "https://brionv.com/log/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "97a5bf30-4c89-489d-a27e-6d3f32e90b6e",
      "title": "My favorite rust function",
      "content_text": "My favorite rust function is std::mem::drop which is used to free ordeallocate a value, similar to free() in C.",
      "url": "https://blog.jabid.in/2019/10/11/drop.html",
      "date_published": "2019-10-11T00:00:00+00:00",
      "author": {
        "name": "Jaseem Abid",
        "url": "https://blog.jabid.in/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "90d063a7-b14b-4a7d-be58-a33e6e1dcb5f",
      "title": "Ownership and impl Trait",
      "content_text": "There's a common pattern in Rust APIs: returning a relatively complex data type which provide a trait implementation we want to work with. One of the first places many Rust newcomers encounter this is with iterators.",
      "url": "https://tech.fpcomplete.com/rust/ownership-and-impl-trait",
      "date_published": "2019-10-07T03:48:44+00:00",
      "author": {
        "name": "FP Complete",
        "url": "https://tech.fpcomplete.com/rust/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "cd24e5cb-982d-424e-85b2-0b7284cadee4",
      "title": "Tarpaulin And The Futures",
      "content_text": "Tarpaulin (or cargo-tarpaulin) is a code coverage tool for Rust, and anyone who‚Äôs used it might know that until recently it had an issue with code that used futures.",
      "url": "https://xd009642.github.io/2019/10/02/Tarpaulin-and-the-futures.html",
      "date_published": "2019-10-02T00:00:00+00:00",
      "author": {
        "name": "xd009642",
        "url": "https://xd009642.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c86c3ae5-41e3-4973-955d-c8b6d61bcbd7",
      "title": "Rust as a gateway drug to¬†Haskell",
      "content_text": "For work-related reasons, I had to recently get up to speed on programming in Haskell. Before that, I had very little actual experience with the language, clocking probably at less than a thousand lines of working code over a couple of years. the one thing that really enabled me to become (somewhat) productive was not even related to Haskell at all? It was Rust.",
      "url": "http://xion.io/post/programming/rust-into-haskell.html",
      "date_published": "2019-06-13T00:00:00+00:00",
      "author": {
        "name": "Karol Kuczmarski",
        "url": "http://xion.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "feee8a1a-6c6b-45dc-a800-6d93d18e7b9a",
      "title": "Declarative memory management",
      "content_text": "It feels like an eternity since I‚Äôve started using Rust, and yet I remember vividly what it felt like to bang my head against the borrow checker for the first few times.\n\nI‚Äôm definitely not alone in that, and there‚Äôs been quite a few articles on the subject! But I want to take some time to present the borrow checker from the perspective of its benefits, rather than as an opponent to fend with.",
      "url": "https://fasterthanli.me/blog/2019/declarative-memory-management/",
      "date_published": "2019-09-19T00:00:00+00:00",
      "author": {
        "name": "Amos",
        "url": "https://fasterthanli.me/"
      },
      "tags": [
        "Getting Started",
        "Language"
      ]
    },
    {
      "id": "388629ea-87a4-4119-a7d5-24c13c2e470b",
      "title": "Generic Newtypes: A way to work around the orphan rule",
      "content_text": "Rust's orphan rule prevents us from implementing a foreign trait on a foreign type. While this may appear limiting at first, it is actually a good thing and one of the ways how the Rust compiler can prove at compile time that our code works the way we intended.\n\n This blog post is a follow-up on one that I already wrote some time ago. In this one, we will go more in-depth into the \"local wrapper type\" idea and rebrand it as \"generic newtypes\".",
      "url": "https://blog.eizinger.io/8593/generic-newtypes-a-way-to-work-around-the-orphan-rule",
      "date_published": "2019-09-21T00:00:00+00:00",
      "author": {
        "name": "Thomas Eizinger",
        "url": "https://blog.eizinger.io/@thomas_eizinger"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fc07abd0-fc94-40d6-b4f8-b29ce54fb934",
      "title": "Improved C Variadics in Rust and C2Rust",
      "content_text": "Our goal in the C2Rust project is to translate any valid C99 program into equivalent Rust code. Naturally, this means we need to properly support translating C variadic functions into Rust. For a long time, the Rust-C FFI only allowed one-way calls to C variadic functions: Rust code could call C variadic functions, but not the other way around. Rust RFC 2137 proposed an interface for Rust code to provide C-compatible variadic functions, which was later implemented as a series of patches by Dan Robertson that have been merged into nightly Rust from November 2018 to February 2019.",
      "url": "https://immunant.com/blog/2019/09/variadics/",
      "date_published": "2019-09-17T00:00:00+00:00",
      "author": {
        "name": "Immunant, Inc.",
        "url": "https://immunant.com/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0127a4ce-f036-4969-bab1-d55679ac36ce",
      "title": "Using ramdisks with Cargo",
      "content_text": "I have a bit of a history of killing SSDs - probably because I do a bit too much compiling and management of thousands of tiny files. Plenty of developers have this problem! So while thinking one evening, I was curious if I could setup a ramdisk on my mac for my cargo work to output to.",
      "url": "https://fy.blackhats.net.au/blog/html/2019/08/26/using_ramdisks_with_cargo.html",
      "date_published": "2019-08-26T00:00:00+00:00",
      "author": {
        "name": "Firstyear",
        "url": "https://fy.blackhats.net.au/blog/html/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f6721f14-deaa-4603-949e-f62b5130e6d7",
      "title": "It‚Äôs not wrong that \"ü§¶üèº‚Äç‚ôÇÔ∏è\".length == 7",
      "content_text": "But It‚Äôs Better that \"ü§¶üèº‚Äç‚ôÇÔ∏è\".len() == 17 and Rather Useless that len(\"ü§¶üèº‚Äç‚ôÇÔ∏è\") == 5\n\nFrom time to time, someone shows that in JavaScript the .length of a string containing an emoji results in a number greater than 1 (typically 2) and then proceeds to the conclusion that haha JavaScript is so broken‚Äîand is rewarded with many likes. In this post, I will try to convince you that ridiculing JavaScript for this is less insightful than it first appears and that Swift‚Äôs approach to string length isn‚Äôt unambiguously the best one. Python 3‚Äôs approach is unambiguously the worst one, though.",
      "url": "https://hsivonen.fi/string-length/",
      "date_published": "2019-09-08T23:17:00+00:00",
      "author": {
        "name": "Henri Sivonen",
        "url": "https://hsivonen.fi/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3a482b07-e688-4b92-94e7-5bd2d87e9f66",
      "title": "Scala Developer Journey into Rust - Part 7 : Type Classes",
      "content_text": "Rust is one of the major programming languages that‚Äôs been getting popular in recent years. It has many advanced high level language features like Scala.This made me interested to learn Rust. So in this next series of blogs I will share my experience with Rust from a Scala developer point of view. I would like to explore how these two language approach things. I would like to explore the similarities and their differences. This is seventh post in the series. In this post, I will be talking about type classes. You can find all the other posts in the series here.",
      "url": "http://blog.madhukaraphatak.com/rust-scala-part-7/",
      "date_published": "2019-08-20T00:00:00+00:00",
      "author": {
        "name": "Madhukara Phatak",
        "url": "http://madhukaraphatak.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "134835d4-c3ca-4ae7-bed7-eef5b69dcf44",
      "title": "Minimum Safe Abstractions",
      "content_text": "Recently, there‚Äôs been a lot of talk about unsafe in the Rust world, and how to deal with it. Let‚Äôs recap: Rust has a subset called ‚Äúsafe Rust‚Äù, with a few very neat guarantees, such as memory safety and freedom from data races. The superset that completes the language is called ‚Äúunsafe Rust‚Äù, and it still has a number of cool safeguards, but it also has an escape hatch to allow bending a few of them in order to let us write safe abstractions on top in much the same language.",
      "url": "https://llogiq.github.io/2019/08/01/unsafe.html",
      "date_published": "2019-08-01T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "27f56d23-f9a1-494d-b75f-864691d8e14c",
      "title": "Introduction to Procedural Macros in Rust",
      "content_text": "As a newcomer to Rust, I heard the phrase \"procedural macro\" thrown around a lot without really understanding what it meant. I figured that I would learn about them if I ever needed them. Well, I'm working on the guts of relm, and a large chunk of it is procedural macros. I've learned enough about procedural macros to be dangerous, so I thought I would pass on some knowledge.",
      "url": "https://tinkering.xyz/introduction-to-proc-macros/",
      "date_published": "2018-02-03T19:36:37-05:00",
      "author": {
        "name": "Zach Mitchell",
        "url": "https://tinkering.xyz/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f4b11aa2-a9ac-4511-aa4d-d8d81f51ab79",
      "title": "Coverage Reports as a Code Reading Tool",
      "content_text": "Coverage reports are widely used to visualize the lines of code which are covered by test cases. Often this is used in CI to block merge requests which lower test coverage by some metric. But coverage reports don‚Äôt have to be test coverage reports. In general, the idea of ‚Äúrun some code and see which lines are executed‚Äù can be applied to anything, not just the test cases.",
      "url": "https://www.joshmcguigan.com/blog/coverage-reports-code-reading-tool/",
      "date_published": "2019-08-20T00:00:00+00:00",
      "author": {
        "name": "Josh Mcguigan",
        "url": "https://www.joshmcguigan.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "db66d2c2-313a-4810-9a18-c802f98f5752",
      "title": "Rust std study series: Pin",
      "content_text": "This time we dive into std::pin which has a dense documentation.",
      "url": "https://ehsanmkermani.com/2019/08/16/rust-std-study-series-pin/",
      "date_published": "2019-08-16T17:27:37+00:00",
      "author": {
        "name": "Ehsan M. Kermani",
        "url": "https://ehsanmkermani.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "aeaec86b-ce60-4809-9c2a-db6aac5869eb",
      "title": "World‚Äôs Fourth Simplest Bytecode Interpreter: Register Machines",
      "content_text": "For the fourth World‚Äôs Simplest Bytecode Interpreter, Kazanov goes into a bit of esoterica without discussing why: he has ‚Äúauthentic bytecode‚Äù; he‚Äôs doing C programming and he dense-packs his instructions into a single 16-bit instruction. That‚Äôs fine if you‚Äôre emulating a real chunk of hardware, but for our purposes‚Ä¶ I really don‚Äôt care.",
      "url": "https://elfsternberg.com/2019/04/18/worlds-fourth-simplest-bytecode-interpreter-register-machines/",
      "date_published": "2019-04-18T00:00:00+00:00",
      "author": {
        "name": "Elf Sternberg",
        "url": "https://elfsternberg.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fa5a432c-cb0e-4c6e-b003-e52c1ce72829",
      "title": "The World‚Äôs Fifth Simplest Bytecode Interpreter: A Regular Expression Engine!",
      "content_text": "Kazanov‚Äôs fifth World‚Äôs Simplest Bytecode Intepreter (see the Fourth Simplest) isn‚Äôt quite so simple: it is an implementation of Thompson‚Äôs most basic regular expression table-driven DFA handler. It handles a complete set of Kleene‚Äôs Regular Expressions without the closure operator (no * operator), and it does so by exploiting the host language stack to handle nested recursion of alternatives.\n\nThis is a much different beast from the previous four, and it requires a little thinking to grok why it‚Äôs so different. For one thing, we‚Äôre going to be jumping back and forth inside the program: this is our first bytecode interpreter with a Jmp instruction. More than that, we may want to jump backwards, so we can‚Äôt use ‚Äòusize‚Äô for that, we‚Äôll need to use ‚Äòisize‚Äô. There are times we want to add a negative offset, after all!",
      "url": "https://elfsternberg.com/2019/04/18/the-worlds-fifth-simplest-bytecode-interpreter-a-regular-expression-engine/",
      "date_published": "2019-04-18T00:00:00+00:00",
      "author": {
        "name": "Elf Sternberg",
        "url": "https://elfsternberg.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "02e9c871-0bac-4650-8fc3-1c8c64e95c7e",
      "title": "Runtime Diagnostics",
      "content_text": "Rust is well-known for its helpful error messages, good tooling, and generally empathic compiler interface. If something goes wrong, Rust tries hard to help you get back on track. In this post I'd like to talk about the runtime aspect of debugging errors.",
      "url": "https://blog.yoshuawuyts.com/runtime-diagnostics/",
      "date_published": "2019-11-03T00:00:00+00:00",
      "author": {
        "name": "Yoshua Wuyts",
        "url": "https://blog.yoshuawuyts.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "35e06989-4cc4-4d3b-ab76-5830da233ebd",
      "title": "Async-await on stable Rust!",
      "content_text": "On Thursday, November 7, async-await syntax hit stable Rust, as part of the 1.39.0 release. This work has been a long time in development -- the key ideas for zero-cost futures, for example, were first proposed by Aaron Turon and Alex Crichton in 2016! -- and we are very proud of the end result. We believe that Async I/O is going to be an increasingly important part of Rust's story.",
      "url": "https://blog.rust-lang.org/2019/11/07/Async-await-stable.html",
      "date_published": "2019-11-07T00:00:00+00:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "dfcf2420-e465-4c62-8b31-f7e2792c2e94",
      "title": "Announcing Rust 1.39.0",
      "content_text": "The Rust team is happy to announce a new version of Rust, 1.39.0. The highlights of Rust 1.39.0 include async/.await, shared references to by-move bindings in match guards, and attributes on function parameters.",
      "url": "https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html",
      "date_published": "2019-11-07T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5fd6f3d5-2732-4d86-9824-78928983ebdf",
      "title": "Implementing a job queue in Rust",
      "content_text": "I recently finished my first rust project - a command line utility called ‚Äúwhat‚Äù that displays network utilization information. As a newcomer to rust, this project offered quite some challenges for me. This post is a write up of one of them, going into detail on the parts that I personally found most difficult to understand.\n\nIn this first post, I‚Äôd like to talk about implementing a job queue to resolve IPs into their hostnames by querying a remote DNS server.",
      "url": "https://www.poor.dev/posts/what-job-queue/",
      "date_published": "2019-10-30T00:00:00+00:00",
      "author": {
        "name": "Aram Drevekenin",
        "url": "https://www.poor.dev/"
      },
      "tags": [
        "Getting Started",
        "Language"
      ]
    },
    {
      "id": "290147b3-4275-4b38-86d1-48ead00c7e9f",
      "title": "Completing the transition to the new borrow checker",
      "content_text": "For most of 2018, we've been issuing warnings about various bugs in the borrow checker that we plan to fix -- about two months ago, in the current Rust nightly, those warnings became hard errors. In about two weeks, when the nightly branches to become beta, those hard errors will be in the beta build, and they will eventually hit stable on December 19th, as part of Rust 1.40.0. If you're testing with Nightly, you should be all set -- but otherwise, you may want to go and check to make sure your code still builds. If not, we have advice for fixing common problems below.",
      "url": "https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html",
      "date_published": "2019-11-01T00:00:00+00:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "884f2a1b-a04c-44b4-ae44-c7f1b489cbc6",
      "title": "The Rustc Learning Working Group - An Introduction",
      "content_text": "The Learning Working Group, formed in April 2019, is focused on making the compiler easier to learn by ensuring that rustc-guide and API docs are \"complete\". It is one of the many efforts by the Rust Compiler team to decrease the barrier of contributing to the compiler.",
      "url": "https://blog.rust-lang.org/inside-rust/2019/10/28/rustc-learning-working-group-introduction.html",
      "date_published": "2019-10-28T00:00:00+00:00",
      "author": {
        "name": "Amanjeev Sethi",
        "url": "https://blog.rust-lang.org/inside-rust/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6d1c1c33-6e97-4911-af35-4b6e621da968",
      "title": "Audio Processing for Dummies",
      "content_text": "In my spare time I‚Äôm an emergency services volunteer, and one of the tasks our unit has is to run the radio network and keep track of what‚Äôs happening. This can be a pretty stressful job, especially when there‚Äôs lots of radio traffic, and it‚Äôs not unusual to miss words or entire transmissions.\n\nTo help with a personal project that could make the job easier I‚Äôd like to implement a basic component of audio processing, the Noise Gate.",
      "url": "http://adventures.michaelfbryan.com/posts/audio-processing-for-dummies/",
      "date_published": "2019-10-27T23:34:00+08:00",
      "author": {
        "name": "Michael-F-Bryan",
        "url": "http://adventures.michaelfbryan.com/posts/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "49a2176c-55b0-4603-8f20-d0d15ab56ca4",
      "title": "Programming Servo: the incredibly shrinking timer",
      "content_text": "How to build a timer in Rust in five easy evolutionary steps.",
      "url": "https://medium.com/programming-servo/programming-servo-the-incredibly-shrinking-timer-7283ae2a2669",
      "date_published": "2019-10-27T15:40:54.995+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "da517b10-2b8a-4b94-97c3-34b0c049de42",
      "title": "Why async fn in traits are hard",
      "content_text": "After reading boat‚Äôs excellent post on asynchronous destructors, I thought it might be a good idea to write some about async fn in traits. Support for async fn in traits is probably the single most common feature request that I hear about. It‚Äôs also one of the more complex topics. So I thought it‚Äôd be nice to do a blog post kind of giving the ‚Äúlay of the land‚Äù on that feature ‚Äì what makes it complicated? What questions remain open?",
      "url": "http://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/",
      "date_published": "2019-10-26T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6e9b1816-3105-4847-b96e-d3af713b9ebc",
      "title": "Cost of rust-analyzer",
      "content_text": "In this post, we‚Äôll talk about financial side of the rust-analyzer project. The goal is to find out how much rust-analyzer costs now, formulate financial goals for speeding up the development and document the Open Collective expenses policy.",
      "url": "https://rust-analyzer.github.io/2019/10/16/finance.html",
      "date_published": "2019-10-16T09:00:00+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9b853968-186e-414b-af4a-f4a6cf9e7392",
      "title": "Asynchronous Destructors",
      "content_text": "The first version of async/await syntax is in the beta release, set to be shipped to stable in 1.39 on November 7, next month. There are a wide variety of additional features we could add to async/await in Rust beyond what we‚Äôre shipping in that release, but speaking for myself I know that I‚Äôd like to pump the breaks on pushing forward big ticket items in this space. Let‚Äôs let the ecosystem develop around what we have now before we start sprinting toward more big additions to the language.",
      "url": "https://boats.gitlab.io/blog/post/poll-drop/",
      "date_published": "2019-10-16T00:00:00+00:00",
      "author": {
        "name": "boats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e8d05615-a728-4bea-8f43-400827903e1a",
      "title": "How to not rewrite it in Rust",
      "content_text": "Once you get past the growing pains of the Borrow Checker and realise Rust gives you the power to do things which would be unheard of (or just plain dangerous) in other languages, the temptation to Rewrite it in Rust can be quite strong. However at best, the temptation to RiiR is unproductive (unnecessary duplication of effort), and at worst it can promote the creation of buggy software (why would you be better equipped to write a library for some domain-specific purpose than the original author?",
      "url": "http://adventures.michaelfbryan.com/posts/how-not-to-riir/",
      "date_published": "2019-10-20T19:45:00+08:00",
      "author": {
        "name": "Michael-F-Bryan",
        "url": "http://adventures.michaelfbryan.com/posts/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5a7311d2-3cf3-47fa-bce5-10b0747b30e8",
      "title": "Announcing the LLVM ICE-breaker group",
      "content_text": "Today I'm announcing a new experiment in the compiler team, the LLVM ICE-breaker group. If you're familiar with LLVM and would like to contribute to rustc -- but without taking on a large commitment -- then the LLVM ICE-breaker group might well be for you!",
      "url": "https://blog.rust-lang.org/inside-rust/2019/10/22/LLVM-ICE-breakers.html",
      "date_published": "2019-10-22T00:00:00+00:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "https://blog.rust-lang.org/inside-rust/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8b2ade3b-1476-4770-a7e2-838c3623a381",
      "title": "Detecting Application Uniqueness and interprocess communication in Rust",
      "content_text": "The aim of this article is to demonstrate one of many ways to detect application uniqueness and establish unilateral interprocess communication in Rust in the Linux platform. Note that the APIs used in this article is not portable to Windows and other *nix systems. Also note that methods used in this article may not be best suitable for all use cases.",
      "url": "https://gitlab.com/snippets/1903637",
      "date_published": "2019-10-14T00:00:00+00:00",
      "author": {
        "name": "9898287",
        "url": "https://gitlab.com/9898287"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8629a67f-d7a6-41e9-80b1-e568f491c325",
      "title": "Announcing Rustup 1.20.0",
      "content_text": "The highlights of this release are profiles support, the ability to get the latest available nightly with all the components you need, and improvements to the rustup doc command. You can also check out the changelog for a list of all the changes included in this release.",
      "url": "https://blog.rust-lang.org/2019/10/15/Rustup-1.20.0.html",
      "date_published": "2019-10-15T00:00:00+00:00",
      "author": {
        "name": "The Rustup Working Group",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "318ffc1c-1f3c-4d9a-b5ea-edaa476d3438",
      "title": "Parsing Rust Strings into Slices",
      "content_text": "A Rust String is a vector of bytes containing a UTF-8 string, which is an uneasy combination. You can‚Äôt simply index into a String: the compiler forbids it, because you‚Äôre far too likely to get one byte of a multi-byte UTF-8 char. Instead you need to use a Chars iterator to parse out the string character by character.",
      "url": "https://wduquette.github.io/parsing-strings-into-slices/",
      "date_published": "2019-08-10T00:00:00+00:00",
      "author": {
        "name": "Will Duquette",
        "url": "https://wduquette.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d6e69577-47b1-4490-a336-a01b166fff6e",
      "title": "Python vs Rust for Neural Networks",
      "content_text": "In a previous post I introduced the MNIST dataset and the problem of classifying handwritten digits. In this post I‚Äôll be using the code I wrote in that post to port a simple neural network implementation to rust. My goal is to explore performance and ergonomics for data science workflows in Rust.",
      "url": "https://ngoldbaum.github.io/posts/python-vs-rust-nn/",
      "date_published": "2019-07-26T14:17:19-04:00",
      "author": {
        "name": "Nathan Goldbaum",
        "url": "https://ngoldbaum.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "dabffd4d-73ef-4700-8711-b648230659b9",
      "title": "We couldn't get Bitcode and Rust to play nice, until we did",
      "content_text": "The Rust compiler has problems creating Bitcode that's compatible with recent versions of Xcode. Ditto uses a custom toolchain that stays in sync with Apple‚Äîand you can too.",
      "url": "https://www.ditto.live/blog/rust-bitcode-with-xcode",
      "date_published": "2019-10-10T00:00:00+00:00",
      "author": {
        "name": "Tom Karpiniec",
        "url": "http://www.ditto.live/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6907953b-62d5-475e-8695-0e89fec37b5e",
      "title": "Why we‚Äôre bringing Astropad cross-platform with Rust",
      "content_text": "Over the past few years, we‚Äôve heard over and over again about an exodus from Mac to Windows in the creative community. Here at Astropad, we‚Äôve kept a close eye on this shift, knowing that Windows would be a big part of our company‚Äôs future. Our flagship products ‚Äî Astropad Studio and Luna Display ‚Äî primarily serve the creative pro market. Both products run on our low-latency, high-fidelity video streaming technology called Liquid that was designed to meet the demands of professional illustrators, animators, and photographers.\n\nWhen we were first building our products, we used the tools we were most comfortable with, like Objective-C and the Cocoa APIs. This allowed us to move quickly, launch Astropad 1.0, and establish product-market fit in a relatively short period of time. But as we grew, we made the mistake of doubling down on Objective-C, and we pushed off the Windows effort because it created a catch-22 situation of engineering hurdles. Our Liquid engine was tightly wrapped around the Apple ecosystem, and the thought of unraveling ourselves was hard to imagine. ",
      "url": "https://blog.astropad.com/why-rust/",
      "date_published": "2019-10-07T19:23:43+00:00",
      "author": {
        "name": "Matt Ronge",
        "url": "https://blog.astropad.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "15c5520b-d7f9-4acc-939f-371cb8fbab95",
      "title": "Async Foundations Update: Time for polish!",
      "content_text": "As you've perhaps heard, recently the async-await feature landed on the Rust beta branch. This marks a big turning point in the usability story for Async Rust. But there's still a lot of work to do. As we mentioned in the main post, the focus for the Async Foundations WG in the immediate term is going to be polish, polish and (ahem) more polish.\n\nIn particular, we want to take aim at a backlog of strange diagnostics, suboptimal performance, and the occasional inexplicable type-check failure. This is a shift: whereas before, we could have laser focus on things that truly blocked stabilization, we've now got a large set of bugs, often without a clear prioritization between them. This requires us to mix up how the Async Foundations WG is operating.",
      "url": "https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html",
      "date_published": "2019-10-07T00:00:00+00:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "https://blog.rust-lang.org/inside-rust/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "409c73c3-8c32-4c3a-97a9-30f700237fe8",
      "title": "Designing a COM library for Rust",
      "content_text": "I interned with Microsoft as a Software Engineering Intern in the MSRC UK team in Cheltenham this past summer. I worked in the Safe Systems Programming Language (SSPL) group, which explores safe programming languages as a proactive measure against memory-safety related vulnerabilities.\n\nThis blog post describes the project that I have been working on under the mentorship of the SSPL team. Hopefully, this provides additional insight into the work Microsoft interns do! My goal was to build an open-sourced Rust library that will allow developers to both consume and produce in-process Component Object Model (COM) components in an idiomatic manner.",
      "url": "https://msrc-blog.microsoft.com/2019/10/08/designing-a-com-library-for-rust/",
      "date_published": "2019-10-08T17:00:03+00:00",
      "author": {
        "name": "Hadrian Wei Heng Lim",
        "url": "https://msrc-blog.microsoft.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "79f41426-ad58-4eac-9adb-88b27c2a63ba",
      "title": "How I handle errors in Rust",
      "content_text": "derive_more is a crate which has many proc macros, amongst which is a macro for deriving From for structs, enums, and newtypes. From is the basic mechanism for using ? ergonomically in a function which returns Result<T, Error>. Almost everything I write has the derive_more crate as a dependency, and the following pattern for handling errors.",
      "url": "https://blog.kiani.io/blog/how-i-handle-errors-in-rust/",
      "date_published": "2019-10-09T00:00:00+00:00",
      "author": {
        "name": "Ashkan Kiani",
        "url": "https://blog.kiani.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e131911e-9ccb-4b6f-9c05-f95611cb66d2",
      "title": "The Node Experiment - Exploring Async Basics with Rust",
      "content_text": "After originally researching the history and discussions about Rusts Async story, I realized I needed a better understanding of async basics and the result is this book. It's published it as a gitbook to make this journey easier for the next person (hopefully).",
      "url": "https://cfsamson.github.io/book-exploring-async-basics/",
      "date_published": "2019-10-10T00:00:00+00:00",
      "author": {
        "name": "Carl Fredrik Samson",
        "url": "https://github.com/cfsamson"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f7d6bffe-ea86-4fbc-9aa6-4ba15b3929a5",
      "title": "Building the Azure IoT Edge Security Daemon in Rust",
      "content_text": "Azure IoT Edge is an open source, cross platform software project from the Azure IoT team at Microsoft that seeks to solve the problem of managing distribution of compute to the edge of your on-premise network from the cloud. This post explains some of the rationale behind our choice of Rust as the implementation programming language for the Security Daemon component in the product.",
      "url": "https://msrc-blog.microsoft.com/2019/09/30/building-the-azure-iot-edge-security-daemon-in-rust/",
      "date_published": "2019-09-30T16:45:48+00:00",
      "author": {
        "name": "Raj Vengalil",
        "url": "https://msrc-blog.microsoft.com/"
      },
      "tags": [
        "Security",
        "Language"
      ]
    },
    {
      "id": "51a1a155-fccb-426f-b0e5-f4670be28e9d",
      "title": "Figthting The Async Fragmentation",
      "content_text": "Sometimes, I get this nudging feeling that something is not exactly right and that I have to go out and save the world and fix it (even though it‚Äôs usually something minor or doesn‚Äôt need fixing at all). I guess everyone has days like these. It‚Äôs part what drives me to invest my free time to writing software.\n\nThis is about some dead ends when trying to fix the problem of Rust‚Äôs async networking fragmentation. I haven‚Äôt been successful, but I can at least share what I tried and discovered, maybe someone else is having the same bugging feeling so they don‚Äôt have to repeat them. Or just maybe some of the approaches would work for some other problems. And because we have a bunch of success stories out there, having some failure stories to balance it doesn‚Äôt hurt.",
      "url": "https://vorner.github.io/2019/09/29/figthting-the-async-fragmentation.html",
      "date_published": "2019-09-29T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "55e7a635-29bd-4a2d-aaac-b0d599006ff7",
      "title": "The \"Inside Rust\" Blog",
      "content_text": "This is the \"Inside Rust\" blog. This blog is aimed at those who wish to follow along with Rust development. The various Rust teams and working groups use this blog to post status updates, calls for help, and other similar announcements.",
      "url": "https://blog.rust-lang.org/inside-rust/",
      "date_published": "2019-10-04T01:18:00+00:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "https://blog.rust-lang.org/inside-rust/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "258e95ec-03a2-47b2-b577-cf45ad96924e",
      "title": "Async Builders",
      "content_text": "Last month we introduced Surf, an async cross-platform streaming HTTP client for Rust. It was met with a great reception, and people generally seem to be really enjoying it. A common piece of feedback we've gotten is how much people enjoy the interface, in particular how little code it requires to create HTTP requests. In this post we'll cover a pattern at the heart of Surf's ergonomics stjepang came up with: the \"async finalizer\".",
      "url": "https://blog.yoshuawuyts.com/async-finalizers/",
      "date_published": "2019-09-21T00:00:00+00:00",
      "author": {
        "name": "Yoshua Wuyts",
        "url": "https://blog.yoshuawuyts.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7a86a452-ec34-4489-b209-f91aecdd6d98",
      "title": "Plugins in Rust",
      "content_text": "Imagine you are implementing a calculator application and want users to be able to extend the application with their own functionality. For example, imagine a user wants to provide a random() function that generates true random numbers using random.org instead of the pseudo-random numbers that a crate like rand would provide.\n\nThe Rust language gives you a lot of really powerful tools for adding flexibility and extensibility to your applications (e.g. traits, enums, macros), but all of these happen at compile time. Unfortunately, to get the flexibility that we‚Äôre looking we‚Äôll need to be able to add new functionalty at runtime. This can be achieved using a technique called Dynamic Loading.",
      "url": "http://adventures.michaelfbryan.com/posts/plugins-in-rust/",
      "date_published": "2019-09-30T22:04:58+08:00",
      "author": {
        "name": "Michael-F-Bryan",
        "url": "http://adventures.michaelfbryan.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "63fb93a7-e179-491f-83b9-84a7e284fe48",
      "title": "Is This Magic!? Ferris Explores Rustc!",
      "content_text": "A companion to the RustConf 2019 talk with the same name; an introduction to making your first contribution to the Rust compiler.",
      "url": "https://quietmisdreavus.net/code/2019/08/23/is-this-magic-ferris-explores-rustc/",
      "date_published": "2019-08-23T11:00:00-05:00",
      "author": {
        "name": "QuietMisdreavus",
        "url": "https://quietmisdreavus.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d9b796b1-aacb-4a2f-ad7b-05ce22cc3ec1",
      "title": "Announcing Rust 1.38.0",
      "content_text": "The highlight of this release is pipelined compilation. The release also includes linting of some incorrect uses of mem::{uninitialized, zeroed}, #[deprecated] macros, std::any::type_name, and more.",
      "url": "https://blog.rust-lang.org/2019/09/26/Rust-1.38.0.html",
      "date_published": "2019-09-26T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fbf09d15-52c8-4ab6-a6bf-22c0b238aedb",
      "title": "Async-await hits beta!",
      "content_text": "Big news! As of this writing, syntactic support for async-await is available in the Rust beta channel! It will be available in the 1.39 release, which is expected to be released on November 7th, 2019. Once async-await hits stable, that will mark the culmination of a multi-year effort to enable efficient and ergonomic asynchronous I/O in Rust. It will not, however, mark the end of the road: there is still more work to do, both in terms of polish (some of the error messages we get today are, um, not great) and in terms of feature set (async fn in traits, anyone?).",
      "url": "https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html",
      "date_published": "2019-09-30T00:00:00+00:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language",
        "async"
      ]
    },
    {
      "id": "d821223f-0e0c-4bbf-a248-7191d0c0c1da",
      "title": "Futures Concurrency",
      "content_text": "In a previous post we've looked at Rust streams. In this post we're going to discuss another problem in the async space: futures concurrency combinators. We're going to cover the different forms of concurrency that can be expressed with Futures, and cover both fallible and infallible variants.",
      "url": "https://blog.yoshuawuyts.com/futures-concurrency/",
      "date_published": "2019-09-02T00:00:00+00:00",
      "author": {
        "name": "Yoshua Wuyts",
        "url": "https://blog.yoshuawuyts.com/"
      },
      "tags": [
        "Language",
        "async"
      ]
    },
    {
      "id": "518da2d7-644e-4028-95a2-388b2cb5fc0f",
      "title": "Async Stack Traces in Rust",
      "content_text": "One neat result of Rust‚Äôs futures and async/await design is that all of the async callers are on the stack below the async callees. In most other languages, only the youngest async callee is on the stack, and none of the async callers. Because the youngest frame is most often not where a bug‚Äôs root cause lies, this extra context makes debugging async code easier in Rust.",
      "url": "http://fitzgeraldnick.com/2019/08/27/async-stacks-in-rust.html",
      "date_published": "2019-08-27T00:00:00-07:00",
      "author": {
        "name": "Nick Fitzgerald",
        "url": "http://fitzgeraldnick.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7304ebe7-ee28-48a9-b88c-dd03e2605a10",
      "title": "How Rust optimizes async/await II: Program analysis",
      "content_text": "In Part 1, we covered how async fns in Rust are compiled to state machines. We saw that the internal compiler implementation uses generators and the yield statement to facilitate this transformation. In this post, we'll go over some subtleties that the compiler implementation must consider when optimizing generators. We'll look at two different kinds of analysis, liveness analysis and storage conflict detection.",
      "url": "https://tmandry.gitlab.io/blog/posts/optimizing-await-2/",
      "date_published": "2019-09-02T00:00:00+00:00",
      "author": {
        "name": "Tyler Mandry",
        "url": "https://tmandry.gitlab.io/blog/"
      },
      "tags": [
        "Performance",
        "Language"
      ]
    },
    {
      "id": "eb9194f2-85b1-412c-aa0b-0218529bf163",
      "title": "Wrapping Unsafe C Libraries in Rust",
      "content_text": "In this article, we will explore how to wrap those functions and make them safe for normal use. We‚Äôll go over how to define a wrapper struct that handles initialization and cleanup, and describe some traits that describe how application developers can safely use your library with threads. We‚Äôll also talk a bit about how to turn a function‚Äôs random integer return into an ergonomic, type-checked Result, how to translate strings and arrays to and from the world of C, and how to turn raw pointers returned from C into scoped objects with inherited lifetimes.\n\nThe overall goal of this step is to dig into the C library‚Äôs documentation and make each function‚Äôs internal assumptions explicit.",
      "url": "https://medium.com/dwelo-r-d/wrapping-unsafe-c-libraries-in-rust-d75aeb283c65",
      "date_published": "2019-08-24T07:09:28.812+00:00",
      "author": {
        "name": "Jeff Hiner",
        "url": "https://medium.com/@jhiner"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4bf39b49-7652-4132-8a42-c12c7d922ab9",
      "title": "Understanding Futures in Rust -- Part 2",
      "content_text": "If you're familiar with promises in JavaScript and followed the last blog post you may have been confused about where the familiar combinators (then, catch, and finally) were in the previous post. You will find their equivalents in this post, and, by the end, the following code will compile. You will also gain an understanding of the types, traits, and underling concepts that make futures work.",
      "url": "https://www.viget.com/articles/understanding-futures-is-rust-part-2/",
      "date_published": "2019-08-15T00:00:00+00:00",
      "author": {
        "name": "Joe Jackson",
        "url": "https://www.viget.com/about/team/jjackson"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2938c850-88bc-4bec-b0fb-f2561f4a0b17",
      "title": "Runtime Configuration Reloading",
      "content_text": "A lot of programs need to read some kind of configuration at startup. But the challenge doesn‚Äôt end here. Some programs ‚Äí certainly not all, but some ‚Äí are long running. For these, restarting them to change configuration isn‚Äôt something you‚Äôd want to do. The unix daemon convention is to send a SIGHUP signal to the process.",
      "url": "https://vorner.github.io/2019/08/11/runtime-configuration-reloading.html",
      "date_published": "2019-08-11T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "86fe455b-cfd7-472b-860b-2d969a8cd5ba",
      "title": "Using C Libraries in Rust",
      "content_text": "Today I want to dig into one of the difficulties we ran into while trying to rewrite our IoT Python code in Rust: specifically FFI, or the ‚ÄúForeign Function Interface‚Äù ‚Äî the bit that allows Rust to interact with other languages. When I tried to write Rust code to integrate with C libraries a year ago, the existing documents and guides often gave conflicting advice, and I had to stumble through the process on my own. This guide is intended to help future Rustaceans work through the process of porting C libraries to Rust, and familiarize the reader with the most common problems we encountered while doing the same.",
      "url": "https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72a",
      "date_published": "2019-08-17T00:22:36.987+00:00",
      "author": {
        "name": "Jeff Hiner",
        "url": "https://medium.com/@jhiner"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c50ebb87-7e8f-4d08-bc8c-ebe51377faf4",
      "title": "Join Your Threads",
      "content_text": "This is a note on how to make multithreaded programs more robust. It‚Äôs not really specific to Rust, but I get to advertise my new jod-thread micro-crate :)",
      "url": "https://matklad.github.io/2019/08/23/join-your-threads.html",
      "date_published": "2019-08-23T00:00:00+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "dac15914-213c-4397-8485-eb2156b0e88b",
      "title": "Updating to Async/Await",
      "content_text": "We‚Äôre pleased to announce the release of the first Tokio alpha with async & await support. This includes updating all of the Tokio crates to use std::future instead of futures 0.1. It also includes adding async fn versions of the APIs.",
      "url": "https://leshow.github.io/post/async_await/",
      "date_published": "2019-08-12T09:30:08-04:00",
      "author": {
        "name": "Evan Cameron",
        "url": "https://leshow.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "398562a1-3ec5-4277-8a7c-5c3388fed5ba",
      "title": "Rust: safe and unsafe as theorems and axioms",
      "content_text": "There is a fair amount of confusion about what unsafe means in Rust, as well as debate about how one should think about it. Recently I‚Äôve seen several blog posts like What is Rust‚Äôs unsafe?, The Temptation of Unsafe and Unsafe as a Human-Assisted Type System. I‚Äôm not really attempting to explain what is considered unsafe in Rust, which is explained by the reference. Nor am I going to try to answer the question of precisely when unsafe should be used and how often. My basic suggestion: we can think of unsafe in terms of mathematical axioms and theorems. This understanding is somewhere in between actual mathematical rigour and an analogy.",
      "url": "https://iandouglasscott.com/2019/07/26/rust-safe-and-unsafe-as-theorems-and-axioms/",
      "date_published": "2019-07-26T15:37:00-07:00",
      "author": {
        "name": "Ian Douglas Scott",
        "url": "https://iandouglasscott.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fd4779eb-f9f4-4c63-98c9-d7fe21fb6bac",
      "title": "Rust for OOP - Closures",
      "content_text": "Turning functions into first-class citizens in our programming languages is one of the major changes of the decade. Well, kind of. The concept, also known as lambda, is far from new. Functional programming languages had it from the very start, during the late ‚Äô50s. Even some of the object-oriented languages like Python had it quite early, back in 1994. However it became an official part of C++ only in 2011, and Java brought it even later in 2014. And with those two languages and many others, it became the norm, even for non-functional programming. As first-class citizens, functions can be saved as variables or transfer as arguments to functions easily.",
      "url": "https://oribenshir.github.io/afternoon_rusting/blog/closures",
      "date_published": "2019-07-19T00:00:00+00:00",
      "author": {
        "name": "Ori Ben-Shir",
        "url": "https://oribenshir.github.io/afternoon_rusting/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "902d33e4-a66a-479e-8758-f543083da639",
      "title": "Await a minute, why bother?",
      "content_text": "Recently I have been retooling some core Rust libraries at $work to play nicely with native async/await syntax. This note covers my thoughts on why this feature is so important to our async codebase if it's \"just\" syntax sugar for a job that could just be done using raw Futures instead.",
      "url": "https://docs.rs/dtolnay/0.0.5/dtolnay/macro._01__await_a_minute.html",
      "date_published": "2019-08-08T00:00:00+00:00",
      "author": {
        "name": "David Tolnay",
        "url": "https://docs.rs/dtolnay/0.0.5/dtolnay/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5b9044be-428f-48ff-b1f3-b9f0e6b63732",
      "title": "Thoughts on Rust bloat",
      "content_text": "I‚Äôm about to accept a PR that will increase druid‚Äôs compile time about 3x and its executable size almost 2x. In this case, I think the tradeoff is worth it (without localization, a GUI toolkit is strictly a toy), but the bloat makes me unhappy and I think there is room for improvement in the Rust ecosystem.",
      "url": "https://raphlinus.github.io/rust/2019/08/21/rust-bloat.html",
      "date_published": "2019-08-21T17:17:42+00:00",
      "author": {
        "name": "Raph Levien",
        "url": "https://raphlinus.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "76cefd5b-2344-4629-84fb-5bf5c45c0ce0",
      "title": "Announcing Rust 1.37.0",
      "content_text": "The highlights of Rust 1.37.0 include referring to enum variants through type aliases, built-in cargo vendor, unnamed const items, profile-guided optimization, a default-run key in Cargo, and #[repr(align(N))] on enums. Read on for a few highlights, or see the detailed release notes for additional information.",
      "url": "https://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html",
      "date_published": "2019-08-15T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "98583b20-bd88-4cad-8a18-5e375c6c369f",
      "title": "Unsafe as a Human-Assisted Type System",
      "content_text": "This is a short note about yet another way to look at Rust‚Äôs unsafe. Today, an interesting bug was found in rustc, which made me aware just how useful unsafe is for making code maintainable. The story begins a couple of months ago, when I was casually browsing through recent pull requests for rust-lang/rust. I was probably waiting for my code to compile at that moment :] Anyway, a pull request caught my attention, and, while I was reading the diff, I noticed a usage of unsafe.",
      "url": "https://matklad.github.io/2019/07/25/unsafe-as-a-type-system.html",
      "date_published": "2019-07-25T00:00:00+03:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6f824da5-4033-40da-994f-581a7909e50e",
      "title": "Introduction",
      "content_text": "A home for compiler team planning documents, meeting minutes, and other such things. If you‚Äôre interested in learning about how rustc works ‚Äì as well as advice on building the compiler, preparing a PR, and other similar topics ‚Äì check out the rustc-guide.",
      "url": "https://rust-lang.github.io/compiler-team/",
      "date_published": "2019-08-18T04:30:25+00:00",
      "author": {
        "name": "Rust Lang Compiler Team",
        "url": "https://rust-lang.github.io/compiler-team"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2a87f758-3eaf-4971-a00f-02f3175d0db5",
      "title": "Follow-up to Method on Emulating Higher-Kinded Types (HKTs) in Rust",
      "content_text": "First off, thanks for all the comments and kind words on the original writeup; I've been meaning to follow up on some of the suggestions and write about the different ways to represent monads (and functors, HKTs, etc) that now exist, but a month of being busy has kind of gotten in the way (mainly with three new kittens!).\n\nAnd for sure, I do not expect (nor do I want) this to become the norm for production-level Rust: rather, I hope that this can contribute to the foundations of programming with higher-level abstractions in Rust, somewhat like how early template metaprogramming in C++ and typeclass-constraint-unification metaprogramming in Haskell have contributed, perhaps indirectly, to later innovations in their respective languages and ecosystems that were much more reasoned, sound and usable.",
      "url": "https://gist.github.com/edmundsmith/e09d5f473172066c0023ef84ee830cad",
      "date_published": "2019-08-08T11:44:35+00:00",
      "author": {
        "name": "Edmund Smith",
        "url": "https://gist.github.com/edmundsmith"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "27ce3b2b-a0fc-4cf2-ade4-1d4bcd1dabf7",
      "title": "My First Three Months With Rust",
      "content_text": "I‚Äôve used C++ professionally in games and simulations for over 10 years, and in the past few years I‚Äôve also used C# to build distributed backend systems. Lately, I‚Äôve been exploring Rust.",
      "url": "https://blog.aclysma.com/my-first-three-months-with-rust/",
      "date_published": "2019-08-07T19:13:41+00:00",
      "author": {
        "name": "Philip Degarmo",
        "url": "https://blog.aclysma.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ac36b146-f880-46e7-9f3f-819ab9daefa8",
      "title": "My Thoughts on Rust's Future: A Positive Outlook",
      "content_text": "I'm feeling really positive about Rust's prospects of popularity and wide-spread adoption in the future. I've been a part of the Rust community for three years now, and it feels like the stars are starting to align in order to let Rust jump into a position of dominance in the programming language world. There are several different, wide-spread, and mostly unrelated trends that I've noticed are all coming together with positive implications for Rust.",
      "url": "https://cprimozic.net/blog/my-thoughts-on-rusts-future/",
      "date_published": "2019-08-03T00:00:00+00:00",
      "author": {
        "name": "Casey Primozic",
        "url": "https://cprimozic.net/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ab2b1d95-83c2-4541-9f2d-bb5224d0b713",
      "title": "HOWTO: Replace mem::uninitialized with mem::MaybeUninit",
      "content_text": "The recent 1.36.0 release of Rust has brought a mem::MaybeUninit union that allows safer handling of possibly uninitialized data. MaybeUninit is a replacement of mem::uninitialized. Why? Because using mem::uninitialized it is damn easy to shoot yourself in the foot.",
      "url": "https://www.reddit.com/r/rust/comments/cefgec/howto_replace_memuninitialized_with_memmaybeuninit/",
      "date_published": "2019-07-19T10:59:18+00:00",
      "author": {
        "name": "Roman Proskuryakov",
        "url": "https://www.reddit.com/user/rproskuryakov/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "461ba118-af83-41c6-8afc-42b1d320a826",
      "title": "Understanding Lifetimes",
      "content_text": "In this post, I want to describe the Lifetimes in a different way that what I‚Äôm learned from the RFC. Audience: You may already have read the Rust Book. Nice if you took a compiler course.",
      "url": "https://rniczh.github.io/blog/lifetimes-intro/",
      "date_published": "2019-06-05T00:00:00+00:00",
      "author": {
        "name": "Hong-Sheng Zheng",
        "url": "https://rniczh.github.io/"
      },
      "tags": [
        "Computer Science",
        "Language"
      ]
    },
    {
      "id": "a0f3d2bb-e52e-440b-809f-169497494769",
      "title": "The Temptation of Unsafe",
      "content_text": "Recently, another round of discussion concerning the use of Rust‚Äôs unsafe features in the Actix web framework happened, or rather erupted, on Reddit, even more heated and acrimonious than the first time around. (I am not linking to any of the threads, as I believe that they don‚Äôt need any more exposure. Use your favorite search engine.) This proves, if more proof is needed, that people hold passionate beliefs about the matter.",
      "url": "https://inejge.github.io/blog/2019/07/18/The-Temptation-of-Unsafe.html",
      "date_published": "2019-07-18T00:00:00+00:00",
      "author": {
        "name": "inejge",
        "url": "https://inejge.github.io/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "85b61a6b-91ab-4194-a236-43a690cc3f2f",
      "title": "Perils of Constructors",
      "content_text": "One of my favorite blog posts about Rust is Things Rust Shipped Without by Graydon Hoare. To me, footguns that don‚Äôt exist in a language are usually more important than expressiveness. In this slightly philosophical essay, I want to tell about a missing Rust feature I especially like: constructors.",
      "url": "https://matklad.github.io/2019/07/16/perils-of-constructors.html",
      "date_published": "2019-07-16T00:00:00+03:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "649aefcc-0d0c-4e1c-b2d2-337d3110c606",
      "title": "Rust vs C++ - Implementing a Neural Network",
      "content_text": "I first learned Rust back in 2014, before it was stable. Rust is definitely a very interesting language so I have decided to revisit it by programming a simple neural network. For comparison, I also implemented the network in C++, the language I'm looking to replace.",
      "url": "http://nicktasios.nl/posts/rust-vs-c%2B%2B-implementing-a-neural-network.html",
      "date_published": "2019-07-06T19:18:48+02:00",
      "author": {
        "name": "Nick Tasios",
        "url": "http://nicktasios.nl/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "20553a37-476d-45bb-8180-3de54aa932cd",
      "title": "Testable Component Design in Rust",
      "content_text": "I consider myself an advanced beginner in Rust. There is still much I‚Äôm wrapping my head around‚Äìand I still get caught off guard by the ‚Äúmove‚Äù and ‚Äúmutability‚Äù rules Rust enforces. However, in keeping with my personal emphasis, I‚Äôve devoted my efforts to learning how to create automated tests in Rust. The below guidelines are not exhaustive, but represent my learning so far. Feedback is welcome!",
      "url": "http://iextendable.com/2019/07/12/testable-component-design-in-rust/",
      "date_published": "2019-07-12T13:57:01+00:00",
      "author": {
        "name": "Chris McKenzie",
        "url": "http://iextendable.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3161bc30-9df4-4273-8ff7-301ea0426d9f",
      "title": "\"What The Hardware Does\" is not What Your Program Does: Uninitialized Memory",
      "content_text": "This post is about uninitialized memory, but also about the semantics of highly optimized ‚Äúlow-level‚Äù languages in general. I will try to convince you that reasoning by ‚Äúwhat the hardware does‚Äù is inherently flawed when talking about languages such as Rust, C or C++. These are not low-level languages. I have made this point before in the context of pointers; this time it is going to be about uninitialized memory.",
      "url": "https://www.ralfj.de/blog/2019/07/14/uninit.html",
      "date_published": "2019-07-14T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a05e51b1-ea5d-4365-949c-80c0c3e48d54",
      "title": "What Is Rust's unsafe?",
      "content_text": "I‚Äôve seen a lot of misconceptions around what the unsafe keyword means for the utility and validity of Rust and its marketing as a ‚Äúsafe systems language‚Äù. The truth is a lot more complicated than a single pithy tweet can possibly sum up, unfortunately; here it is as I see it.\n\nBasically, the unsafe keyword does not turn off the advanced type system that keeps Rust code honest. It only allows a few select ‚Äúsuperpowers‚Äù, like dereferencing raw pointers. It is used to implement safe abstractions over a fundamentally unsafe world so that the majority of Rust code can use those abstractions and avoid memory unsafety.",
      "url": "https://nora.codes/post/what-is-rusts-unsafe/",
      "date_published": "2019-07-12T10:00:00-07:00",
      "author": {
        "name": "Leonora Tindall",
        "url": "https://nora.codes/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "55481592-1914-40bc-a2be-f7be9702c5c7",
      "title": "Method for Emulating Higher-Kinded Types in Rust",
      "content_text": "I've been fiddling about with an idea lately, looking at how higher-kinded types can be represented in such a way that we can reason with them in Rust here and now, without having to wait a couple years for what would be a significant change to the language and compiler.\n\nThere have been multiple discussions on introducing higher-ranked polymorphism into Rust, using Haskell-style Higher-Kinded Types (HKTs) or Scala-looking Generalised Associated Types (GATs). The benefit of higher-ranked polymorphism is to allow higher-level, richer abstractions and pattern expression than just the rank-1 polymorphism we have today.",
      "url": "https://gist.github.com/edmundsmith/855fcf0cb35dd467c29a9350481f0ecf",
      "date_published": "2019-07-07T20:47:09+00:00",
      "author": {
        "name": "Edmund Smith",
        "url": "https://gist.github.com/edmundsmith"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "815aa1ce-d98e-484c-8dbf-a91fce9a4167",
      "title": "Async-await status report #2",
      "content_text": "I wanted to give an update on the status of the ‚Äúasync-await foundations‚Äù working group. This post aims to cover three things: the ‚Äúasync await MVP‚Äù that we are currently targeting; how that fits into the bigger picture; and how you can help, if you‚Äôre so inclined;",
      "url": "http://smallcultfollowing.com/babysteps/blog/2019/07/08/async-await-status-report-2/",
      "date_published": "2019-07-08T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6d02baa8-8fcd-45fa-9f96-d36a635a2379",
      "title": "AiC: Unbounded queues and lang design",
      "content_text": "I have been thinking about how language feature development works in Rust1. I wanted to write a post about what I see as one of the key problems: too much concurrency in our design process, without any kind of ‚Äúback-pressure‚Äù to help keep the number of ‚Äúopen efforts‚Äù under control. This setup does enable us to get a lot of things done sometimes, but I believe it also leads to a number of problems.\n\nAlthough I don‚Äôt make any proposals in this post, I am basically advocating for changes to our process that can help us to stay focused on a few active things at a time. Basically, incorporating a notion of capacity such that, if we want to start something new, we either have to finish up with something or else find a way to grow our capacity.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2019/07/10/aic-unbounded-queues-and-lang-design/",
      "date_published": "2019-07-10T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3d786e81-3097-48f1-aea9-9a86473f6957",
      "title": "Functional Programming Jargon in Rust",
      "content_text": "Github Repository: https://github.com/JasonShin/functional-programming-jargon.rsFunctional programming (FP) provides many advantages, and its popula...",
      "url": "https://functional.works-hub.com/learn/functional-programming-jargon-in-rust-1b555",
      "date_published": "2019-07-05T00:00:00+00:00",
      "author": {
        "name": "Jason Shin",
        "url": "https://functional.works-hub.com/learn/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "75040309-d3a6-4941-a8d1-28c6f8bdfc19",
      "title": "Announcing Rust 1.36.0",
      "content_text": "This release brings many changes, including the stabilization of the Future trait, the alloc crate, the MaybeUninit<T> type, NLL for Rust 2015, a new HashMap<K, V> implementation, and --offline support in Cargo. Read on for a few highlights, or see the detailed release notes for additional information.",
      "url": "https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html",
      "date_published": "2019-07-04T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4ab235dc-fc27-4dfe-aefc-1bcc16a23199",
      "title": "Cargo --offline ‚úàÔ∏è",
      "content_text": "Rust 1.36 is released on the 4th July and includes a bunch of new stuff. This blog post is about one newly stable feature in Cargo: --offline.",
      "url": "https://www.ncameron.org/blog/cargo-offline/",
      "date_published": "2019-07-04T08:13:57+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a11e4440-7ad1-4e28-95d7-db6cc8a4544b",
      "title": "Rust std study series: alloc",
      "content_text": "Let‚Äôs get deep into std::alloc! The very basic need for any program to compile and execute is having access to either physical memory or virtual memory. An allocator is responsible for providing such an access. You can think of an allocator as a service, taking some sort of requests and either giving back a (pointer) to block of memory or some errors. In Rust, a request is a Layout i.e. some meta-data about how the memory we want is supposed to take up the space.",
      "url": "https://ehsanmkermani.com/2019/07/03/rust-std-study-series-alloc/",
      "date_published": "2019-07-04T00:20:38+00:00",
      "author": {
        "name": "Ehsan M. Kermani",
        "url": "https://ehsanmkermani.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ec53084d-522d-4916-90b2-c8adda4b75f2",
      "title": "Rust modules vs files",
      "content_text": "A while back, I asked on Twitter what people found confusing in Rust, and one of the top topics was ‚Äúhow the module system maps to files‚Äù. I remember struggling with that a lot when I first started Rust, so I‚Äôll try to explain it in a way that makes sense to me.",
      "url": "https://amos.me/blog/2019/rust-modules-vs-files/",
      "date_published": "2019-07-01T00:00:00+00:00",
      "author": {
        "name": "amos",
        "url": "https://amos.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6e2a2811-942b-4e62-b173-6d2b0d3e0acd",
      "title": "Writing a small ray tracer in Rust and Zig",
      "content_text": "The two languages that I spent most of my time daydreaming about writing code in are Rust and Zig. Would the lack of features in Zig make me more or less productive than with Rust‚Äôs feature overload? Which language is more enjoyable to use for writing a small, self-contained computer graphics project?  To find out, I decided to implement the same simple project in both languages: a small ray tracer, following the book Ray Tracing in One Weekend.",
      "url": "https://nelari.us/post/raytracer_with_rust_and_zig/",
      "date_published": "2019-06-27T20:00:00+02:00",
      "author": {
        "name": "Johann Muszynski",
        "url": "https://nelari.us/"
      },
      "tags": [
        "Language",
        "Performance"
      ]
    },
    {
      "id": "a7b2c09d-06ca-4ae2-89c2-70bf78282396",
      "title": "One Program Written in Python, Go, and Rust",
      "content_text": "This is a subjective, primarily developer-ergonomics-based comparison of the three languages from the perspective of a Python developer, but you can skip the prose and go to the code samples, the performance comparison if you want some hard numbers, the takeaway for the tl;dr, or the Python, Go, and Rust diffimg implementations.",
      "url": "http://www.nicolas-hahn.com/python/go/rust/programming/2019/07/01/program-in-python-go-rust/",
      "date_published": "2019-07-01T00:00:00+00:00",
      "author": {
        "name": "Nicolas Hahn",
        "url": "http://www.nicolas-hahn.com/"
      },
      "tags": [
        "Language",
        "Performance"
      ]
    },
    {
      "id": "38abc54a-6b27-48ec-8789-363ead337d8a",
      "title": "Sharing references between Python and Rust",
      "content_text": "In 2018, the Mercurial project decided to use Rust to improve performance and maintainability of previous high-performance code. We have faced some interesting challenges when bridging the Python implementation with the new Rust code, and this is one that I have not found any literature about.",
      "url": "https://raphaelgomes.dev/blog/articles/2019-07-01-sharing-references-between-python-and-rust.html",
      "date_published": "2019-07-01T00:00:00+00:00",
      "author": {
        "name": "Rapha√´l Gom√®s",
        "url": "https://raphaelgomes.dev/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "09564ee8-19af-4b03-95c4-b231ffd7f24f",
      "title": "Status of rust-analyzer: Achievements and Open Collective",
      "content_text": "rust-analyzer is an experimental compiler frontend for the Rust programming language. The ultimate goal for this project is to provide the perfect IDE experience for Rust, with all IDE features working flawlessly while editing code. This post talks about what happened to rust-analyzer in between the all-hands and today, discusses future plans, and also announces the rust-analyzer Open Collective.",
      "url": "https://ferrous-systems.com/blog/rust-analyzer-status-opencollective/",
      "date_published": "2019-07-01T22:00:00+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://ferrous-systems.com/blog"
      },
      "tags": [
        "Language",
        "Community"
      ]
    },
    {
      "id": "cb4c2736-6856-435e-a605-8d7b2155a1c3",
      "title": "My iterator is returning a reference to a reference",
      "content_text": "Sometimes you mean it. Other times you really don't. It can be a bit of a headscratcher, but is not a particularly complicated situation, just easy to stumble into on a tired afternoon. In the end it all comes down to the ensuring you're being purposeful about what you're iterating over. I'll take a relatively brief dive into what can cause this, and how you can get back to iterating over what you want to iterate over.",
      "url": "https://blog.tawhidhannan.co.uk/rust/tidbits/rust-double-ref",
      "date_published": "2019-06-23T00:00:00+00:00",
      "author": {
        "name": "Tawhid Hannan",
        "url": "https://blog.tawhidhannan.co.uk/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c39c6210-76a8-46f1-ab2d-b6f1be909232",
      "title": "Understanding Closures in Rust",
      "content_text": "Summary: Closures are a combination of a function pointer (fn) and a context. A closure with no context is just a function pointer. A closure which has an immutable context belongs to Fn. A closure which has a mutable context belongs to FnMut. A closure that owns its context belongs to FnOnce.",
      "url": "https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759",
      "date_published": "2019-06-26T10:27:58.447+00:00",
      "author": {
        "name": "Andrew Pritchard",
        "url": "https://medium.com/@andrewjpritchard"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f6b00396-a786-403b-b392-16e784f32241",
      "title": "Rust Creator Graydon Hoare Talks About Security, History, and Rust",
      "content_text": "We‚Äôre approaching the 9th anniversary of the day Graydon Hoare (and numerous contributors) first revealed to the world the newly-designed Rust programming language. So we thought it‚Äôd be a good time to assess our current landscape.\n\nHoare graciously agreed, sharing his thoughts on everything from the state of systems programming, to the difficulty of defining safety on ever-more complex systems ‚Äî and whether we‚Äôre truly more secure today, or confronting an inherited software mess that will take decades to clean up.",
      "url": "https://thenewstack.io/rust-creator-graydon-hoare-talks-about-security-history-and-rust/",
      "date_published": "2019-06-18T13:00:49+00:00",
      "author": {
        "name": "David Cassel",
        "url": "https://thenewstack.io/author/destiny/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ca449299-1f7d-493f-9857-b1954e1f371d",
      "title": "Rust std study series: Interior mutability",
      "content_text": "Continuing the standard library study, it‚Äôs time for Cell<T>!",
      "url": "https://ehsanmkermani.com/2019/06/18/rust-std-study-series-interior-mutability/",
      "date_published": "2019-06-18T20:27:25+00:00",
      "author": {
        "name": "Ehsan M. Kermani",
        "url": "https://ehsanmkermani.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ed6c2d09-739d-476b-b46f-441a1eefc6e3",
      "title": "A Journey Through Rust Lifetimes",
      "content_text": "I wanted to write an article about one aspect of Rust I really put off for a long while‚Ää‚Äî‚Äälifetimes. They are one of the hardest parts about Rust to wrap one‚Äôs brain around. Many of us are simply not used to a compiler with a paradigm around memory ownership where such things are needed.\n\nLifetimes help the compiler make your code safer (i.e. less prone to crashing by using unexpected places in memory). Even if we don‚Äôt write them in our code, the compiler is smart enough to figure out your lifetimes without you under the covers. They are often times your secret allies, so let's learn a bit about them.",
      "url": "https://medium.com/@richardanaya/a-journey-through-rust-lifetimes-5a08782c7091",
      "date_published": "2019-06-13T00:09:47.932+00:00",
      "author": {
        "name": "Richard Anaya",
        "url": "https://medium.com/@richardanaya"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d682ecb5-9935-4073-8865-f5a66f2a65f5",
      "title": "Non-Lexical Lifetimes arrives for everyone",
      "content_text": "It has been literally years since I last posted to this blog. I have been doing a bunch of Rust compiler work. One big feature has been deployed: Non-Lexical Lifetimes (hereafter denoted ‚ÄúNLL‚Äù).\n\nThe motivation for this blog post: The next version of Rust, 1.36, is going to have NLL turned on for the 2015 edition. Going forward, all editions of Rust will now use NLL.",
      "url": "http://blog.pnkfx.org/blog/2019/06/26/breaking-news-non-lexical-lifetimes-arrives-for-everyone/",
      "date_published": "2019-06-26T12:54:29+02:00",
      "author": {
        "name": "Felix S. Klock II",
        "url": "http://blog.pnkfx.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f0491f48-a0cd-4f35-a781-a8907f277e8a",
      "title": "std time",
      "content_text": "Over the past month we've been hard at work to add time support to the Runtime crate. One of the things we've had to think about has been examples. Which means we've had a chance to become intimately familiar with the good and less good parts of the std::time API.\n\nIn this post we'll look at the std::time API, and some of the proposed changes to smooth things out a bit. Also disclaimer: I've been involved with these proposals, hehe.",
      "url": "https://blog.yoshuawuyts.com/std-time/",
      "date_published": "2019-06-25T00:00:00+00:00",
      "author": {
        "name": "Yoshua Wuyts",
        "url": "https://blog.yoshuawuyts.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4b9faf2d-145a-4deb-909d-ac58ea05bdc8",
      "title": "Rust type language - journey to rust",
      "content_text": "Disclaimer: If you are learning Rust, take this with grain of salt. I‚Äôm learning Rust too and I may be utterly wrong in my guesses. The more I read and do Rust, the more I realize, that Rust consists of two (three, if macros counts) languages.",
      "url": "https://medium.com/journey-to-rust/rust-type-language-48e1c43b1ef4",
      "date_published": "2019-06-25T14:10:43.359+00:00",
      "author": {
        "name": "George Shuklin",
        "url": "https://medium.com/@george.shuklin"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "170dcb20-7011-4222-afe7-e3eb2298a661",
      "title": "How macros make your Rust life easier and generally better",
      "content_text": "Let‚Äôs explore a topic that has been quite foreign to me for a long time: macros.",
      "url": "https://blog.x5ff.xyz/blog/easy-programming-with-rust-macros/",
      "date_published": "2019-06-07T00:00:00+00:00",
      "author": {
        "name": "Claus",
        "url": "https://blog.x5ff.xyz/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "91f9b804-7782-4a78-ade2-e4d8008923cf",
      "title": "Why we're using Rust for cloud rendering",
      "content_text": "We initially began replacing a small component of our stack using Rust, but it quickly became clear that a larger effort would allow a great reduction in complexity. In the end, all the C, C++, and Python components of the service were rebuilt, with Rust used from task loading through to dispatching GPU operations.",
      "url": "https://www.digitalbridge.com/blog/why-were-using-rust-for-cloud-rendering",
      "date_published": "2019-06-24T12:07:47+00:00",
      "author": {
        "name": "Iain MacIver",
        "url": "https://www.digitalbridge.com/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7fc0def8-20e5-4923-922d-33732b5fc86c",
      "title": "On public API and private implementation",
      "content_text": "In this blog article, I want to explore a problem I‚Äôve been facing from time to time in luminance. The manual dispatch problem. The idea is simple: you are writing a crate and want to expose an API to people. You want them to know which type they can use with a given operation (let‚Äôs call it update). However, the actual implementation of this update function is not performed directly by your API but is deferred to a backend implementation. Some people usually like to do that with several crates; in my case, I really don‚Äôt care and let‚Äôs think in terms of types / modules instead.",
      "url": "https://phaazon.net/blog/public-api-private-implementation",
      "date_published": "2019-06-13T17:05:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fde2b9f7-5ee2-4743-8887-0ae941fc2217",
      "title": "Comparing the Same Project in Rust, Haskell, C++, Python, Scala and OCaml",
      "content_text": "During my final term at UWaterloo I took the CS444 compilers class with a project to write a compiler from a substantial subset of Java to x86, in teams of up to three people with a language of the group‚Äôs choice. This was a rare opportunity to compare implementations of large programs that all did the same thing, written by friends I knew were highly competent, and have a fairly pure opportunity to see what difference design and language choices could make. I gained a lot of useful insights from this. It‚Äôs rare to encounter such a controlled comparison of languages, it‚Äôs not perfect but it‚Äôs much better than most anecdotes people use as the basis for their opinions on programming languages.",
      "url": "http://thume.ca/2019/04/29/comparing-compilers-in-rust-haskell-c-and-python/",
      "date_published": "2019-04-29T00:00:00+00:00",
      "author": {
        "name": "Tristan Hume",
        "url": "http://thume.ca/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "98e8bcf7-00d1-4f6d-ba28-ea41f2d7b705",
      "title": "Experiment with streams, reading files with futures",
      "content_text": "We were experimenting with streams and I wanted to play around with them as well. There are some tokio implementations for async file reading futuers, but since linux filesystems before kernel 5.1 do not really support non blocking file operations. I thought lets have fun breaking things ourselves. As I mentioned this is not really non blocking I/O esp. since there are two ways to view futures in their current state. ",
      "url": "https://chilimatic.hashnode.dev/experiment-with-streams-reading-files-with-futures-cjx1q0gmo001eurs1pt0c27kz",
      "date_published": "2019-06-18T00:00:00+00:00",
      "author": {
        "name": "j",
        "url": "https://chilimatic.hashnode.dev/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6ca39c1c-1424-4f6f-86c0-8e93f84718c0",
      "title": "How do you impl Display for Vec?",
      "content_text": "Or, more generally, how do you implement any trait that is outside of your crate, for a type that is also outside of your crate? Lets create a micro app that helps us explore the problem. We‚Äôll create a simple struct, implement Display for that, then try to implement Display for a Vec of that struct. Once we understand the problem we‚Äôll discuss a simple solution and how to make that solution more idiomatic.",
      "url": "https://medium.com/apolitical-engineering/how-do-you-impl-display-for-vec-b8dbb21d814f",
      "date_published": "2019-06-10T14:03:02.038+00:00",
      "author": {
        "name": "Daniel Mason",
        "url": "https://medium.com/@Gisleburt"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d0496592-58c8-4e56-8cfb-890df49f7b6c",
      "title": "A simple plugin interface for the Rust FFI",
      "content_text": "I present a straight-forward design of a plugin interface using the Rust FFI.",
      "url": "http://kmdouglass.github.io/posts/a-simple-plugin-interface-for-the-rust-ffi/",
      "date_published": "2019-06-16T07:33:33+00:00",
      "author": {
        "name": "Kyle M. Douglass",
        "url": "http://kmdouglass.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7602cf1d-bae1-41bb-bfb8-4d7967af1704",
      "title": "A Detailed Look at Rust Streams",
      "content_text": "As Rust's async story is evolving, so is Rust's streaming story. In this post we'll take a look at how Rust's streaming model works, how to use it effectively, and where things are heading in the future.",
      "url": "https://blog.yoshuawuyts.com/rust-streams/",
      "date_published": "2019-06-20T00:00:00+00:00",
      "author": {
        "name": "Yoshua Wuyts",
        "url": "https://blog.yoshuawuyts.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f756eb13-90c3-407a-a304-66e198248d3b",
      "title": "Distributed Systems Training in Rust and Go",
      "content_text": "PingCAP is creating a series of training courses on writing distributed systems in Rust and Go. These courses consist of:\n\nPractical Networked Applications in Rust. A series of projects that incrementally develop a single Rust project from the ground up into a high-performance, networked, parallel and asynchronous key/value store. Along the way various real-world and practical Rust development subject matter are explored and discussed.\n\nDistributed Systems in Rust. Adapted from the MIT 6.824 distributed systems coursework, this course focuses on implementing important distributed algorithms, including the Raft consensus algorithm, and the Percolator distributed transaction protocol.",
      "url": "https://tikv.org/blog/talent-training/",
      "date_published": "2019-06-20T00:00:00+00:00",
      "author": {
        "name": "Brian Anderson",
        "url": "https://tikv.org/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7d1887a3-55d1-448d-8643-2a520bfddc41",
      "title": "The Typestate Pattern in Rust",
      "content_text": "The typestate pattern is an API design pattern that encodes information about an object's run-time state in its compile-time type. This pattern is so easy in Rust that it's almost obvious, to the point that you may have already written code that uses it, perhaps without realizing it. I haven't seen a detailed examination of the nuances of this pattern, so here's my contribution.",
      "url": "http://cliffle.com/blog/rust-typestate/",
      "date_published": "2019-06-05T00:00:00+00:00",
      "author": {
        "name": "Cliff L. Biffle",
        "url": "http://cliffle.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "922ec00d-8aa7-48eb-9344-c1d1eacc44ec",
      "title": "Threads in rust",
      "content_text": "In our regular hacksession, the current season ;), we are focusing on threading. Concurrency/Multithreading is a really hard topic it has a lot of very specific nomenclature and there are different 'levels' of concurrency one might say. I will start with the nomenclature starting from the programmers / OS perspective.",
      "url": "https://chilimatic.hashnode.dev/threads-in-rust-cjwmbxw9e003pzjs19n7pa0bt",
      "date_published": "2019-06-07T00:00:00+00:00",
      "author": {
        "name": "j",
        "url": "https://chilimatic.hashnode.dev/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "05531a2c-35fc-4e51-ad25-77b362b99e03",
      "title": "Bzip2 in Rust: porting the randomization table",
      "content_text": "Here is a straightforward port of some easy code. randtable.c has a lookup table with seemingly-random numbers. This table is used by the following macros in bzlib_private.h",
      "url": "https://people.gnome.org/~federico/blog/bzip2-in-rust-randomization-table.html",
      "date_published": "2019-06-11T14:30:17-05:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c4166c18-6984-4c64-bda0-68d98d5b3ae7",
      "title": "Determining if a Rust Vector has all equal elements",
      "content_text": "Earlier today, I tooted out a Rust question: How would you write a function to determine if a Vector of integers are all the same, or not. Anyway, the Fediverse is wonderful and full of helpful Rust friends ‚Äì I ended up getting about a dozen solutions (none exactly the same I don‚Äôt think?)",
      "url": "https://sts10.github.io/2019/06/06/is-all-equal-function.html",
      "date_published": "2019-06-06T22:11:00+00:00",
      "author": {
        "name": "Sam Schlinkert",
        "url": "https://sts10.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "30deb171-6751-4af4-9f56-202fe6a78110",
      "title": "Solutions to the first 20 project euler problems",
      "content_text": "I‚Äôm getting more and more used to thinking about Rust code in an idiomatic way, but I don‚Äôt think I‚Äôm comfortable enough to call myself a rustacean yet. To further my goal of oxidizing my brain with rust knowledge, I decided to start working through project euler problems sequentially. I‚Äôve recently finished the first 20 problems and I though I‚Äôd share the highlights of what I learned about rust along the way.",
      "url": "https://ngoldbaum.github.io/posts/project-euler/",
      "date_published": "2019-06-06T10:23:45-04:00",
      "author": {
        "name": "Nathan Goldbaum",
        "url": "https://ngoldbaum.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7d2d904d-78a6-42be-8c41-c1934b975516",
      "title": "Tutorial: Use FlatBuffers in Rust",
      "content_text": "The FlatBuffers project is an extremely efficient schema-versioned serialization library. In this tutorial, you‚Äôll learn how to use it in Rust.",
      "url": "https://rwinslow.com/posts/use-flatbuffers-in-rust/",
      "date_published": "2019-05-17T00:00:00+00:00",
      "author": {
        "name": "Robert Winslow",
        "url": "https://rwinslow.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "37400230-0f89-41d9-a9e4-a0d7460217ab",
      "title": "Overlapping blanket impls",
      "content_text": "Rust doesn‚Äôt allow multiple impls of a trait on the same type. This rule keeps resolution transparent and reliable. It also has an ugly side effect, that for every trait there can be only 1 blanket impl. Compiler is completely distrustful here. What if somebody somewhere created a structure that implemented both ToString and Clone? Should such combination suddenly be forbidden? What about String and u32? This rule prevents type hierarchy from sliding into minefield of odd rules and breakages on every other dependency update.",
      "url": "https://codesandwich.github.io/overlapping_blanket_impls/",
      "date_published": "2019-06-05T12:00:00+00:00",
      "author": {
        "name": "CodeSandwich",
        "url": "https://codesandwich.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d6200716-96c2-4c9c-890d-0047906b7c72",
      "title": "Rust's custom derives in a hexagonal architecture: Incompatible ideas?",
      "content_text": "This blog post is a manifestation of a problem that has been floating around in my head for quite a while now. It is about the seemingly incompatible idea of fully embracing Rust's custom derive system in an application that puts a strong focus on a hexagonal architecture.\n\nTo discuss this problem, I am going to first write about both concepts individually. Feel free to skip over those sections if you are already familiar with the topics. The blog post finishes off with some ideas on how Rust could be extended to better support these kind of usecases.",
      "url": "https://blog.eizinger.io/5835/rust-s-custom-derives-in-a-hexagonal-architecture-incompatible-ideas",
      "date_published": "2019-05-30T00:00:00+00:00",
      "author": {
        "name": "Thomas Eizinger",
        "url": "https://blog.eizinger.io/@thomas_eizinger"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "332be129-192f-46d1-aefc-c3765e5b1b56",
      "title": "Bzip2 in Rust - Basic infrastructure and CRC32 computation",
      "content_text": "I have started a little experiment in porting bits of the widely-used bzip2/bzlib to Rust. I hope this can serve to refresh bzip2, which had its last release in 2010 and has been nominally unmaintained for years.\n\nI hope to make several posts detailing how this port is done. In this post, I'll talk about setting up a Rust infrastructure for bzip2 and my experiments in replacing the C code that does CRC32 computations.",
      "url": "https://people.gnome.org/~federico/blog/bzip2-in-rust-basic-infra.html",
      "date_published": "2019-05-30T10:36:19-05:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "51cdd7b5-fed9-439c-b6f8-c50ee7f93ea2",
      "title": "Creating a 'paged' Vec in Rust",
      "content_text": "In this post I'll show you some code I wrote for paginating over a Vec collection in Rust. I needed this for a CLI tool I wrote which was meant to display all the vector entries retrieved from a remote server. In most cases, I expected to receive a lot of results, so to display them in a terminal efficiently, I couldn't reasonably render them all. I decided I would page the results.",
      "url": "https://dev.to/kdrakon/creating-a-paged-vec-in-rust-193l",
      "date_published": "2019-05-24T06:36:49+00:00",
      "author": {
        "name": "Sean Policarpio",
        "url": "https://dev.to/kdrakon"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b3ca84bd-3574-43f7-aef3-988cbc6389a4",
      "title": "Update on await syntax",
      "content_text": "In my previous post I said that the lang team would be making our final decision about the syntax of the await operator in the May 23 meeting. That was last Thursday, and we did reach a decision. In brief, we decided to go forward with the preliminary proposal I outlined earlier: a postfix dot syntax, future.await. For more background, in addition the previous post on my blog, you can read this write up about some of the trade offs from April.",
      "url": "https://boats.gitlab.io/blog/post/await-decision-ii/",
      "date_published": "2019-05-28T00:00:00+00:00",
      "author": {
        "name": "boats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ec3d6230-6b29-4459-8a62-c40a8ef08430",
      "title": "Calling a Go Library from Rust: A Case Study with SQIP",
      "content_text": "A brief run-down of how to wrap a Go library in a CGO FFI to enable its functions to be called by Rust.",
      "url": "https://blog.arranfrance.com/post/cgo-sqip-rust/",
      "date_published": "2019-05-27T00:00:00+00:00",
      "author": {
        "name": "Arran France",
        "url": "https://blog.arranfrance.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "53c0e6e9-a95e-4509-b70a-74e945e74e92",
      "title": "Announcing Rust 1.35.0",
      "content_text": "The highlight of this release is the implementation of the FnOnce, FnMut, and Fn closure traits for Box<dyn FnOnce>, Box<dyn FnMut>, and Box<dyn Fn> respectively. Additionally, closures may now be coerced to unsafe function pointers. The dbg! macro introduced in Rust 1.32.0 can now also be called without arguments. Moreover, there were a number of standard library stabilizations. Read on for a few highlights, or see the detailed release notes for additional information.",
      "url": "https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html",
      "date_published": "2019-05-23T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c12cd1dc-8523-4caf-add8-4ba0322a3cb6",
      "title": "Putting the stack back into Stacked Borrows",
      "content_text": "Less than a month ago, I announced Stacked Borrows 2. In particular, I hoped that that version would bring us closer to proper support for two-phase borrows. Turns out I was a bit too optimistic! Last week, @Manishearth asked on Zulip why Miri rejected a certain program, and it turned out that the issue was related to two-phase borrows: in combination with interior mutability, behavior wasn‚Äôt always what we wanted it to be. So, I went back to the drawing board and tried to adjust Stacked Borrows.\n\nIn the end, I decided to give up on ‚Äúproper‚Äù support for two-phase borrows for now, which I explained here. But I also made some tweaks to Stacked Borrows that affect all accesses (not just two-phase borrows), and that‚Äôs what this post is about. I am referring to this as ‚ÄúStacked Borrows 2.1‚Äù.",
      "url": "https://www.ralfj.de/blog/2019/05/21/stacked-borrows-2.1.html",
      "date_published": "2019-05-21T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "bab17ec7-d45f-40fa-963b-10c3085fa7bf",
      "title": "Here's My Type, So Initialize Me Maybe (mem::uninitialized is deprecated)",
      "content_text": "Rust's infamous mem::uninitialized method has been deprecated in today's nightly build. Its replacement, MaybeUninit, has been stabilized. If you are using the former, you should migrate to using the latter as soon as possible (probably when it hits stable in 6 weeks). This was done because it was determined that mem::uninitialized was fundamentally broken, and could not be made to work.",
      "url": "https://gankro.github.io/blah/initialize-me-maybe/",
      "date_published": "2019-05-21T00:00:00+00:00",
      "author": {
        "name": "Alexis Beingessner",
        "url": "https://gankro.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4dfd194e-9cc6-4b75-b2f4-8900d8fdebcd",
      "title": "dtolnay/case-studies: Analysis of various tricky Rust code",
      "content_text": "This repository showcases some examples of tricky Rust code that I have encountered during my years working with a variety of advanced macro libraries in Rust (my own and others').",
      "url": "https://github.com/dtolnay/case-studies",
      "date_published": "2019-05-21T00:00:00+00:00",
      "author": {
        "name": "David Tolnay",
        "url": "https://github.com/dtolnay"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "812b46b0-ec10-45f3-9fc6-4aaa2ae2534e",
      "title": "Polyglot Projects",
      "content_text": "An exploration of how I wrote a C++ binding API for my Rust library.",
      "url": "https://myrrlyn.net/blog/misc/polyglot-projects",
      "date_published": "2019-05-20T00:00:00+00:00",
      "author": {
        "name": "Alexander Payne",
        "url": "https://myrrlyn.net/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "eedb81ef-265f-4dc2-a1d9-559d2d68594d",
      "title": "Rust In Avast",
      "content_text": "When I joined Avast about a year and a half ago, I did it because of two things:  I wanted to work on interesting problems and I wanted to share the Wisdom of Rust with few more people.\n\nOriginally, I was hired because of my experience with writing software for ‚Äûbigger embedded‚Äú (think a home router or Raspberry PI ‚Äí it runs Linux kernel, has a shell, but the file system is a bad joke, your libc has bunch of weird bugs features, you really need to think twice not to waste RAM needlessly and you have to cross-compile), low-level networking knowledge and C++.\n\nBut I don‚Äôt enjoy writing C++ (not speaking about the libc features). And I have other skills I like to practice too. So I would drop an occasional comment about how this or that would be better done in Rust. I‚Äôve done internal courses and workshops about Rust for whoever was interested, in the hope more people would start asking to be allowed to do stuff in Rust and I could participate in such projects.",
      "url": "https://vorner.github.io/2019/05/19/rust-in-avast.html",
      "date_published": "2019-05-19T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "009c05c5-89b2-4519-9133-c46988d45a17",
      "title": "Rust ‚Äì Arrays? Make chains, not concat!",
      "content_text": "f your application needs to iterate over a bunch of items from different sources or arrays, someone with C/C++ background might copy all items into a single vector and iterate this vector. This strategy will cause high costs in terms of allocating heap memory for the consecutive vector buffer. Instead, keep the data where it is, and chain it together to form an iterator over a virtual array. The following Rust code demonstrates the chaining of multiple arrays, forming a single itertator, without any additional allocation of vector buffer in heap. ",
      "url": "https://frehberg.com/2019/05/rust-arrays-make-chains-no-concat/",
      "date_published": "2019-05-16T16:59:10+00:00",
      "author": {
        "name": "Frank Rehberger",
        "url": "https://frehberg.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "64f26c72-e208-4900-90b5-cd1c61ec450b",
      "title": "Evaluating pipelined rustc compilation",
      "content_text": "Recently landed in nightly is the ability for Cargo to execute rustc in a ‚Äúpipelined‚Äù fashion which has the promise of faster build times across the ecosystem. This support is turned off by default and the Cargo team is interested to gather more data and information about this feature, and that‚Äôs where you come in! If you‚Äôre interested in faster compiles, we‚Äôre interested in getting your feedback on this feature!",
      "url": "https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199",
      "date_published": "2019-05-17T16:09:30+00:00",
      "author": {
        "name": "Alex Crichton",
        "url": "https://internals.rust-lang.org/u/alexcrichton"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0369c538-0c12-4b33-9211-fd410b2c38da",
      "title": "Zero Cost Abstractions",
      "content_text": "The idea of a zero cost abstraction is very important to certain programming languages, like Rust and C++, which intend to enable users to write programs with excellent performance profiles with relatively little effort. Since this idea is fundamental to the design of Rust and my work, I want to investigate, for a moment, what exactly a zero cost abstraction even is.",
      "url": "https://boats.gitlab.io/blog/post/zero-cost-abstractions/",
      "date_published": "2019-05-16T00:00:00+00:00",
      "author": {
        "name": "boats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3f754573-640a-4f2c-8c98-bcb1d2727bf9",
      "title": "Cross compiling and statically linking against Rust libraries",
      "content_text": "A few years ago, mainly due to performance reasons, we started rewriting specific back-end services from Python to Rust, with great success. Now, for the sake of ease of development and testing, we are exploring the idea of moving parts of our C/C++ code base to Rust, too.\n\nIn order to do so, instead of re-writing everything in one swoop, we decided to try integrating Rust into our existing code base.\n\nFollowing is a summary of our experiments, and a skeleton for writing a Rust library and calling it from a C/C++ application.",
      "url": "https://medium.com/csis-techblog/cross-compiling-and-statically-linking-against-rust-libraries-2c02ee2c01af",
      "date_published": "2019-05-16T10:29:25.251+00:00",
      "author": {
        "name": "Tiago Seco",
        "url": "https://medium.com/@TiagoSeco"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e710999e-81b7-433e-a2cd-d1968a619567",
      "title": "Rust - 4+ years later",
      "content_text": "A quick tour through my 4+ years with Rust.",
      "url": "https://fnordig.de/2019/05/15/rust-4-years-later/",
      "date_published": "2019-05-15T00:00:00+00:00",
      "author": {
        "name": "Jan-Erik Rediger",
        "url": "https://fnordig.de/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1bda7394-787a-42d1-9733-2b503a611ffb",
      "title": "4 years of Rust",
      "content_text": "On May 15th, 2015, Rust was released to the world! After 5 years of open development (and a couple of years of sketching before that), we finally hit the button on making the attempt to create a new systems programming language a serious effort!",
      "url": "https://blog.rust-lang.org/2019/05/15/4-Years-Of-Rust.html",
      "date_published": "2019-05-15T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0e504089-5eaf-4cb5-a22d-04bb587e54f9",
      "title": "Rust ‚Äì Handling Executables and their Debug-Symbols",
      "content_text": "This post is about compiling Rust-code, the executables, the handling of the corresponding debug symbols and core-files. It highlights the importance of debug-symbols for debugging and how to split them of the binary before shipping to customer.",
      "url": "https://frehberg.com/2019/05/rust-handling-executables-and-their-debug-symbols/",
      "date_published": "2019-05-14T22:24:55+00:00",
      "author": {
        "name": "Frank Rehberger",
        "url": "https://frehberg.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6715c2d9-9049-40c2-bc29-cca235bde059",
      "title": "Creating C/C++ APIs in Rust",
      "content_text": "Rust is an amazing language with an even better ecosystem. Many design decisions of Rust make it a great fit to add new functionality to existing C/C++ systems or gradually replace parts of those systems!\n\nWhen I tried to make a C++ API for a Rust library, I found that binding from C/C++ to Rust is better documented and has a smoother experience than binding from Rust to C/C++.",
      "url": "https://karroffel.gitlab.io/post/2019-05-15-rust/",
      "date_published": "2019-05-15T00:00:00+00:00",
      "author": {
        "name": "Thomas Herzog",
        "url": "https://karroffel.gitlab.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "294ff4dd-a217-4d15-a378-a2ef10f6aae8",
      "title": "Announcing Rust 1.34.2",
      "content_text": "The Error::type_id method was recently stabilized as part of Rust 1.34.0. This point release destabilizes it, preventing any code on the stable and beta channels to implement or use it, awaiting future plans that will be discussed in issue #60784.",
      "url": "https://blog.rust-lang.org/2019/05/14/Rust-1.34.2.html",
      "date_published": "2019-05-14T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a0770f01-6980-48bd-bd23-cdee98b5c16a",
      "title": "Optional parameters in Rust",
      "content_text": "Many languages feature ‚Äúoptional‚Äù parameters to function arguments: if you provide a value, it will be used, but if you don‚Äôt, a default value will be used instead. How to do that in Rust? Well, in Rust you have to provide all the parameters a function requests. You can, however, use ‚ÄúOption‚Äùs to do two things: make their usage not mandatory, provide a default value.",
      "url": "http://blog.keiruaprod.fr/2019/05/11/optional-parameters-in-rust/",
      "date_published": "2019-05-11T19:16:47+00:00",
      "author": {
        "name": "Clement Keirua",
        "url": "http://www.keiruaprod.fr/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6c334d13-f697-4774-8820-3665687ec7a4",
      "title": "Some Thoughts on Rust's Async/Await Debate",
      "content_text": "This post will be an extension of the debates found in the Rust forums, specifically here and here. A lot is being said in those threads and there's a certain amount of duplicated posts that are drowning out potentially valuable information and perspectives. I've written several comments in those debates",
      "url": "https://whitfin.io/some-thoughts-on-rusts-async-await-proposals/",
      "date_published": "2019-05-09T18:41:38+00:00",
      "author": {
        "name": "Isaac Whitfield",
        "url": "https://whitfin.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7d5b4554-d4eb-45b4-9d90-a562f36a4f88",
      "title": "Recursive iterators in Rust",
      "content_text": "I‚Äôve been looking for this blog post everywhere, but it doesn‚Äôt exist, so I guess it‚Äôs my turn to write about Some Fun with Rust. Let‚Äôs say you have a recursive, acyclic data structure. Now let‚Äôs say you want to iterate over the values of the root node and all its children, recursively, so that you get the sequence [1, 2, 3, 4, 5, 6, 7].",
      "url": "https://amos.me/blog/2019/recursive-iterators-rust/",
      "date_published": "2019-05-08T00:00:00+00:00",
      "author": {
        "name": "amos",
        "url": "https://amos.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "577c30e3-f6b8-4c6f-98a5-020962df3df3",
      "title": "Rust Patterns: Enums Instead Of Booleans",
      "content_text": "As I‚Äôve been writing Rust code more, I‚Äôve noticed how few boolean types I‚Äôm using in my code. Instead, I‚Äôm using Rust‚Äôs powerful enums in 90% of cases where I would have reached for a boolean in another language.",
      "url": "http://blakesmith.me/2019/05/07/rust-patterns-enums-instead-of-booleans.html",
      "date_published": "2019-05-07T00:00:00+00:00",
      "author": {
        "name": "Blake Smith",
        "url": "http://blakesmith.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "10bffdde-a5d9-4066-971b-0c155ba8ce2d",
      "title": "How and why await should be a method afterall",
      "content_text": "Explains in which way the planned `await` resembles a function call and provides reasoning how apparent contradictions in this model can be dispelled.",
      "url": "https://www.hardmo.de/article/2019-05-06-await-method-afterall.md",
      "date_published": "2019-05-06T00:00:00+00:00",
      "author": {
        "name": "Andreas Molzer",
        "url": "https://www.hardmo.de/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "35a812e7-75c8-4ffe-98b0-0dee390a5a51",
      "title": "Implementing a Interpreted Language in Rust Part 1",
      "content_text": "We live in a great era for language design. Within the last 5-10 years, several innovative languages have come out and won over the hearts of many developers with a newfound focus on memory safety (Rust), runtime interoperability (JVM: Kotlin, V8: Typescript, BEAM: Elixir), first class concurrency (Go, Pony), dependent types (Idris), Language oriented Programming (Racket) and many more inspired features. In this spirit, I have decided to throw my hat into the ring as well and create my own language for fun.",
      "url": "http://nedellis.com/2019/05/08/esta_1/",
      "date_published": "2019-05-08T00:00:00+00:00",
      "author": {
        "name": "Ned Ellis",
        "url": "http://nedellis.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "89a6ce72-79b9-477d-a5e5-bd1e6407c3f5",
      "title": "World's First Private Cargo Registry",
      "content_text": "If you're interested in the possibilities that hosting your own private or internal crates brings, then this is incredibly good news for you: Cloudsmith are proud to provide the World's first commercially available public and private Cargo registry hosting, with ultra-fast and secure delivery of your Rust packages, alongside all of the usual Enterprise-grade features that we provide.",
      "url": "https://blog.cloudsmith.io/2019/05/01/worlds-first-private-cargo-registry/",
      "date_published": "2019-05-01T12:06:47+00:00",
      "author": {
        "name": "Patrick Carey",
        "url": "https://blog.cloudsmith.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b7f70811-6fa2-4bab-b9e2-be4107ec221b",
      "title": "A final proposal for await syntax",
      "content_text": "This is an announcement regarding the resolution of the syntax for the await operator in Rust. This is one of the last major unresolved questions blocking the stabilization of the async/await feature, a feature which will enable many more people to write non-blocking network services in Rust. This post contains information about the timeline for the final decision, a proposal from the language team which is the most likely syntax to be adopted, and the justification for this decision.",
      "url": "https://boats.gitlab.io/blog/post/await-decision/",
      "date_published": "2019-05-06T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e6de297c-e3b3-40ab-af40-922f95e71444",
      "title": "Rust and glibc version",
      "content_text": "The rust compiler dynamically link the executable against the glibc in the system. Hence if you compile your software against a newer version of glibc (say 2.19) that the one available where you run the executable (say in the host is available 2.14) it may not work.\n\nThe cleanest one is to don‚Äôt dynamically link against glib, indeed is possible to compile a rust binary statically linking musl, to do so is sufficient to compile against the correct target, usually using cargo build --target x86_64-unknown-linux-musl.\n\nAnother possibility is to compile in an environment with an ‚Äúold-enough‚Äù version of glibc, this is usually done using docker and indeed there is a whole project that aim to create a set ‚Äúzero setup‚Äù docker images. ",
      "url": "http://redbeardlab.com/2019/05/07/rust-and-glibc-version/",
      "date_published": "2019-05-07T16:33:59+00:00",
      "author": {
        "name": "Simone Mosciatti",
        "url": "http://redbeardlab.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "433737c5-300e-4095-82c3-2ca05e51b029",
      "title": "Compile-time coprocessor codegen, with Rust macros",
      "content_text": "Motivation: The Nintendo 3DS uses an ARM standard peripheral, the CoreLink DMA engine, for copying memory among DRAM and memory-mapped peripherals.\n\nThis DMA engine, unlike most other IO devices on the 3DS, actually has its own instruction set where the CPU merely uploads a stream of instructions for the peripheral to execute (other examples of this, on the 3DS, are the DSP audio processor and the PICA graphics chip).\n\nI‚Äôd like to compile and run DMA instructions in Rust, in a hopefully ergonomic manner, without needing to use any dynamic memory allocation. This imposes a particular constraint that I need to know the number of instruction bytes at compile time so I can use an appropriately-sized array.",
      "url": "https://guiand.xyz/blog-posts/macro-assembly-codegen.html",
      "date_published": "2019-05-03T00:00:00+00:00",
      "author": {
        "name": "Gui Andrade",
        "url": "https://guiand.xyz/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0bc705c5-726c-4967-84cc-264f7a6338df",
      "title": "How XV uses Panics",
      "content_text": "XV is a terminal hex viewer that I am working on. It is the first ‚Äúreal‚Äù Rust project that I am working on, coming from a Java background.\n\nJava has exceptions. Both checked exceptions, identified by having the Exception class as a parent class, and unchecked exceptions, which have RuntimeException as a parent class.\n\nRust does not have exceptions. Rust has panics, which, depending on build-time configurations, are either catch-able when they unwind the stack, or only produce a backtrace, or just immediately aborts the process. This is controlled by the ‚Äúpanic‚Äù setting in the ‚Äúprofile‚Äù sections of your Cargo.toml file.",
      "url": "https://medium.com/@chrisvest/how-xv-uses-panics-ba22bd6152a5",
      "date_published": "2019-05-02T16:26:24.329+00:00",
      "author": {
        "name": "Chris Vest",
        "url": "https://medium.com/@chrisvest"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f759c500-da13-4765-81f1-dd59918b09d1",
      "title": "Extending Python with Rust",
      "content_text": "Python is a great programming language but sometimes it can be a bit of slowcoach when it comes to performing certain tasks. That‚Äôs why developers have been building C/C++ extensions and integrating them with Python to speed up the performance. However, writing these extensions is a bit difficult because these low-level languages are not type-safe, so doesn‚Äôt guarantee a defined behavior. This tends to introduce bugs with respect to memory management. Rust ensures memory safety and hence can easily prevent these kinds of bugs.",
      "url": "https://medium.com/@p_chhetri/extending-python-with-rust-84e9299d34c1",
      "date_published": "2019-05-01T17:37:44.829+00:00",
      "author": {
        "name": "Pradeep Chhetri",
        "url": "https://medium.com/@p_chhetri"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "facd2bd5-bb49-449e-b8d9-c9f353545c32",
      "title": "Rustacean Hat Pattern",
      "content_text": "Making a Ferris the Rustacean hat.",
      "url": "http://edunham.net/2019/04/06/rustacean_hat_pattern.html",
      "date_published": "2019-04-06T00:00:00+00:00",
      "author": {
        "name": "E. Dunham",
        "url": "http://edunham.net/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4ce6618d-d773-4260-85c6-639aaf6ec7fc",
      "title": "Risp (Lisp (in (Rust)))",
      "content_text": "Many years ago, Peter Norvig wrote a beautiful article about creating a lisp interpreter in Python. It‚Äôs the most fun tutorial I‚Äôve seen, not just because it teaches you about my favorite language family (Lisp), but because it cuts through to the essence of interpreters, is fun to follow and quick to finish.\n\nRecently, I had some time and wanted to learn Rust. It‚Äôs a beautiful systems language, and I‚Äôve seen some great work come out from those who adopt it. I thought, what better way to learn Rust, than to create a lisp interpreter in it?\n\nHence, Risp‚Ää‚Äî‚Ääa lisp in rust‚Ää‚Äî‚Ääwas born. In this essay you and I will follow along with Norvig‚Äôs Lispy, but instead of Python, we‚Äôll do it in Rust üôÇ.",
      "url": "https://m.stopa.io/risp-lisp-in-rust-90a0dad5b116",
      "date_published": "2019-05-02T17:44:37.154+00:00",
      "author": {
        "name": "Stepan Parunashvili",
        "url": "https://m.stopa.io/@stepan"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ae1f3c27-6a45-4b49-ac3c-e081adfe52c9",
      "title": "Cargo in 2019",
      "content_text": "I recently published a post detailing a vision for the next few years (hah! Not so recently now, this took a lot longer than expected). Here I'll get into more detail about 2019.",
      "url": "https://www.ncameron.org/blog/cargo-in-2019/",
      "date_published": "2019-05-01T22:37:35+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "37ea8a58-93a1-4e5c-b125-d98a250e601c",
      "title": "Chess vocabulary in Rust",
      "content_text": "Recently I've been using Rust to build a server for the new 7-piece Syzygy endgame tablebases. Using Rust was quite enjoyable and I plan to use it for many future projects. This series is intended to order and share my thoughts, and as a primer to discuss some open questions I have.",
      "url": "https://backscattering.de/chess/vocabulary/",
      "date_published": "2019-04-14T00:00:00+00:00",
      "author": {
        "name": "Niklas Fiekas",
        "url": "https://backscattering.de/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f2a55dcd-b163-42ac-8660-311e1cc384d0",
      "title": "Stacked Borrows 2",
      "content_text": "Recently, I have significantly updated Stacked Borrows in order to fix some issues with the handling of shared references that were uncovered in the previous version. In this post, I will describe what the new version looks like and how it differs from Stacked Borrows 1. I assume some familiarity with the prior version and will not explain everything from scratch.",
      "url": "https://www.ralfj.de/blog/2019/04/30/stacked-borrows-2.html",
      "date_published": "2019-04-30T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "094e167c-f023-449e-9976-247d314fd269",
      "title": "My Key Learnings after 30,000 LOC in Rust",
      "content_text": "For me, Rust takes a stroll over the memory lane above and picks and drives home the best experiences from all those languages‚Ää‚Äî‚Ääwhich is a",
      "url": "https://medium.com/@jondot/my-key-learnings-after-30-000-loc-in-rust-a553e6403c19",
      "date_published": "2019-04-29T17:57:26.520+00:00",
      "author": {
        "name": "Dotan Nahum",
        "url": "https://medium.com/@jondot"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b7836b84-068e-4db1-9c0c-2dea0652626d",
      "title": "Building a pub/sub server with Sonr (part 2)",
      "content_text": "This is the second part in a two part series on writing a pub/sub server in Rust using Sonr. We will jump straight in building the publisher. This is the biggest piece of code so far in this project.",
      "url": "https://hagsteel.com/posts/building-a-pub-sub-with-sonr-part-2/",
      "date_published": "2019-04-11T01:00:00+01:00",
      "author": {
        "name": "Jonas",
        "url": "https://hagsteel.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "28c59573-37da-46b6-92c0-f6fbb4a5e613",
      "title": "Creating cross-platform Rust terminal apps",
      "content_text": "I‚Äôve been wanting to play around with the cool spinning Pikachu demo everyone was talking about. Sadly, it used termion to do its magic, which meant that unfortunately it wouldn‚Äôt work for me. Termion has been a boon for Rust, with lots of folks using it to create terminal applications. Unfortunately, as a Windows user, I know there‚Äôs a good chance that if the crate depends on termion that‚Äôs the end of the line for me, as termion apps just don‚Äôt work in Windows. Surely, I thought, there must be a better way, but I never managed to find one. Enter crossterm.",
      "url": "http://www.jonathanturner.org/2019/04/porting-the-pikachu.html",
      "date_published": "2019-04-27T00:00:00+00:00",
      "author": {
        "name": "Jonathan Turner",
        "url": "http://www.jonathanturner.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9197a635-8114-4c33-ae94-226af2147624",
      "title": "How to Write Better Compilation Error Message In Rust",
      "content_text": "While exploring Rust's standard libraries, I came across a beautiful feature of Rust - compile_error.",
      "url": "https://blog.knoldus.com/how-to-write-better-compilation-error-message-in-rust/",
      "date_published": "2019-03-31T14:08:04+00:00",
      "author": {
        "name": "Ayush Mishra",
        "url": "https://blog.knoldus.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8c6f2335-8fba-4cb5-9da1-2baba7f59159",
      "title": "for await loops (Part I)",
      "content_text": "The biggest unresolved question regarding the async/await syntax is the final syntax for the await operator. There‚Äôs been an enormous amount of discussion on this question so far; a summary of the present status of that discussion and the positions within the language team is coming soon. Right now I want to separately focus on one question which impacts that decision but hasn‚Äôt been considered very much yet: for loops which process streams.",
      "url": "https://boats.gitlab.io/blog/post/for-await-i/",
      "date_published": "2019-04-15T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "91b5c36e-a3f8-4cbd-ad0e-cd796ee6ea24",
      "title": "How Rust Solved Dependency Hell",
      "content_text": "Every once in a while I'll be involved in a conversation about dependency management and versions, often at work, in which the subject of ‚Äúdependency hell‚Äù will come up. If you're not familiar with the term, then I encourage you to look it up. A brief summary might be: \"The frustration that comes from dealing with application dependency versions and dependency conflicts\". With that in mind, let's get a little technical about dependency resolution.",
      "url": "https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell",
      "date_published": "2019-04-24T05:00:00+00:00",
      "author": {
        "name": "Stephen Coakley",
        "url": "https://stephencoakley.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ce78473f-6f58-428d-ba3e-cbbbfc778345",
      "title": "Announcing Rust 1.34.1",
      "content_text": "This patch release fixes two false positives and a panic when checking macros in Clippy. Clippy is a tool which provides a collection of lints to catch common mistakes and improve your Rust code.",
      "url": "https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html",
      "date_published": "2019-04-25T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b35d346f-7773-44c5-8db5-4cbe95fb3749",
      "title": "More than coders",
      "content_text": "Lately, the compiler team has been changing up the way that we work. Our goal is to make it easier for people to track what we are doing and ‚Äì hopefully ‚Äì get involved. This is an ongoing effort, but one thing that has become clear immediately is this: the compiler team needs more than coders.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2019/04/15/more-than-coders/",
      "date_published": "2019-04-15T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8fbc326e-e356-480c-8708-c6b4d8d66719",
      "title": "Things I Enjoy in Rust: Error Handling",
      "content_text": "I‚Äôve already talked about how I like how enums are used in Rust. They make it easy to express multiple states and the state‚Äôs related data. One place this is excellently utilized is error handling.",
      "url": "https://blog.jonstodle.com/things-i-enjoy-in-rust-error-handling/",
      "date_published": "2019-04-21T12:00:00+02:00",
      "author": {
        "name": "Jon Grythe St√∏dle",
        "url": "https://blog.jonstodle.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c66e7e63-ea76-4d35-a15b-0bf56a905b07",
      "title": "Rust's 2019 roadmap",
      "content_text": "Each year the Rust community comes together to set out a roadmap. This year, in addition to the survey, we put out a call for blog posts in December, which resulted in 73 blog posts written over the span of a few weeks. The end result is the recently-merged 2019 roadmap RFC. To get all of the details, please give it a read, but this post lays out some of the highlights.",
      "url": "https://blog.rust-lang.org/2019/04/23/roadmap.html",
      "date_published": "2019-04-23T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "675975c8-b21a-4d87-8ac3-7e8c74fd8897",
      "title": "Things I Enjoy in Rust: Enums",
      "content_text": "I‚Äôve been diving into Rust for the last couple of months, after my colleague started talking about it. I‚Äôve been wanting to learn a lower level language, but C++ or something of the like have always seemed too daunting for me to even start.\n\nI‚Äôd heard of Rust before, and great things too, but hadn‚Äôt set apart time to look into it. I finally took the dive. And boy, am I glad I did.\n\nA lot of people talk about the borrowing system of Rust, or how fast it, or the strict type system. All of which are great things, but it‚Äôs not what I‚Äôm going to write about here. I‚Äôm excited about enums.",
      "url": "https://blog.jonstodle.com/things-i-enjoy-in-rust-enums/",
      "date_published": "2019-04-18T18:00:00+02:00",
      "author": {
        "name": "Jon Grythe St√∏dle",
        "url": "https://blog.jonstodle.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0cc3f8b6-7cd9-423f-96f2-569b660e2bf3",
      "title": "Lessons moving from iOS delegates to Rust async",
      "content_text": "The majority of my async programming experience is on iOS and let me tell you, life is good. You can easily dispatch work to background threads. You can bring work back to the main thread. You can mark your classes as delegates and when you need to handle some event the OS will use a magic pre-existing thread pool to invoke your method and you can do whatever you like. It works perfectly almost all the time, except for when it doesn‚Äôt because of race conditions or it crashes due to concurrency. Life is good.\n\nRust is less tolerant about the crashing part. While I agree that crashing is bad in principle, avoiding it has significant ramifications for how you can write async code at all. Recently I‚Äôve been finding out what the differences are. Obviously this means I‚Äôm more of a noob than an expert, but I‚Äôm currently in a good position to point out what the confusing parts are and what the Rust solutions seem to be. (But I‚Äôm a noob so take it with a grain of salt.)",
      "url": "https://thomask.sdf.org/blog/2019/04/19/lessons-moving-from-ios-delegates-to-rust-async.html",
      "date_published": "2019-04-19T19:30:00+10:00",
      "author": {
        "name": "Thomas Karpiniec",
        "url": "https://thomask.sdf.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "bda9c409-db67-4283-aadc-ffb54c3ad00d",
      "title": "Elements of Rust: style and philosophy",
      "content_text": "A collection of software engineering techniques for effectively expressing intent with Rust.",
      "url": "https://github.com/ferrous-systems/elements-of-rust",
      "date_published": "2019-04-22T00:00:00+00:00",
      "author": {
        "name": "Ferrous Systems ",
        "url": "https://github.com/ferrous-systems"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "036c9563-3d69-4cf8-a59a-718976fded92",
      "title": "Generic returns in Rust",
      "content_text": "After casting around for a new platform to learn recently, I‚Äôve decided to dive into Rust. Being mostly familiar with untyped languages like Ruby and JavaScript, it‚Äôs interesting to learn a statically typed language and see how it changes how one writes programs. There‚Äôs a common misconception amongst dynamic typing fans that static typing means you write the same programs, they‚Äôre just more verbose and come with more restrictions. And while there is certainly a cost to only being allowed to write type-safe programs, a good type system actually lets you write programs you cannot write in dynamic languages. In Rust, generic return values are a good example of this.",
      "url": "https://blog.jcoglan.com/2019/04/22/generic-returns-in-rust/",
      "date_published": "2019-04-22T00:00:00+00:00",
      "author": {
        "name": "James Coglan",
        "url": "https://blog.jcoglan.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "da05eb25-52b2-48f6-9008-944a9a95ccaa",
      "title": "An interview with the creator of Gleam: an ML like language for the Erlang VM with a compiler written in Rust",
      "content_text": "An interesting thing about Gleam is that its compiler is written in Rust. I think that Rust is a sort of ML + C language. I like C since the developer is at the driver seat driving with manual transmission. I can‚Äôt explain very well but I have always seen C as a simple and powerful language but I have always disliked C++. Knowing that I like ML and C you might understand why I find Rust an interesting language. To sum up we (me and Juan Bono) decided to do this interview with Louis Pilfold not only because of what it is, but also because it is implemented in Rust.",
      "url": "https://notamonadtutorial.com/an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler-e94775f60dc7",
      "date_published": "2019-04-01T16:30:35.129+00:00",
      "author": {
        "name": "unbalancedparentheses",
        "url": "https://notamonadtutorial.com/@unbalancedparen"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a085423c-ec98-4fff-ba66-7c23926175d9",
      "title": "Learning Parser Combinators With Rust",
      "content_text": "This article teaches the fundamentals of parser combinators to people who are already Rust programmers. It assumes no other knowledge, and will explain everything that isn't directly related to Rust, as well as a few of the more unexpected aspects of using Rust for this purpose. It will not teach you Rust if you don't already know it, and, if so, it probably also won't teach you parser combinators very well.",
      "url": "https://bodil.lol/parser-combinators/",
      "date_published": "2019-04-18T00:00:00+00:00",
      "author": {
        "name": "Bodil Stokke",
        "url": "https://bodil.lol/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "77c8e0ed-ccb6-4f29-8ab7-1e8c3cd5d39d",
      "title": "Rust Associated Type",
      "content_text": "Associated Types in Rust are similar to Generic Types; however, Associated Types limit the types of things a user can do, which consequently facilitates code management. Among the Generic Types of traits, types that depend on the type of trait implementation can be expressed by using the Associated Type syntax. By comparing the Associated and Generic Types, you can get a better understanding of Associated Types.",
      "url": "https://medium.com/codechain/rust-associated-type-b0193c22eacd",
      "date_published": "2019-04-16T10:08:09.783+00:00",
      "author": {
        "name": "Park Juhyung",
        "url": "https://medium.com/@majecty"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8770e0f9-eca2-4f58-b2f4-7761dbcf81bb",
      "title": "Rust: beyond the typechecker",
      "content_text": "This post will be different from the previous ones, since I‚Äôm going to present some of the early results of my work as a PhD student at the Prosecco team in ...",
      "url": "https://blog.merigoux.ovh/en/2019/04/16/verifying-rust.html",
      "date_published": "2019-04-16T00:00:00+00:00",
      "author": {
        "name": "Denis Merigoux",
        "url": "https://blog.merigoux.ovh/en/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "524e6489-33da-4635-977c-9d86e839d185",
      "title": "Proper Notation for Scalar Multiplication in Rust: Dispatching on the Right-Hand Side of Operators and Rusts's Orphan Rule",
      "content_text": "The scalar multiplication in a vector space is written kv in math, where k is a scalar value (e.g. a number) and v is a vector. It would be nice to write k * v in programming languages, to stay close to the familiar notation. Object-oriented languages typically only support calling methods on the first argument. But the scalar normally doesn't know about vectors, so it can't easily do that.",
      "url": "https://www.jstuber.net/2019/04/17/scalar-multiplication-in-rust/",
      "date_published": "2019-04-17T00:00:00+00:00",
      "author": {
        "name": "J√ºrgen Stuber",
        "url": "https://www.jstuber.net/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d171d946-7117-4e2a-bfae-0a4089cdfa9d",
      "title": "Complex data types and the Rust FFI",
      "content_text": "There are a few good resources on the internet about using the Rust FFI to expose functions written in Rust to other languages. However, I found little information about passing data types between languages. To help remedy this situation, I describe in this post a simple Rust library that I wrote to explore how to pass complex data types from Rust to C.",
      "url": "http://kmdouglass.github.io/posts/complex-data-types-and-the-rust-ffi/",
      "date_published": "2019-04-04T17:51:55+00:00",
      "author": {
        "name": "Kyle M. Douglass",
        "url": "http://kmdouglass.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8042dc34-344d-452f-818c-bebe0f6cf573",
      "title": "Building a pub/sub server with Sonr (part 1)",
      "content_text": "This is the first part in a two part series where we explore Sonr by writing a pubsub server in Rust using Sonr.",
      "url": "https://hagsteel.com/posts/building-a-pub-sub-with-sonr-part-1/",
      "date_published": "2019-04-10T00:00:00+01:00",
      "author": {
        "name": "Jonas",
        "url": "https://hagsteel.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ad1e9e94-37b0-4328-93d5-216cb58cd905",
      "title": "Using Rust Generics to Enforce DB Record State",
      "content_text": "I‚Äôm currently working on a (private in 2019, public in july 2019) project which is a NoSQL database writting in Rust. To help us manage the correctness and lifecycle of database entries, I have been using advice from the Rust Embedded Group‚Äôs Book. As I have mentioned in the past, state machines are a great way to design code, so let‚Äôs plot out the state machine we have for Entries",
      "url": "https://fy.blackhats.net.au/blog/html/2019/04/13/using_rust_generics_to_enforce_db_record_state.html",
      "date_published": "2019-04-13T00:00:00+00:00",
      "author": {
        "name": "Firstyear",
        "url": "https://fy.blackhats.net.au/blog/html/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c652e06d-95e4-4da0-8ce8-a94c007587d7",
      "title": "Announcing Rust 1.34.0",
      "content_text": "The largest feature in this release is the introduction of alternative cargo registries. The release also includes support for ? in documentation tests, some improvements for #[attribute(..)]s, as well as the stabilization of TryFrom. Read on for a few highlights, or see the detailed release notes for additional information.",
      "url": "https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html",
      "date_published": "2019-04-11T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c16ea768-9518-4a40-b51d-9c5e978994a2",
      "title": "Neat new feature in Rust: iter::from_fn",
      "content_text": "Recently Rust has introduced a couple of new features, and the one that caught my eye in particular was std::iter::from_fn, which let‚Äôs you make an iterator from a function, which is most of what that macro was trying to do, so I thought I would try to convert the various places I was using the macro to use the new function instead‚Ä¶",
      "url": "https://weblog.latte.ca/blake/tech/rust/makingiterators.html",
      "date_published": "2019-04-13T20:49:00+00:00",
      "author": {
        "name": "Blake Winton",
        "url": "https://weblog.latte.ca/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "30a32647-13d1-4d87-89c0-804ef7d456e6",
      "title": "Tricks In Arc Swap",
      "content_text": "This is a continuation of the Making Arc more atomic post. In short, ArcSwap is a place where you can atomically store and load an Arc, similar to RwLock<Arc<T>> but without the locking. It‚Äôs a good tool if you have some data that is very frequently read but infrequently modified, like configuration or an in-memory database that answers millions of queries per second, but is replaced only every 5 minutes. The canonical example for this is routing tables ‚Äí you want to read them with every passing packet, but you change them only when routing changes.",
      "url": "https://vorner.github.io/2019/04/06/tricks-in-arc-swap.html",
      "date_published": "2019-04-06T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "afbe8437-4dca-40c1-b6ab-034fbd57c9cd",
      "title": "Mysteriously Low Hanging Fruit: A Big Improvement To LLD For Rust Debug Builds",
      "content_text": "LLD is generally much faster than the GNU ld.bfd and ld.gold linkers, so you would think it has been pretty well optimised. You might then be surprised to discover that a 36-line patch dramatically speeds up linking of Rust debug builds, while also shrinking the generated binaries dramatically, both in simple examples and large real-world projects.",
      "url": "https://robert.ocallahan.org/2019/04/mysteriously-low-hanging-fruit-big.html",
      "date_published": "2019-04-11T00:00:00+00:00",
      "author": {
        "name": "Robert O'Callahan",
        "url": "https://robert.ocallahan.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "54d19ed4-0cb7-4ab9-939e-5afcdf8b0ca5",
      "title": "How to Mock Time in Rust Tests and Cargo Gotchas We Met",
      "content_text": "I'm working in a team developing a big Rust project recently. The project has some features depending on time. We, the developers, want to be able to mock the time in test. In this post, I'll talk about the problems we have met, mostly related to Cargo.",
      "url": "https://blog.iany.me/2019/03/how-to-mock-time-in-rust-tests-and-cargo-gotchas-we-met",
      "date_published": "2019-03-31T00:00:00+00:00",
      "author": {
        "name": "Ian Yang",
        "url": "https://blog.iany.me"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f0be7972-25a7-4ff9-af00-904780465c8f",
      "title": "A Story of Rust",
      "content_text": "Introducing Rust in an Enterprise Environment...",
      "url": "https://jobs.zalando.com/tech/blog/story-rust/",
      "date_published": "2019-03-28T00:00:00+00:00",
      "author": {
        "name": "Christian Douven",
        "url": "https://jobs.zalando.com/tech/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "63c81ff0-ee39-437f-a299-70173f639777",
      "title": "Javascript evaluator part 2: Parser and Basic evaluator",
      "content_text": "This is the second part of writing Javascript evaluator series. I‚Äôm going to talk about my project developing Javascript evaluator in Rust. This post is going to briefly introduce Parsing that‚Äôs build on top of the results from Lexer in the first post. Then I will cover elements of evaluation of abstract syntax tree (AST).",
      "url": "https://medium.com/@retep007/javascript-evaluator-part-2-parser-and-basic-evaluator-d306ff1aec83",
      "date_published": "2019-04-08T06:39:05.543+00:00",
      "author": {
        "name": "Peter Hrvola",
        "url": "https://medium.com/@retep007"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "749e48bb-50e5-4e7e-8e17-9dd73e1776f2",
      "title": "A Love Letter to Rust Macros",
      "content_text": "It‚Äôs no secret to people who know me that I‚Äôm a huge fan of the Rust programming language. I could talk for hours about the brilliance of the ownership system, my irrational longing for natively compiled languages without garbage collection, or the welcoming community that finally moved me to take a more active part in open source projects. But for a start, I just want to highlight one of my favourite features: Macros.",
      "url": "https://happens.lol/posts/a-love-letter-to-rust-macros/",
      "date_published": "2019-04-09T00:00:00+00:00",
      "author": {
        "name": "Hilmar Wiegand",
        "url": "https://happens.lol/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0ee4dffd-3f5f-4c26-9a66-5a2c94db3ace",
      "title": "Javascript evaluator part 1: Lexing",
      "content_text": "In this post I will describe my latest findings from writing my own Javascript lexer in Rust-lang. I will start by briefly describing what lexing is. Then, I will continue explaining how to implement state machines in Rust-lang. Next, I talk about how to use state machines for Javascript lexing. Last but not least, I cover further performance optimizations of my lexer.",
      "url": "https://medium.com/@retep007/javascript-lexing-for-high-performance-f9a800ec930d",
      "date_published": "2019-04-02T06:08:32.573+00:00",
      "author": {
        "name": "Peter Hrvola",
        "url": "https://medium.com/@retep007"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7e90b841-ce0c-47f1-b6ab-420aa7d7bb35",
      "title": "Our journey from nightly to stable Rust",
      "content_text": "When we shipped Seq 5.0 back in November, our new storage engine was compiled against Rust's unstable nightly channel. As of Seq 5.1, we can instead use the supported stable channel. That feels like a bit of a milestone so I'd like to share a few details about our journey from nightly to stable, and celebrate the progress the community has made on the language, libraries, and tooling over the last twelve months that made that journey painless for us.",
      "url": "https://blog.datalust.co/our-journey-from-rust-nightly-to-stable/",
      "date_published": "2019-04-04T23:44:23+00:00",
      "author": {
        "name": "Ashley Mannix",
        "url": "https://kodraus.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3046fc78-93d2-4298-a8ae-134f2fbd29b9",
      "title": "Crossing the Rust FFI frontier with Protocol Buffers",
      "content_text": "The Firefox Application Services engineering team made the decision to use Rust to build cross-platform components for Firefox Sync, powering Firefox Accounts across many devices. They are implementing core business logic using Rust and wrapping it in a thin platform-native layer, such as Kotlin for Android and Swift for iOS.",
      "url": "https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/",
      "date_published": "2019-04-02T14:42:47+00:00",
      "author": {
        "name": "Edouard Oger",
        "url": "https://hacks.mozilla.org/author/eogermozilla-com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5b355e5c-bc78-4134-91a2-c383b350d5f8",
      "title": "Mocking in Rust with conditional compilation",
      "content_text": "When writing automated unit tests for your application you will probably need to use mocks at some point. Classical object-oriented programming languages such as PHP solve this with reflection where mock object types are created during test runtime. The code under test expects a certain interface or class and the test code passes mock objects that implement the interface or are a subclass.",
      "url": "https://klausi.github.io/rustnish/2019/03/31/mocking-in-rust-with-conditional-compilation.html",
      "date_published": "2019-03-31T00:00:00+00:00",
      "author": {
        "name": "klausi",
        "url": "https://klausi.github.io/rustnish/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "865d719c-3067-49d0-8bfc-361bfe91d257",
      "title": "Summary: What are the Allocation Rules?",
      "content_text": "While there‚Äôs a lot of interesting detail captured in this series, it‚Äôs often helpful to have a document that answers some ‚Äúyes/no‚Äù questions. You may not care about what an Iterator looks like in assembly, you just need to know whether it allocates an object on the heap or not. And while Rust will prioritize the fastest behavior it can, here are the rules for each memory type",
      "url": "https://speice.io/2019/02/summary.html",
      "date_published": "2019-02-09T00:00:00-05:00",
      "author": {
        "name": "Bradlee Speice",
        "url": "https://speice.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4984adf8-b660-4433-a888-8bd84d669dc0",
      "title": "Compiler Optimizations: What It's Done Lately",
      "content_text": "Throughout the series so far, we‚Äôve put a handicap on the code. In the name of consistent and understandable results, we‚Äôve asked the compiler to pretty please leave the training wheels on. Now is the time where we throw out all the rules and take off the kid gloves. As it turns out, both the Rust compiler and the LLVM optimizers are incredibly sophisticated, and we‚Äôll step back and let them do their job.\n\nSimilar to ‚ÄúWhat Has My Compiler Done For Me Lately?‚Äù, we‚Äôre focusing on interesting things the Rust language (and LLVM!) can do with memory management.",
      "url": "https://speice.io/2019/02/compiler-optimizations.html",
      "date_published": "2019-02-08T00:00:00-05:00",
      "author": {
        "name": "Bradlee Speice",
        "url": "https://speice.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ff71674c-714c-4d6d-adde-bca7a03d697e",
      "title": "Miri available as rustup component",
      "content_text": "Running your unsafe code test suite in Miri has just gotten even easier: Miri is now available as a rustup component!",
      "url": "https://www.ralfj.de/blog/2019/03/26/miri-as-rustup-component.html",
      "date_published": "2019-03-26T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ee2c7f86-323c-49fe-a707-afc505088445",
      "title": "Variance in Rust: An intuitive explanation",
      "content_text": "Recently I made a presentation about subtyping and variance in Rust for our local Vancouver Rust meetup, but I still think intuition was rather lost in the formalism, so here‚Äôs my shot at explaining it as intuitively as I can.",
      "url": "https://ehsanmkermani.com/2019/03/16/variance-in-rust-an-intuitive-explanation/",
      "date_published": "2019-03-17T03:24:05+00:00",
      "author": {
        "name": "Ehsan M. Kermani",
        "url": "https://ehsanmkermani.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "03a41715-2772-48f5-8a75-bd0d4d1d04c7",
      "title": "Understanding Futures In Rust - Part 1",
      "content_text": "Futures make async programming in Rust easy and readable. Learn how to use futures by building them from scratch.",
      "url": "https://www.viget.com/articles/understanding-futures-in-rust-part-1/",
      "date_published": "2019-03-26T00:00:00+00:00",
      "author": {
        "name": "Joe Jackson",
        "url": "https://www.viget.com/about/team/jjackson"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e69005a8-5193-4715-b906-f7a1a71db4f0",
      "title": "Dynamic Memory: A Heaping Helping",
      "content_text": "Managing dynamic memory is hard. Some languages assume users will do it themselves (C, C++), and some languages go to extreme lengths to protect users from themselves (Java, Python). In Rust, how the language uses dynamic memory (also referred to as the heap) is a system called ownership. And as the docs mention, ownership is Rust‚Äôs most unique feature.",
      "url": "https://speice.io/2019/02/a-heaping-helping.html",
      "date_published": "2019-02-07T00:00:00-05:00",
      "author": {
        "name": "Bradlee Speice",
        "url": "https://speice.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6ed35d04-359f-4971-9cf6-19d824cdcf72",
      "title": "Handmade Rust Part 3: Containers",
      "content_text": "The most commonly used kinds of containers are arrays and maps. Pretty much any other container type can be built using those two, so that‚Äôs what we‚Äôll build today! Of course, just like for Unq, we won‚Äôt be making simple replacements, instead we‚Äôll be making the most minimal containers necessary for now and add features later as needed, but we‚Äôll be make them allocator aware.",
      "url": "http://stevenlr.com/posts/handmade-rust-3-containers/",
      "date_published": "2019-03-23T17:12:54+01:00",
      "author": {
        "name": "Steven Le Rouzic",
        "url": "http://stevenlr.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c24a6d4f-b367-4b18-ad85-52fe59b7e6b3",
      "title": "The Phantom Builder",
      "content_text": "Recently on twitter, someone asked fora a practical explainer for PhantomData and while I don't have that I did want to share one place I have found PhantomData to be useful. This blog post is an overview of how I ended up using PhantomData in my builder patterns that require a generic type argument.",
      "url": "https://wiredforge.com/blog/phantom-builder/index.html",
      "date_published": "2019-03-24T00:00:00+00:00",
      "author": {
        "name": "Robert Masen",
        "url": "https://wiredforge.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "29538906-a949-430f-a129-f9c8dca4eb54",
      "title": "Kickstarting a database working group",
      "content_text": "I posted the idea of a database WG on twitter recently and it was met with a lot of excitement. Also there was a post on reddit recently that proposed the same idea, taken from examples of where using Rust with databases is currently a painful experience. I would as part of this also want to work out a base charter to start the WG as well as setting up when and how to have regular meetings to discuss roadmaps and current projects that are being worked on.",
      "url": "https://internals.rust-lang.org/t/kickstarting-a-database-wg/9696",
      "date_published": "2019-03-25T09:53:26+00:00",
      "author": {
        "name": "Katharina Fey",
        "url": "https://internals.rust-lang.org/u/spacekookie"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "166e7e9f-de17-4abb-b2f4-08169793f3dd",
      "title": "How to Debug Rust with Visual Studio Code",
      "content_text": "A step-by-step guide for debugging Rust with Visual Studio Code.",
      "url": "https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/",
      "date_published": "2019-02-03T20:01:00+00:00",
      "author": {
        "name": "Forrest Smith",
        "url": "https://www.forrestthewoods.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "44856ee1-451a-44b6-8cc1-5afd881bb57d",
      "title": "Fixed Memory: Stacking Up",
      "content_text": "const and static are perfectly fine, but it‚Äôs relatively rare that we know at compile-time about either values or references that will be the same for the duration of our program. Put another way, it‚Äôs not often the case that either you or your compiler knows how much memory your entire program will ever need.",
      "url": "https://speice.io/2019/02/stacking-up.html",
      "date_published": "2019-02-06T00:00:00-05:00",
      "author": {
        "name": "Bradlee Speice",
        "url": "https://speice.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "59ecea36-40a2-4b3a-aaf5-2d156d885d24",
      "title": "Handmade Rust Part 2: Unq, an allocator-aware Box",
      "content_text": "In the Rust standard library, Box is a RAII wrapper for an object on the heap. It‚Äôs actually a special type that‚Äôs not implemented purely in the library, but also use special features called lang items. It uses the global allocator to allocate its memory. We want a similar type that also has an allocator associated to it. We‚Äôll call it Unq, which mirror C++‚Äôs unique_ptr.",
      "url": "http://stevenlr.com/posts/handmade-rust-2-unq/",
      "date_published": "2019-02-10T16:30:21+01:00",
      "author": {
        "name": "Steven Le Rouzic",
        "url": "http://stevenlr.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "98e50b2b-889a-49d1-9973-f1d39c9cc389",
      "title": "My First 3 Weeks of Professional Rust",
      "content_text": "For the last 15 years as a professional programmer I have worked mostly with dynamic languages. First Perl, then Python, and for the last 10 years or so, Ruby. I‚Äôve also been writing Rust on the side for personal projects for nearly four years. Recently I started a new job and for the first time I‚Äôm writing Rust professionally. Rust represents quite a shift in language features, development process and tooling. I thought it would be interesting to reflect on that experience so far.",
      "url": "https://www.wezm.net/technical/2019/03/first-3-weeks-of-professional-rust/",
      "date_published": "2019-03-23T22:45:00+00:00",
      "author": {
        "name": "Wesley Moore",
        "url": "http://www.wezm.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6450a97d-c96a-47df-b999-a865defe34ae",
      "title": "Rust All Hands 2019: Array iterators, Rayon, and more",
      "content_text": "A few weeks ago, I had the pleasure of attending the second annual Rust All Hands meeting, hosted by Mozilla at their Berlin office. The attendees were a mix of volunteers and corporate employees covering the full range of Rust development, including the compiler, language, libraries, docs, tools, operations, and community. Although I‚Äôm sure there will be an official summary of the meeting (like last year‚Äôs), in this article, I‚Äôll cover a few things I was directly involved in. First, I‚Äôll look at a feature many developers have wanted for a long time‚Ä¶",
      "url": "https://developers.redhat.com/blog/2019/03/22/rust-all-hands-2019-array-iterators-rayon-and-more/",
      "date_published": "2019-03-22T07:05:51+00:00",
      "author": {
        "name": "Josh Stone",
        "url": "https://developers.redhat.com/blog/author/jistoneredhat-com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5190b436-eaa3-4067-a6a0-fec861ea8316",
      "title": "Handmade Rust Part 1: Introduction & Allocators",
      "content_text": "Welcome to Handmade Rust, a series (hopefully) where I will be developing a Vulkan rendering engine in Rust the Handmade way. By this, I mean using no external libraries, not even the Rust standard library, only the core lib. I am doing this mainly for my own enjoyment but also because I want to get better at writing Rust, and sometimes the best way to really understand something is to just do it yourself. The project will be available on GitHub at stevenlr/HandmadeRust.\n\nThe first step will be to build a foundation library for memory allocation, containers, and other utilities that are not provided by the core lib.",
      "url": "http://stevenlr.com/posts/handmade-rust-1-allocators/",
      "date_published": "2019-02-10T00:50:11+01:00",
      "author": {
        "name": "Steven Le Rouzic",
        "url": "http://stevenlr.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "108f009d-94b1-43c6-8598-43088175772e",
      "title": "Global Memory Usage: The Whole World",
      "content_text": "The first memory type we‚Äôll look at is pretty special: when Rust can prove that a value is fixed for the life of a program (const), and when a reference is unique for the life of a program (static as a declaration, not 'static as a lifetime), we can make use of global memory. This special section of data is embedded directly in the program binary so that variables are ready to go once the program loads; no additional computation is necessary.",
      "url": "https://speice.io/2019/02/the-whole-world.html",
      "date_published": "2019-02-05T00:00:00-05:00",
      "author": {
        "name": "Bradlee Speice",
        "url": "https://speice.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ba471387-4b93-4e46-8846-c89beddf6916",
      "title": "Allocations in Rust",
      "content_text": "There‚Äôs an alchemy of distilling complex technical topics into articles and videos that change the way programmers see the tools they interact with on a regular basis. I knew what a linker was, but there‚Äôs a staggering amount of complexity in between the OS and main(). Rust programmers use the Box type all the time, but there‚Äôs a rich history of the Rust language itself wrapped up in how special it is.\n\nIn a similar vein, this series attempts to look at code and understand how memory is used; the complex choreography of operating system, compiler, and program that frees you to focus on functionality far-flung from frivolous book-keeping. The Rust compiler relieves a great deal of the cognitive burden associated with memory management, but we‚Äôre going to step into its world for a while.\n\nLet‚Äôs learn a bit about memory in Rust.",
      "url": "https://speice.io/2019/02/understanding-allocations-in-rust.html",
      "date_published": "2019-02-04T00:00:00-05:00",
      "author": {
        "name": "Bradlee Speice",
        "url": "https://speice.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1e324360-c349-474e-b091-7c5250958ffc",
      "title": "Custom Exit Status Codes with ? in main",
      "content_text": "Rust 1.26 introduced the ability to return a Result from the main method, which was a great ergonomics improvement especially for small CLI applications. If your application returns an Ok, Rust reports a success exit status code to the operating system. Likewise if your application returns an Err, Rust reports an error exit status code.\n\nBut what if you want to return a custom exit status error code for each possible error type in your application, to provide some additional feedback to your user? This leads into an exploration of the Termination and Try traits, and is the topic of this post.",
      "url": "https://www.joshmcguigan.com/blog/custom-exit-status-codes-rust/",
      "date_published": "2019-02-09T00:00:00+00:00",
      "author": {
        "name": "Josh Mcguigan",
        "url": "https://www.joshmcguigan.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ea9c3fbe-c681-4b42-a0ef-3699a1612972",
      "title": "Are we Database Yet?",
      "content_text": "I'm giving a talk next month at our Rust Meetup about using Rust in production. I've been reflecting on my last few months using Rust after learning the language about a year ago. One of my most frustrating experiences tends to always be around the futures ecosystem, as that's where I oft-fruitless labour for hours before giving up on what I'm doing.\n\nI do data engineering and software development work professionally, and these 2 areas are where I often find a lot of pain with using the language.\n\nA few weeks ago I wanted to write something that takes csv files and writes them to a database. I used Apache Arrow's Rust library (which I've started contributing to this year) to do that. The idea was simple, Arrow has a CSV reader that can infer schema, so I map the schema's data types to a database's types, and then I sequentially write records in batches to the database.\n\nI found the exercise quite painful, so I'd like to talk about databases and Rust.",
      "url": "https://www.reddit.com/r/rust/comments/b463rg/are_we_database_yet/",
      "date_published": "2019-03-23T02:02:56+11:00",
      "author": {
        "name": "nevi-me",
        "url": "https://www.reddit.com/user/nevi-me"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "eed8a936-e3c7-45b5-bc50-3e1b95ffb767",
      "title": "In nightly Rust, 'await!' may never return (dropping futures)",
      "content_text": "I've been using the proposed await! and Future features in nightly Rust, and overall, I really like the design. But I did run into one surprise: await! may never return, and this has consequences I didn't fully understand. Let's take a look.",
      "url": "http://www.randomhacks.net/2019/03/09/in-nightly-rust-await-may-never-return/",
      "date_published": "2019-03-09T15:11:20-05:00",
      "author": {
        "name": "Eric Kidd",
        "url": "http://www.randomhacks.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "34dfeb70-4900-4ef3-b6d5-674d3caf376d",
      "title": "Learning Rust With Entirely Too Many Linked Lists",
      "content_text": "I fairly frequently get asked how to implement a linked list in Rust. The answer honestly depends on what your requirements are, and it's obviously not super easy to answer the question on the spot. As such I've decided to write this book to comprehensively answer the question once and for all. In this series I will teach you basic and advanced Rust programming entirely by having you implement 6 linked lists.",
      "url": "https://rust-unofficial.github.io/too-many-lists/",
      "date_published": "2019-03-22T00:00:00+00:00",
      "author": {
        "name": "Alexis Beingessner",
        "url": "https://gankro.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "88233a0c-3917-4ec2-b2c5-bcfd322a9662",
      "title": "Chaining Functions Without Returning Self",
      "content_text": "It‚Äôs a common pattern in the Rust ecosystem to have a function return self at the end in order to enable method chaining. This approach is often used in combination with the builder pattern, though it can also be applied to a wide variety of other situations. The example demonstrates the most straightforward of these cases (i.e. initializing and modifying an object in a single statement), but, as I‚Äôm going to demonstrate, this approach quickly breaks down when applied to a wider variety of use cases.",
      "url": "https://randompoison.github.io/posts/returning-self/",
      "date_published": "2019-03-21T00:00:00+00:00",
      "author": {
        "name": "David LeGare",
        "url": "https://randompoison.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d10fac5d-46ac-49b4-a8e0-517cb3cdfcba",
      "title": "Procedural macro in Rust 101",
      "content_text": "How to pick a function and make it a macro with added superpowers.",
      "url": "https://dev.to/naufraghi/procedural-macro-in-rust-101-k3f",
      "date_published": "2019-03-17T00:00:00+00:00",
      "author": {
        "name": "Matteo Bertini",
        "url": "https://dev.to/naufraghi"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5afc518c-63b7-4b76-96f2-659de41359d9",
      "title": "rustdoc in 2019",
      "content_text": "A recap of the 2019 Rust All-Hands from a rustdoc perspective; and the 2019 roadmap for the Rustdoc Team.",
      "url": "https://quietmisdreavus.net/code/2019/02/19/rustdoc-in-2019/",
      "date_published": "2019-02-19T12:00:00-06:00",
      "author": {
        "name": "QuietMisdreavus",
        "url": "https://quietmisdreavus.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "09e6b7ba-69f9-4256-9ce5-c75ea253c3ec",
      "title": "Should Rust channels panic on send if nobody's listening?",
      "content_text": "Lately, I've been working on several real-world systems using Rust's async and tokio. As you can see on the areweasyncyet.rs site, this requires using nightly Rust and the experimental tokio-async-await library. I hope to talk more about these experiences soon! But today, I want to talk about channel APIs in Rust. A question was raised by @matklad on GitHub, \"I've migrated rust-analyzer to crossbeam-channel 0.3, and the thing I've noticed is that every .send is followed by .unwrap. Perhaps we should make this unwrapping behavior the default, and introduce a separate checked_send which returns a Result?\".",
      "url": "http://www.randomhacks.net/2019/03/08/should-rust-channels-panic-on-send/",
      "date_published": "2019-03-08T16:42:27-05:00",
      "author": {
        "name": "Eric Kidd",
        "url": "http://www.randomhacks.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b86ab49d-2104-43d3-86c2-3bbf740f08f2",
      "title": "Async, futures, and tokio - Rust Crash Course lesson 7",
      "content_text": "Unlike languages like Haskell, Erlang, and Go, Rust does not have a runtime system providing green threads and asynchronous I/O. However, for many real world use cases, async I/O is strongly desired, if not a hard requirement. The de facto standard library for handling this in Rust is tokio. This post is part of a series based on teaching Rust at FP Complete.",
      "url": "https://www.snoyman.com/blog/2018/12/rust-crash-course-07-async-futures-tokio",
      "date_published": "2018-12-03T00:00:00+00:00",
      "author": {
        "name": "Michael Snoyman",
        "url": "https://www.snoyman.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6cab1c1c-68f3-4f20-b239-85009d4d563a",
      "title": "How to document Rust's macro invocation",
      "content_text": "You can easily document your Rust items like functions by putting three slashes ///. However, if you want to document each separate invocation of your amazing! macro, it is not that straightfoward.",
      "url": "https://amanjeev.com/blog/rust-document-macro-invocations/",
      "date_published": "2019-02-21T00:00:00+00:00",
      "author": {
        "name": "Amanjeev Sethi",
        "url": "https://amanjeev.com/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "38a15a60-b3e5-49c5-9036-3af3d6bc43ff",
      "title": "Why Hashbrown Does A Double-Lookup",
      "content_text": "I recently finished a detailed review of hashbrown, which will likely become the new implementation for rust's std::collections::HashMap. One of the most surprising things I found was in the implementation of insert. It was doing something that was so offensive to people who care about collection performance that we had designed an entire API to help people avoid it: it did two lookups in the map. However, after some more discussion and review, I concluded that this implementation was reasonable. This post will try to cover why that is.",
      "url": "https://gankro.github.io/blah/hashbrown-insert/",
      "date_published": "2019-03-20T00:00:00+00:00",
      "author": {
        "name": "Alexis Beingessner",
        "url": "https://gankro.github.io/"
      },
      "tags": [
        "Language",
        "Performance"
      ]
    },
    {
      "id": "23fcf66c-3fff-4894-836d-32a880171b46",
      "title": "How productive is Rust?",
      "content_text": "We often get the question how productive working with Rust is. ‚ÄúWe know that it is awesome, but isn‚Äôt it hard to learn? Don‚Äôt you struggle with the borrow checker?‚Äù. Well, we put it to the test in Google‚Äôs Hash Code 2019 programming competition.",
      "url": "https://medium.com/@woutergeraedts/how-productive-is-rust-e2260db28f09",
      "date_published": "2019-03-08T12:59:39.723+00:00",
      "author": {
        "name": "Wouter Geraedts",
        "url": "https://medium.com/@woutergeraedts"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "48cd5e22-48f6-4711-a1d2-e9ce7338ef0d",
      "title": "Enjoy Compile time function evaluation using 'const fn' in Rust",
      "content_text": "A few days ago, I was exploring Rust‚Äôs Unstable Book and found pretty much same feature in Rust, which is const_fn. I started exploring this feature more after the recent Rust release 1.33.0, in which Rust team has announced major improvements in const fn. The idea of using const fn is to compute result at compile time so that time can be saved when code is run.",
      "url": "https://blog.knoldus.com/no-more-run-time-enjoy-compile-time-function-evaluation-using-const-fn-in-rust/",
      "date_published": "2019-03-04T15:26:43+00:00",
      "author": {
        "name": "Ayush Mishra",
        "url": "https://blog.knoldus.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "28f6c857-f8f6-4ff3-8a21-12c894a7dbb8",
      "title": "JavaFX UI in Rust",
      "content_text": "In this post, I would like to share the way how we can implement a Rust application that has a User Interface written in JavaFX.",
      "url": "https://astonbitecode.github.io/blog/post/rust-javafx/",
      "date_published": "2019-02-28T00:05:58+00:00",
      "author": {
        "name": "Aston",
        "url": "https://astonbitecode.github.io/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e9d10b77-3f54-4479-b685-26efa74f67ce",
      "title": "Getting started with Rust FFI",
      "content_text": "The memory models of Rust and C can often cause a lot of friction. This guide is born out of my own personal struggles writing transmission-sys a wrapper for the Transmission BitTorrent client. Though in this guide we will go over the much simpler example of writing a wrapper for libevent-sys.",
      "url": "https://rushsteve1.us/wp/getting-started-with-rust-ffi/",
      "date_published": "2019-02-15T03:00:32+00:00",
      "author": {
        "name": "Rushsteve1",
        "url": "https://rushsteve1.us/wp/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c838f89e-80f8-4146-b26e-622020ff2653",
      "title": "Async-await status report",
      "content_text": "I wanted to post a quick update on the status of the async-await effort. The short version is that we‚Äôre in the home stretch for some kind of stabilization, but there remain some significant questions to overcome.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2019/03/01/async-await-status-report/",
      "date_published": "2019-03-01T00:00:00-05:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4a9fd96a-fd25-48dd-a97e-511e023b35f8",
      "title": "Proposal: New channels for Rust‚Äôs standard library",
      "content_text": "In this blog post, I‚Äôm proposing we also replace the guts of mpsc with crossbeam-channel for some more performance wins. However, unlike with mutexes and hash maps, this change will also enable oft-requested new features that make it tempting to deprecate mpsc altogether and introduce better channels designed from scratch.",
      "url": "https://stjepang.github.io/2019/03/02/new-channels.html",
      "date_published": "2019-03-02T00:00:00+00:00",
      "author": {
        "name": "Stjepan Glavina",
        "url": "https://stjepang.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e6376cd5-713f-4a8e-8792-2329772feee5",
      "title": "Announcing Rust 1.33.0",
      "content_text": "The Rust team is happy to announce a new version of Rust, 1.33.0. The two largest features in this release are significant improvements to const fns, and the stabilization of a new concept: \"pinning.\"",
      "url": "https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html",
      "date_published": "2019-02-28T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a6483426-5600-4cf0-a514-c532946abda3",
      "title": "Bid adieu to tarpaulin, HTML reports are here for Rust",
      "content_text": "Kcov is a code coverage tool for Binaries, Shell scripts as well as Python scripts. It generates an HTML file for most of the languages. But we will focus mainly on Rust language.",
      "url": "https://blog.knoldus.com/bid-adieu-to-tarpaulin-html-reports-are-here-for-rust/",
      "date_published": "2019-02-26T06:41:19+00:00",
      "author": {
        "name": "Mudit Chhabra",
        "url": "https://blog.knoldus.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f93cc38e-4380-4174-8f53-b5c6674772da",
      "title": "Rust build scripts vs. Meson",
      "content_text": "One of the pain points in trying to make the Meson build system work with Rust and Cargo is Cargo's use of build scripts, i.e. the build.rs that many Rust programs use for doing things before the main build. This post is about my exploration of what build.rs does.",
      "url": "https://people.gnome.org/~federico/blog/rust-build-scripts.html",
      "date_published": "2019-02-27T12:14:12-06:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b149b575-39a9-4136-8749-29e04c5cf0b3",
      "title": "Rust Case Study: Community makes Rust an easy choice for npm [pdf]",
      "content_text": "Learn how npm uses Rust",
      "url": "https://www.rust-lang.org/static/pdfs/Rust-npm-Whitepaper.pdf",
      "date_published": "2019-02-27T03:26:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2c0fbe82-0ef4-455a-94f9-886472559fdb",
      "title": "MPSC Channel API for painless usage of threads with GTK in Rust",
      "content_text": "A very common question that comes up on IRC or elsewhere by people trying to use the gtk-rs GTK bindings in Rust is how to modify UI state, or more specifically GTK widgets, from another thread. I‚Äôll take this opportunity to also explain why it‚Äôs not so trivial in Rust first and also explain another solution.",
      "url": "https://coaxion.net/blog/2019/02/mpsc-channel-api-for-painless-usage-of-threads-with-gtk-in-rust/",
      "date_published": "2019-02-09T13:25:55+00:00",
      "author": {
        "name": "Sebastian Dr√∂ge",
        "url": "https://coaxion.net/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "295b15d9-04eb-420c-bc3e-8b3c12a81882",
      "title": "Visualizing your Rust code using graphviz",
      "content_text": "In a previous post I mentioned that the Rust compiler allows you to output interesting intermediate languages/formats in a number of different ways. hir, mir and even flowgraphs! In this post I will be giving a brief overview of the flowgraph format and also instructions on how to generate images from your code.",
      "url": "https://jonathansteyfkens.com/posts/visualizing-rust.html",
      "date_published": "2019-02-17T00:00:00+00:00",
      "author": {
        "name": "Jonathan Steyfkens",
        "url": "https://jonathansteyfkens.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "16bded10-81dc-4ef1-bf04-83a8ab584308",
      "title": "A Quick Look at Trait Objects in Rust",
      "content_text": "One of the things that baffled me for quite a long time are Rust‚Äôs ‚Äútrait objects‚Äù: they felt like an odd part of the language and I was never quite sure whether I was using them or not, even when I wanted to be. Since I‚Äôve recently had cause to look into them in more detail, I thought it might be helpful to write a few things down, in case anyone else finds my explanation useful. The first part of this blog post covers the basics and the second part takes a look at the performance implications of the way trait objects are implemented in Rust.",
      "url": "https://tratt.net/laurie/blog/entries/a_quick_look_at_trait_objects_in_rust.html",
      "date_published": "2019-02-12T00:00:00+00:00",
      "author": {
        "name": "Laurence Tratt",
        "url": "https://tratt.net/laurie/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2471466d-74a1-4d19-82d7-6909e10178cd",
      "title": "Changes in the core team",
      "content_text": "Just a quick update: You may have noticed that, in the last month or so, a number of Rust core team members have changed their jobs and/or their roles in the project.",
      "url": "https://blog.rust-lang.org/2019/02/22/Core-team-changes.html",
      "date_published": "2019-02-22T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0d3ca45d-85aa-40ab-95f0-40ec5abaa75f",
      "title": "Rust lang team working groups",
      "content_text": "Now that the Rust 2018 edition has shipped, the language design team has been thinking a lot about what to do in 2019 and over the next few years. I think we‚Äôve got a lot of exciting stuff on the horizon, and I wanted to write about it.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2019/02/22/rust-lang-team-working-groups/",
      "date_published": "2019-02-22T00:00:00-05:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "365d8318-a9d3-4c1e-9f2a-73c4c5d812ee",
      "title": "Hindsight on Advent of Code 2018",
      "content_text": "On the 1st of December 2018, I decided to give it a try to Advent of Code. AoC is, basically, a programming challenge website where you get two puzzles unlocked every day of December from 1st to 25th ‚Äì hence the name. It has a ranking system which scores are based on the absolute time you took to solve the puzzles ‚Äì i.e. spent time as soon as the puzzles got unlocked. As a French living in Paris, I find this a bit unfair (we get puzzles unlocked at around 5:00 AM!) and then I just realized I could do the puzzles for fun only.\n\nThis blog post sums up what I did with AoC#18, my thoughts about the puzzles and even a meta-discussion about programming challenges. I used Haskell for most challenges and switched to Rust for no specific reason. Just fun.",
      "url": "https://phaazon.net/blog/aoc-18-hindsight",
      "date_published": "2019-01-12T00:20:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2c43b8ca-4c87-4138-adfc-2e32660061a2",
      "title": "Generators II: The Question Mark Problem",
      "content_text": "This is my second post on the design of generators. In the first post, I outlined what an MVP of the feature would look like. In this post, I want to take a look at the first design issue for the feature: how it integrates with the ? operator.",
      "url": "https://boats.gitlab.io/blog/post/generators-ii/",
      "date_published": "2019-02-18T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5e9e06ae-e22f-4798-b921-d8cb96bf451e",
      "title": "Fearless Security: Thread Safety",
      "content_text": "Multithreading allows programs to do more faster, but adds synchronization bugs and attacks. From a security standpoint, why do we care about thread safety?",
      "url": "https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/",
      "date_published": "2019-02-14T15:48:10+00:00",
      "author": {
        "name": "Diane Hosfelt",
        "url": "https://hacks.mozilla.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7c13bc47-79a3-408a-bfc0-d67639f4f359",
      "title": "DOS: the final frontier...",
      "content_text": "In our crusade to oxidize platform after platform, I've been working to bring Rust to yet another target: MS-DOS. I don't know if this has been done before, but I couldn't find any information about it on the web, so I had to rely on information about using GCC to compile MS-DOS programs (not all of which carried over), and it took quite a bit of fiddling with the target specification to get things just right. In the end, I've managed to produce COM executables that can call DOS interrupts and interface with hardware such as the PC speaker, and presumably the rest of the hardware, given the right code.",
      "url": "https://www.reddit.com/r/rust/comments/ask2v5/dos_the_final_frontier/",
      "date_published": "2019-02-20T15:47:21+11:00",
      "author": {
        "name": "u/serentty",
        "url": "https://www.reddit.com/user/serentty"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "82089039-8f19-4e01-8d91-d0ef468bbab8",
      "title": "Exploring Rust",
      "content_text": "Rust provides a lot of language constructs to enable and empower the user to write memory safe and correct code. But what happens behind these constructs? In this post I will outline ways of exploring rust and it‚Äôs compiler.\n\nLast weekend I went to fosdem 2019. This is where I had the chance to attend a talk given by Matthias Endler. In his talk he explained how rust has got a lot of syntactic sugar to help the programmers in writing safe and correct code, part of his talk was explaining cargo-inspect to analyse this syntax and see what‚Äôs happening behind the scenes. This inspired me to dig a bit deeper and try out other tools.",
      "url": "https://jonathansteyfkens.com/posts/explore-rust.html",
      "date_published": "2019-02-09T00:00:00+00:00",
      "author": {
        "name": "Jonathan Steyfkens",
        "url": "https://jonathansteyfkens.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9cb7faf6-a9cb-4bf5-9549-96ee7e80dd12",
      "title": "One Hundred Rust PRs later",
      "content_text": "It‚Äôs hard for me to believe but it‚Äôs already been over a year since I seriously committed to learning Rust and I have now reached my initial goal of 100 open source contributions to the Rust ecosystem. You can see the full list here. I want to use this blog post to review the work I‚Äôve done, talk about the challenges I‚Äôve come across and how I‚Äôve tried to deal with them. I‚Äôm afraid I haven‚Äôt blogged in a long time and this is a bit longer than usual.",
      "url": "https://phansch.net/2019/02/18/onehundred-rust-prs/",
      "date_published": "2019-02-18T00:00:00+00:00",
      "author": {
        "name": "Philipp Hansch",
        "url": "https://phansch.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "52b68916-b65b-4a28-9bac-e8c8038c6194",
      "title": "The Builder Pattern in Rust",
      "content_text": "For the very first coding blog, I think it is appropriate to start with building objects. This post is about the Builder Pattern in Rust, and how it taught me I couldn‚Äôt write everything the way I want. Yes, strong typing prevents you from common pitfalls, and C++ can go quite far in this direction (as many JS/Python enthusiastic will gladly testify). It is often easy to forget how it sometimes prevents you from writing a completely legal and safe code, due to rules being too ‚Äúprotective‚Äù. And as Rust takes the code safety to a whole new level, sometimes a trivial code can‚Äôt be written, and without the proper knowledge, it might seem entirely arbitrary. It was a subtle restriction in the builder pattern that took me by surprise first.",
      "url": "https://oribenshir.github.io/afternoon_rusting/blog/building-rust",
      "date_published": "2019-02-08T00:00:00+00:00",
      "author": {
        "name": "Ori Ben-Shir",
        "url": "https://oribenshir.github.io/afternoon_rusting/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a22c0b8e-ed54-4502-8130-a03913b6ff67",
      "title": "Generators I: Toward a minimum viable product",
      "content_text": "We‚Äôre still not finished with the design of async/await, but it‚Äôs already become clear that it‚Äôs time to get the next phases of the feature into the pipeline. There are two extensions to the minimal async/await feature we‚Äôve currently got that seem like the clear high priority:\n Async methods: allowing async fn to be used in traits. Generators: allowing imperative control flow to create Iterators and Streams the same way async fn allows imperative control flow to create a Future.",
      "url": "https://boats.gitlab.io/blog/post/generators-i/",
      "date_published": "2019-02-11T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6881b0f3-53e8-4fbf-bca2-9e108792bf29",
      "title": "Rust: The story of closures",
      "content_text": "The Rust programming language introduced many leading concepts in the programming language design landscape. The most famous features are the borrow checker, the ownership management and the trait system.\n\nHowever, the fantastic expressiveness of the closures is generally underestimated. Yes, from the day Javascript introduces closures to main stream programming languages, these days closures become one of the basic features for almost all modern languages. However, Rust‚Äôs ownership rules result in some brand-new observations to closures and its position in programming. Let‚Äôs start the journey now.",
      "url": "https://medium.com/@earthengine/rust-the-story-of-closures-8f8e5af7ea1c",
      "date_published": "2019-01-27T03:12:11.943+00:00",
      "author": {
        "name": "Earth Engine",
        "url": "https://medium.com/@earthengine"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d7fe7d63-d2c8-4bfc-834b-a93155c10dcb",
      "title": "Rust: A unique perspective",
      "content_text": "In which I try to explain the reasoning behind Rust‚Äôs memory-safety mechanisms.",
      "url": "https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html",
      "date_published": "2019-02-07T00:00:00+00:00",
      "author": {
        "name": "Matt Brubeck",
        "url": "https://limpet.net/mbrubeck/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d1d825d3-b864-466c-9909-287ae17591a9",
      "title": "Moving from Ruby to Rust",
      "content_text": "How we migrated our Tier 1 service from Ruby to Rust and didn‚Äôt break production.",
      "url": "https://deliveroo.engineering/2019/02/14/moving-from-ruby-to-rust.html",
      "date_published": "2019-02-14T00:00:00+00:00",
      "author": {
        "name": "Andrii Dmytrenko",
        "url": "https://deliveroo.engineering/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "66563fe6-008a-475e-9337-42ee770d649c",
      "title": "Rust Governance: Scaling Empathy",
      "content_text": "There‚Äôs been a lot of talk about improving Rust‚Äôs governance model lately. As we decompress from last year‚Äôs hectic edition work, we‚Äôre slowly starting to look at all the bits of debt we accumulated, and organizational debt is high on that list.\n\nI‚Äôve been talking in private with people about a bunch of these things for quite a while now, and I felt it worthwhile to write down as much of my thoughts as I can before the Rust All Hands in Berlin this week.",
      "url": "https://manishearth.github.io/blog/2019/02/04/rust-governance-scaling-empathy/",
      "date_published": "2019-02-04T00:00:00+00:00",
      "author": {
        "name": "Manish Goregaokar",
        "url": "https://manishearth.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e412275c-f2ce-4748-bf3d-c53375ff5693",
      "title": "Cross compiling Rust from Linux to macOS",
      "content_text": "I‚Äôve recently been working on a Rust project at work which requires compiling for Linux (GNU), Linux (musl - for Alpine Linux) and macOS. I use Linux Mint nearly all the time, so building for macOS targets has required asking very nicely to borrow a spare Macbook Air. This is naturally a bit crap, so I set out to find a Linux-only solution to cross compile for macOS using osxcross. A weekend of pain later, and I have the following post. Hopefully it spares you a weekend of your own pain.",
      "url": "https://wapl.es/rust/2019/02/17/rust-cross-compile-linux-to-macos.html",
      "date_published": "2019-02-17T00:00:00+00:00",
      "author": {
        "name": "James Waples",
        "url": "https://wapl.es/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1c46694b-ae67-4596-9f46-0e9fd419f585",
      "title": "No, the problem isn‚Äôt ‚Äúbad coders‚Äù",
      "content_text": "A recent blog article discussed the fact that 70% of all security bugs in Microsoft products are due to memory safety vulnerabilities. A lot of the comments I‚Äôve seen on social media boil down to ‚ÄúThe problem isn‚Äôt the use of a memory unsafe language, but that the programmers who wrote this code are bad.‚Äù\n\nIn this article, I‚Äôm going to look at a recent bug that was caught by the Rust compiler, which I think shows that not only is this assertion unreasonable but virtually impossible for reasons I haven‚Äôt seen discussed. While the example I‚Äôm going to give is about thread safety rather than memory safety, the arguments I‚Äôm going to present can be applied to both.",
      "url": "https://medium.com/@sgrif/no-the-problem-isnt-bad-coders-ed4347810270",
      "date_published": "2019-02-12T16:13:55.539+00:00",
      "author": {
        "name": "Sean Griffin",
        "url": "https://medium.com/@sgrif"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "56014abd-0fd0-4b8c-91ba-734e4f16ddac",
      "title": "Gtk-rs: how to have mutable object in a closure?",
      "content_text": "I wanted, was to start the Gtk application with already generated image of the prime numbers spiral (contained in gtk::Image widget) and then be able to re-generate the image when user changed something. It could be \"Generate\" click action for instance to show image in different resolution or color. The problem with the button closure was that when I added the Gtk image to the box_vert container, the next time the button was pressed, the code was supposed to remove existing image and add new one, but it didn't.",
      "url": "http://sireliah.com/niusy/gtk_rust_mutable_object_in_closure/",
      "date_published": "2019-02-12T21:58:00+00:00",
      "author": {
        "name": "Piotr Go≈ÇƒÖb",
        "url": "http://sireliah.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "03bb4da4-48ab-4e1a-a092-be737761fd6f",
      "title": "All-Hands 2019 Recap",
      "content_text": "Last week, I was in Berlin at the Rust All-Hands 2019. It was great! I will miss nerding out in discussions about type theory and having every question answered by just going to the person who‚Äôs the expert in that area, and asking them. In this post, I am summarizing the progress we made in my main areas of interest and the discussions I was involved in‚Äîthis is obviously just a small slice of all the things that happened.",
      "url": "https://www.ralfj.de/blog/2019/02/12/all-hands-recap.html",
      "date_published": "2019-02-12T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3c0e89db-b8b3-44bc-a952-4cf406146fae",
      "title": "Are you still using `println` in Rust for debugging?",
      "content_text": "In this blog, I will explain about new debugging macro dbg, added in Rust 1.32.0. This is a macro for quick and dirty debugging with which you can inspect the value of a given expression.",
      "url": "https://blog.knoldus.com/are-you-still-using-println-in-rust-for-debugging/",
      "date_published": "2019-02-11T04:20:21+00:00",
      "author": {
        "name": "Ayush Mishra",
        "url": "https://blog.knoldus.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "30602bae-8957-4b3a-92d2-eec9e6f2fddd",
      "title": "Salsa: Incremental recompilation",
      "content_text": "So for the last couple of months or so, I‚Äôve been hacking in my spare time on this library named salsa, along with a number of awesome other folks. Salsa basically extracts the incremental recompilation techniques that we built for rustc into a general-purpose framework that can be used by other programs. Salsa is developing quickly: with the publishing of v0.10.0, we saw a big step up in the overall ergonomics, and I think the current interface is starting to feel very nice.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2019/01/29/salsa-incremental-recompilation/",
      "date_published": "2019-01-29T00:00:00-05:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4a6ed1c0-83d7-4392-9d2a-9b749a5433fe",
      "title": "Rust: regret-less concurrency",
      "content_text": "Rust offers the promise of ‚Äúfearless concurrency‚Äù, and delivers on it through memory safety. Yet this safety doesn‚Äôt guarantee code that is easy to maintain. If one is not ‚Äúfearful‚Äù of complexity, concurrency can easily become a story of regrets. Can we get a ‚Äúregret-less‚Äù kind of concurrency?",
      "url": "https://medium.com/@polyglot_factotum/rust-regret-less-concurrency-2238b9e53333",
      "date_published": "2019-02-02T12:15:32.811+00:00",
      "author": {
        "name": "Polyglot Factotum",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7028c8de-9b0d-4f0f-a74e-0e07126cd80e",
      "title": "Killing unwrap()",
      "content_text": "A collection of snippets to avoid unnecessary calls to unwrap() in Rust.",
      "url": "https://dmerej.info/blog/post/killing-unwrap/",
      "date_published": "2019-01-30T19:11:26+00:00",
      "author": {
        "name": "Dimitri Merejkowsky",
        "url": "https://dmerej.info/blog/humans.txt"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e743cfa5-87bc-46d7-9dc6-693352d91e6a",
      "title": "Letting the compiler tell you what to do - an example using Rust",
      "content_text": "If you‚Äôve ever wrote code in a compiled language (C, C++, Java, ‚Ä¶), you are probably used to compiler error messages, and you may think there are only here to prevent you from making mistakes. Well sometimes you can also use compiler error messages to design and implement new features. Let me show you with a simple command-line program written in Rust.",
      "url": "https://dmerej.info/blog/post/letting-the-compiler-tell-you-what-to-do/",
      "date_published": "2019-01-12T12:26:27+00:00",
      "author": {
        "name": "Dimitri Merejkowsky",
        "url": "https://dmerej.info/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "09b9f354-aeed-4d48-b859-9c63fcdddb2e",
      "title": "Polonius and the case of the hereditary harrop predicate",
      "content_text": "In my previous post about Polonius and subregion obligations, I mentioned that there needs to be a follow-up to deal with higher-ranked subregions. This post digs a bit more into what the problem is in the first place and sketches out the general solution I have in mind, but doesn‚Äôt give any concrete algorithms for it.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2019/01/21/hereditary-harrop-region-constraints/",
      "date_published": "2019-01-21T00:00:00-05:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "892a8c46-fee3-48d8-bc78-69a13a9a5c8d",
      "title": "The steps towards rustc, the great optimiser",
      "content_text": "It has been more than 3 years now since the MIR ini¬≠ti¬≠at¬≠ive has been ac¬≠cep¬≠ted. Cur¬≠rently rustc has a num¬≠ber of MIR op¬≠tim¬≠isa¬≠tions: a simple in¬≠lin¬≠er, ba¬≠sic con¬≠stant and copy propaga¬≠tion, a single in¬≠struc¬≠tion com¬≠bin¬≠a¬≠tion rule, a few graph sim¬≠pli¬≠fic¬≠a¬≠tion and clean up passes‚Ä¶ The pat¬≠tern here is clear ‚Äì most of the op¬≠tim¬≠isa¬≠tions we cur¬≠rently have are ba¬≠sic and lim¬≠ited in their po¬≠tency. Given the pace at which we man¬≠aged to bring up MIR in the first place, one would be right to ex¬≠pect‚Ä¶ some¬≠thing more.\n\nAs some¬≠body who has made an at¬≠tempt and failed to im¬≠ple¬≠ment a num¬≠ber of data¬≠flow-¬≠based op¬≠tim¬≠isa¬≠tions (a¬≠mong other thing¬≠s), I con¬≠sider my¬≠self fairly qual¬≠i¬≠fied to haz¬≠ard a guess as to what is the reason for the cur¬≠rent state we are at. Here it goes.",
      "url": "https://kazlauskas.me/entries/the-road-to-bestest-optimiser.html",
      "date_published": "2019-02-01T00:00:00+00:00",
      "author": {
        "name": "Simonas Kazlauskas",
        "url": "https://kazlauskas.me/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8788ae2c-06ea-4226-a28e-8755b31c6860",
      "title": "Refactoring allowed URLs in librsvg",
      "content_text": "While in the middle of converting librsvg's code that processes XML from C to Rust, I went into a digression that has to do with the way librsvg decides which files are allowed to be referenced from within an SVG. There was a central function rsvg_io_acquire_stream() which took a URL as a string. The code assumed that that URL had been first validated with a function called allow_load(url). Rust made it possible to actually make it impossible to acquire a disallowed URL.",
      "url": "https://people.gnome.org/~federico/blog/refactoring-allowed-urls-in-librsvg.html",
      "date_published": "2018-11-29T11:31:37-06:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "040a805b-f794-4df1-810f-5d3607a3f274",
      "title": "Cargo's next few years",
      "content_text": "The Cargo team have been thinking about and discussing long-term plans for Cargo. In this post I'll talk about what we hope Cargo will look like around the time of the next edition (assuming there is another edition and that it happens in about three years, neither of which is confirmed). There will be another post soon on more concrete plans for this year, including some kind of roadmap.",
      "url": "https://www.ncameron.org/blog/cargos-next-few-years/",
      "date_published": "2019-02-02T04:35:37+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2d233ddd-ecb5-499d-88b8-a0f14797c1a7",
      "title": "Rust on iOS",
      "content_text": "If you‚Äôre an iOS developer you may be asking yourself how and why you would make use of Rust on iOS. This article will mostly cover the how. As to why, the most compelling reason for us at Visly is that it enables us to share code between Android and iOS in a performant and safe manner, in a language much easier to work with than C++.",
      "url": "https://medium.com/visly/rust-on-ios-39f799b3c1dd",
      "date_published": "2019-01-26T21:30:07.781+00:00",
      "author": {
        "name": "Emil Sj√∂lander",
        "url": "https://medium.com/@emilsj"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "799301a7-d57a-4e9c-8412-aafc4e643f0a",
      "title": "Rust OSS Governance and Sustainablility I",
      "content_text": "Recently I travelled all the way to Waterloo from Boston for Starcon. With a 9 hour drive I had a lot of time to think about things and so I spent a good majority of it thinking about OSS Governanace and Sustainability. What I came up with and thought of is the more concrete solutions to the problems I brought up in my Rust 2019 post. With the Rust All hands in Berlin only a few weeks away I wanted to get my thoughts in order by writing out some of the solutions to specific problems I came up with. Now, this doesn't mean they'll be accepted! We might even find better solutions! I just felt a need to articulate them as both a reference point and to make sure I've thought through them well. I'll be splitting them into a few posts so I can publish more faster, rather than write one long post that won't be published in time. With that in mind let's begin!",
      "url": "https://mgattozzi.com/oss-governance-and-sustainablility-i/",
      "date_published": "2019-01-22T04:20:23+00:00",
      "author": {
        "name": "Michael Gattozzi",
        "url": "https://mgattozzi.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f950f168-d74e-4b3a-b2f5-18546a7d282b",
      "title": "Why aren't my Rust threads running?",
      "content_text": "I got a bit tangled up while experimenting with threads and channels in Rust. The compiler prevented any undefined behavior or memory corruption, but it can only do so much. My problems came from a shaky understanding of the language‚Äôs fundamentals and the inherent complexity of parallel programming. Or, in my case, attempted parallel programming.",
      "url": "https://esimmler.com/why-arent-my-rust-threads-running/",
      "date_published": "2019-01-19T00:00:00+00:00",
      "author": {
        "name": "Erik Simmler",
        "url": "https://esimmler.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "90b0ffa9-1711-4870-9e30-37375be50515",
      "title": "How to order Rust code",
      "content_text": "Note:This post is about how I arrange the code I write in Rust.If you wanted to ‚Äúorder‚Äù Rust codein the ‚Äúhire someone to write code‚Äù sense,you should still keep on readingas this is excellent material for a job interview.(Not the opinion I present but having an opinion on the topic.)",
      "url": "https://deterministic.space/how-to-order-rust-code.html",
      "date_published": "2019-01-17T00:00:00+01:00",
      "author": {
        "name": "Pascal Hertleif",
        "url": "https://deterministic.space/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "65dcfcd4-e17a-4e0d-bd56-ccea6cfe062f",
      "title": "When Rust is safer than Haskell",
      "content_text": "Haskell generally has better safety guarantees than Rust, there are some cases when Rust is safer than Haskell. This post explores when Rust is safe to use.",
      "url": "https://www.fpcomplete.com/blog/when-rust-is-safer-than-haskell",
      "date_published": "2019-01-17T18:09:09+00:00",
      "author": {
        "name": "Michael Snoyman",
        "url": "https://www.fpcomplete.com/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "97ace8ce-4c4f-442d-bab3-10a97bd119df",
      "title": "Announcing Rust 1.32.0",
      "content_text": "Rust 1.32.0 has a few quality of life improvements, switches the default allocator, and makes additional functions const.",
      "url": "https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html",
      "date_published": "2019-01-17T00:00:00+00:00",
      "author": {
        "name": "The Rust Release Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "85502039-9617-4e25-a34d-2e1f8cd2f452",
      "title": "Closures: Magic Functions",
      "content_text": "Closures seem like magical functions. They can do magic like capture their environment, which normal functions can‚Äôt do. How does this work?",
      "url": "https://krishnasannasi.github.io/rust/syntactic/sugar/2019/01/17/Closures-Magic-Functions.html",
      "date_published": "2019-01-17T19:00:00+00:00",
      "author": {
        "name": "Krishna Sannasi",
        "url": "https://krishnasannasi.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2afd97b3-7b60-4a21-b07a-7f353a23dc4d",
      "title": "Polonius and region errors",
      "content_text": "Now that NLL has been shipped, I‚Äôve been doing some work revisiting the Polonius project. Polonius is the project that implements the ‚Äúalias-based formulation‚Äù described in my older blogpost. Polonius has come a long way since that post; it‚Äôs now quite fast and also experimentally integrated into rustc, where it passes the full test suite.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/",
      "date_published": "2019-01-17T00:00:00-05:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b4d25622-7886-48c7-901c-e382c05122cb",
      "title": "Exploring Column-Oriented Data in Rust with frunk HLists",
      "content_text": "Row-oriented storage and column-oriented storage are two major ways of laying out data in memory. In Rust, there is a simple way to think of this: row-oriented storage is like an array of structs, whereas column-oriented storage is like a struct of arrays. It‚Äôs easy to use row-oriented storage in Rust, so this post is going to explore column-oriented storage.",
      "url": "https://paulkernfeld.com/2019/01/13/frunk-column.html",
      "date_published": "2019-01-13T00:00:00+00:00",
      "author": {
        "name": "Paul Kernfeld",
        "url": "https://paulkernfeld.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "60e20969-d592-4d79-91e8-633409505b03",
      "title": "Proposed Rust community norm for unsafe code",
      "content_text": "Recently cessen asked  people to write their thoughts on Rust community norm for unsafe code. So here it is.",
      "url": "http://sanxiyn.blogspot.com/2019/01/proposed-rust-community-norm-for-unsafe.html",
      "date_published": "2019-01-10T19:03:00.002+09:00",
      "author": {
        "name": "Seo Sanghyeon",
        "url": "http://sanxiyn.blogspot.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2eb4baa4-aac1-4bc2-8162-d2eb290a1ac9",
      "title": "Generate Rust tests from data files",
      "content_text": "Sometimes you just have a bunch of example data laying around and you want to make sure your code works with all of them. Some of them are probably short and sweet and could live happily as doctests, which are amazing btw. But some of them are more awkward to present in such form, because, for example, of their size or number. Typically when you have an example of how the program should behave you write an example-based unit test. Ideally, each of them would represent an isolated example and they should fail independently. But, converting your source data files into a unit test one by one, manually, can be a bit tedious. Rust build scripts to the rescue !",
      "url": "https://blog.cyplo.net/posts/2018/12/generate-rust-tests-from-data.html",
      "date_published": "2018-12-25T00:00:00+00:00",
      "author": {
        "name": "Cyryl P≈Çotnicki",
        "url": "https://blog.cyplo.net/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0b01d8d7-aa94-4382-8fbf-c2979f7018ad",
      "title": "Scala Developer Journey into Rust - Part 2 : Type Inference",
      "content_text": "Rust is one of the major programming languages that‚Äôs been getting popular in recent years. It has many advanced high level language features like Scala.This made me interested to learn Rust. So in this next series of blogs I will share my experience with Rust from a Scala developer point of view. I would like to explore how these two language approach things. I would like to explore the similarities and their differences.",
      "url": "http://blog.madhukaraphatak.com/rust-scala-part-2/",
      "date_published": "2019-01-14T00:00:00+00:00",
      "author": {
        "name": "Madhukara Phatak",
        "url": "http://madhukaraphatak.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "dfbac96b-1ab3-48a8-9c50-917188335ddd",
      "title": "const types, traits and implementations in Rust",
      "content_text": "Rust permits a limited form of compile-time function execution in the form of const and const fn. While, initially, const may seem like a reasonaby straightforward feature, it turns out to raise a wealth of interesting and complex design questions. In this post, we‚Äôre going to look at a particular design question that has been under discussion for some time and propose a design that is natural and expressive. This is motivated both from a syntactic perspective and a theoretic perspective.",
      "url": "https://varkor.github.io/blog/2019/01/11/const-types-traits-and-implementations-in-Rust.html",
      "date_published": "2019-01-11T19:02:40+00:00",
      "author": {
        "name": "varkor",
        "url": "https://varkor.github.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5c15ca59-eba1-43d8-9dd4-206f574826cf",
      "title": "Understanding Rust Lifetimes",
      "content_text": "No, seriously, this time for real.",
      "url": "https://medium.com/nearprotocol/understanding-rust-lifetimes-e813bcd405fa",
      "date_published": "2019-01-10T01:26:26.038+00:00",
      "author": {
        "name": "Maksym Zavershynskyi",
        "url": "https://medium.com/@zaver.max"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "54ecd8fa-cc4f-4c5f-acef-fc75e1e6ce7f",
      "title": "Librsvg is almost rustified now",
      "content_text": "Since a few days ago, librsvg's library implementation is almost 100% Rust code. Paolo Borelli's and Carlos Mart√≠n Nieto's latest commits made it possible. What does \"almost 100% Rust code\" mean here?",
      "url": "https://people.gnome.org/~federico/blog/librsvg-is-almost-rustified.html",
      "date_published": "2019-01-10T12:28:11-06:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fa5229de-d279-44c7-9d62-0163e7dc1771",
      "title": "Rust Community Norms for Unsafe Code",
      "content_text": "I recently released Ropey 1.0, a text rope library for Rust. Ropey uses unsafe code internally, and its use of unsafe unsurprisingly came up in the 1.0 release thread on Reddit.\n\nThe ensuing discussion (especially thanks to Shnatsel) helped me significantly reduce the amount of unsafe code in Ropey with minimal (though not non-existent) performance degradation. But the whole thing nevertheless got me thinking about unsafe code and community norms around it, and I figured writing some of those thoughts down might be useful.",
      "url": "https://blog.cessen.com/post/2019_01_09_rust_community_norms_for_unsafe_code",
      "date_published": "2019-01-09T00:00:00+00:00",
      "author": {
        "name": "Nathan Vegdahl",
        "url": "https://blog.cessen.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "916f96ed-c1cc-4955-ade6-626b3ebf08bd",
      "title": "Building a JS Interpreter in Rust ‚Äì Part 2",
      "content_text": "When writing an interpreter or a compiler for any language, you usually need to start with a lexer and a parser. Boa here is no different, our first task will be to do the same but what do these do?",
      "url": "https://jason-williams.co.uk/building-a-js-interpreter-in-rust-part-2/",
      "date_published": "2019-01-02T00:00:00+00:00",
      "author": {
        "name": "Jason Williams",
        "url": "https://jason-williams.co.uk/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a46b1128-605b-4cab-b36f-5766125ba2f3",
      "title": "Comparing Rust and JavaScript Ergonomics with a Simple Linked List",
      "content_text": "My day-to-day work involves writing a fair bit of JavaScript but, lately, I've gotten really interested in Rust. The other day, I decided to take a slightly different approach: I decided to take a simple linked list program‚Äîthe type can and do ask my students to implement in JavaScript in ~20 minutes‚Äîand re-implement it in Rust. Specifically, I decided to build a queue implemented with a singly linked list.",
      "url": "https://www.codesections.com/blog/javascript-vs-rust-linked-list/",
      "date_published": "2019-01-06T00:00:00+00:00",
      "author": {
        "name": "Daniel Long Sockwell",
        "url": "https://www.codesections.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "470de398-add8-4fdd-9b38-c79c781c58fa",
      "title": "Deriving Traits in Rust with Procedural Macros",
      "content_text": "Procedural macros in Rust are a really compelling feature that I didn‚Äôt understand until recently. There are a few gotchas, but they make it super easy to implement custom #[derive()] expansions for implementing traits with a single line of code. Let‚Äôs dive in.",
      "url": "https://naftuli.wtf/2019/01/02/rust-derive-macros/",
      "date_published": "2019-01-02T00:00:00+00:00",
      "author": {
        "name": "Naftuli Kay",
        "url": "https://naftuli.wtf/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ff73c006-4009-4e7b-9405-7d4ea2b3c08d",
      "title": "Propagating Errors",
      "content_text": "Lately, I have been converting the code in librsvg that handles XML from C to Rust. For many technical reasons, the library still uses libxml2, GNOME's historic XML parsing library, but some of the callbacks to handle XML events like start_element, end_element, characters, are now implemented in Rust. This has meant that I'm running into all the cases where the original C code in librsvg failed to handle errors properly; Rust really makes it obvious when that happens.\n\nIn this post I want to talk a bit about propagating errors. You call a function, it returns an error, and then what?",
      "url": "https://people.gnome.org/~federico/blog/propagating-errors.html",
      "date_published": "2018-11-21T13:58:12-06:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "793ef59c-ee13-4673-a06b-e65d461e7b1c",
      "title": "What is 'Placement New' in Rust?",
      "content_text": "Placement new is a feature currently being discussed for the Rust programming language. It gives programmer control of memory allocation and memory placement, where current memory allocation implementations are hidden behind compiler internals via the Box::new interface. This is Rust‚Äôs answer to C++ placement new, allowing one to control not only when and how memory is freed, but also where it is allocated and freed from.",
      "url": "http://blakesmith.me/2018/12/31/what-is-placement-new-in-rust.html",
      "date_published": "2018-12-31T00:00:00+00:00",
      "author": {
        "name": "Blake Smith",
        "url": "http://blakesmith.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "152067d5-472f-4ba2-9429-6a5de749bf99",
      "title": "Barriers and Two-phase Borrows in Stacked Borrows",
      "content_text": "My internship (‚Äúresearch assistantship‚Äù) with Mozilla has ended several weeks ago, and this post is a report of the most recent tweaks I made to Miri and Stacked Borrows. Neither project is by any means ‚Äúdone‚Äù, of course. However, both have reached a fairly reasonable state, so I felt some kind of closing report made sense. Also, if I ever want to finish my PhD, I‚Äôll have to seriously scale down the amount of time I work on Rust ‚Äì so at least from my side, things will move more slowly from now on.\n\nIn particular, installing Miri and running your test suite in it is now just a single command away! Scroll all the way down if you are not interested in the rest.",
      "url": "https://www.ralfj.de/blog/2018/12/26/stacked-borrows-barriers.html",
      "date_published": "2018-12-26T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "bddc8eb0-f2db-4330-87fa-2eca9a68e9e5",
      "title": "Currying in rust Part 3 (The circle of life ... aka why borrowchecker ... why?!)",
      "content_text": "Today we're going to take a look at the 'pipe' function my friend has written and why all of the sudden lifetimes get important esp. when using references.",
      "url": "https://hashnode.com/post/currying-in-rust-part-3-the-circle-of-life-aka-why-borrowchecker-why-cjq3z1dd800dknds1sls4dqav",
      "date_published": "2018-12-25T16:35:00+00:00",
      "author": {
        "name": "j",
        "url": "https://github.com/chilimatic"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0a14c8b2-c25a-4733-9682-e1cc71567cc9",
      "title": "Handling failure in Rust",
      "content_text": "I‚Äôve begun to seriously dig into the Rust programming language. The learning curve is real, but I already appreciate the work they‚Äôve put into ergonomics. I‚Äôm writing a simple photo thumbnail endpoint using the Rocket web framework (v0.4) and Image library (v0.20.1). My first pass used a lot of unwrapping to ignore potential errors. A lot can go wrong, even in this ‚Äúsimple‚Äù case. Rocket catches any panics thrown by route handlers, so this is about as robust as a naive equivalent in most other languages. However, Rust at least forces us to be explicit and purposeful about when we want to be sloppy. This is great for a first quick and dirty pass, but we can do much better.",
      "url": "https://esimmler.com/handling-failure-in-rust/",
      "date_published": "2018-12-26T00:00:00+00:00",
      "author": {
        "name": "Erik Simmler",
        "url": "https://esimmler.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5e9ee3df-617a-4a7c-b8bd-ade701971b10",
      "title": "Methods for Array Initialization in Rust",
      "content_text": "Arrays in Rust are fixed size, and Rust requires that every element in an array is initialized to a valid value when the array is initialized. The result of these requirements is array initialization in Rust is a much deeper topic then it would seem.",
      "url": "https://www.joshmcguigan.com/blog/array-initialization-rust/",
      "date_published": "2018-12-22T00:00:00+00:00",
      "author": {
        "name": "Josh Mcguigan",
        "url": "https://www.joshmcguigan.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "04d1c753-5242-4aa9-bff7-500a717a62bc",
      "title": "A Rusty Advent of Code",
      "content_text": "For the first time, I took part in the Advent of Code this year. If you haven't heard of it, it's a daily programming challenge that can be solved in any programming language. Rust was very present in the Advent of Code community with people contributing a ton of Rust-related content. In the daily solutions thread on the /r/aoc subreddit, there were always several Rust solutions posted. Advent of Code really helps show off the things that make Rust shine, demonstrating the power and utility of many community-created crates as well as the language itself.",
      "url": "https://cprimozic.net/blog/a-rusty-aoc/",
      "date_published": "2018-12-27T00:00:00+00:00",
      "author": {
        "name": "Casey Primozic",
        "url": "https://cprimozic.net/blog/"
      },
      "tags": [
        "Language",
        "Performance"
      ]
    },
    {
      "id": "fe9a3482-44e2-48d3-8728-0a15b4d2fd48",
      "title": "async-io-demo: Rust asynchronous io: from mio to stackless coroutine",
      "content_text": "2019 is approaching. The rust team keeps their promise about asynchronous IO: async is introduced as keywords, Pin, Future, Poll and await! is introduced into standard library. I have never used rust for asynchronous IO programming earlier, so I almost know nothing about it. However, I would use it for a project recently but couldn't find many documents that are remarkably helpful for newbie of rust asynchronous programming. My purpose of writing this blog is to review and summarize, I will be happy if it can help someone who are interested in rust asynchronous programming.",
      "url": "https://github.com/Hexilee/async-io-demo",
      "date_published": "2018-12-26T00:00:00+00:00",
      "author": {
        "name": "Li Chenxi",
        "url": "https://github.com/Hexilee"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0717e76b-2097-4ee0-87b1-5f6cffadbdf0",
      "title": "On Rust",
      "content_text": "Back in 2013, I started a series of posts on programming languages I found interesting. One of the languages I wanted to write about at that time was Rust. As often happens, life got in the way, and it‚Äôs only now, in the twilight of 2018 I‚Äôm coming round to a long overdue post.",
      "url": "https://dehora.net/journal/2018/12/23/on-rust",
      "date_published": "2018-12-23T16:34:59+00:00",
      "author": {
        "name": "Bill de h√ìra",
        "url": "https://dehora.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "deb0916b-c8e3-47b1-b957-bfa8015b73ff",
      "title": "Six years with Rust",
      "content_text": "This past year was‚Ä¶ intense. Rust 1.31 was basically Rust 2.0, at least in the marketing sense. I burned myself out getting the first edition of the book together for Rust 1.0, and I burned myself out getting the edition shipped.\n\nLet‚Äôs talk about the bad and the good. Bad first so we end on the high notes.",
      "url": "https://words.steveklabnik.com/six-years-with-rust",
      "date_published": "2018-12-21T00:00:00+00:00",
      "author": {
        "name": "Steve Klabnik",
        "url": "https://words.steveklabnik.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7dd6ca97-374d-4c01-86fb-f3fed29bb6f6",
      "title": "Visualizing Crates.io",
      "content_text": "Visualizing Rust's growing ecosystem through crates.io, Rust's central package repository.",
      "url": "https://8-p.info/visualizing-crates-io/",
      "date_published": "2018-12-23T12:06:00+00:00",
      "author": {
        "name": "Kazuyoshi Kato",
        "url": "https://8-p.info/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a4b9f89c-49bd-4910-b1c6-de1c0da5786c",
      "title": "Managing Rust Dependencies with Nix, Part I",
      "content_text": "Learn how to integrate Rust Cargo package manager with the Nix package manager.",
      "url": "https://www.hadean.com/blog/managing-rust-dependencies-with-nix-part-i",
      "date_published": "2018-11-15T16:03:00+00:00",
      "author": {
        "name": "James Kay",
        "url": "https://www.hadean.com/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e01f334f-a14e-4a54-b7d7-76c9cc6ccdc7",
      "title": "Procedural Macros in Rust 2018",
      "content_text": "Perhaps my favorite feature in the Rust 2018 edition is procedural macros. Procedural macros have had a long and storied history in Rust (and will continue to have a storied future!), and now is perhaps one of the best times to get involved with them because the 2018 edition has so dramatically improved the experience both defining and using them.\n\nHere I'd like to explore what procedural macros are, what they're capable of, notable new features, and some fun use cases of procedural macros. I might even convince you that this is Rust 2018's best feature as well!",
      "url": "https://blog.rust-lang.org/2018/12/21/Procedural-Macros-in-Rust-2018.html",
      "date_published": "2018-12-21T00:00:00+00:00",
      "author": {
        "name": "Alex Crichton",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3f750cea-55f1-44cf-b965-b3a2803de32b",
      "title": "Creating an empty iterator of a certain type in Rust",
      "content_text": "I am working these days on the development of offst's Index server. I needed to implement a basic directed graph structure, allowing to run the BFS algorithm to find routes with a certain amount of capacity. During the work on the Index server I had the problem of wanting to return an empty iterator in an early flow of a function.",
      "url": "https://www.freedomlayer.org/offst/option-iterator/",
      "date_published": "2018-12-15T00:00:00+00:00",
      "author": {
        "name": "Freedomlayer",
        "url": "https://www.freedomlayer.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d4acf845-6f69-4f54-bd37-96d62f83a54c",
      "title": "Yet another Rust 2018 wishlist",
      "content_text": "The 2018 year brought a lot of incredible new features and I'm impressed with all the work that was put in to make the 2018 edition happen. I want to join the other users asking for 2019 to be a year we adjust to all the new changes and focus on cleaning and polishing, not entirely new projects*. For the upcoming year I'd like to see progress on compilation speed and maintenance attention in the library ecosystem.",
      "url": "https://www.reddit.com/r/rust/comments/a5q7eb/yet_another_rust_2018_wishlist/",
      "date_published": "2018-12-13T15:38:32+11:00",
      "author": {
        "name": "u/Saefroch",
        "url": "https://www.reddit.com/user/Saefroch"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "dd6ec508-904b-4cd2-96ca-3df2ed99b074",
      "title": "Rust 2019 - my 2¬¢",
      "content_text": "I will not be really original here, but I really hope to see the following features to land on stable in 2019: const generics, async/await, GATs, inherent traits, minimum supported Rust version:",
      "url": "https://www.reddit.com/r/rust/comments/a5s024/rust_2019_my_2/",
      "date_published": "2018-12-13T20:24:49+11:00",
      "author": {
        "name": "u/newpavlov",
        "url": "https://www.reddit.com/user/newpavlov"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a02deaa2-0f75-48c6-86ef-f6a314be6355",
      "title": "Rust 2019",
      "content_text": "In 2019, there are three areas where I would like to see the Rust community focus its efforts: Improved compile times, A community effort to review crates, More ‚Äú80% solutions‚Äù.",
      "url": "https://vfoley.xyz/rust-2019/",
      "date_published": "2018-12-09T00:00:00+00:00",
      "author": {
        "name": "Vincent Foley",
        "url": "http://vfoley.xyz/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c02900f4-a733-4865-980c-3c139ffe0ac8",
      "title": "Storing unboxed trait objects in Rust",
      "content_text": "This blog post will outline the creation of dynstack, a stack datastructure that stores trait objects unboxed to minimize the number of heap allocations necessary.",
      "url": "https://guiand.xyz/blog-posts/unboxed-trait-objects.html",
      "date_published": "2018-11-10T00:00:00+00:00",
      "author": {
        "name": "Gui Andrade",
        "url": "https://guiand.xyz/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6bf8dccd-51b6-4dcb-a9eb-e38923d28a2c",
      "title": "Bootstrapping Rust",
      "content_text": "It has been a long-standing tradition to develop a language far enough to be able to write the language's compiler in the same language, and Rust does the same. Rust is nowadays written in Rust. We've tracked down the earlier Rust versions, which were written in OCaml, and were planning to use these to bootstrap Rust. But in parallel, John Hudge (Mutabah) developed a Rust compiler, called \"mrustc\", written in C++. mrustc is now good enough to compile Rust 1.19.0. Using mrustc, we were able to build Rust entirely from source with a bootstrap chain",
      "url": "https://www.gnu.org/software/guix/blog/2018/bootstrapping-rust/",
      "date_published": "2018-12-11T00:00:00+00:00",
      "author": {
        "name": "Danny Milosavljevic",
        "url": "https://www.gnu.org/software/guix/blog/"
      },
      "tags": [
        "Language",
        "Operating Systems"
      ]
    },
    {
      "id": "823c892a-d7a2-4185-b80f-ba0b47899b25",
      "title": "How I Wrote a Modern C++ Library in Rust",
      "content_text": "Since version 56, Firefox has had a new character encoding conversion library called encoding_rs. It is written in Rust and replaced the old C++ character encoding conversion library called uconv that dated from early 1999. Initially, all the callers of the character encoding conversion library were C++ code, so the new library, despite being written in Rust, needed to feel usable when used from C++ code. In fact, the library appears to C++ callers as a modern C++ library. Here are the patterns that I used to accomplish that.",
      "url": "https://hsivonen.fi/modern-cpp-in-rust/",
      "date_published": "2018-12-03T00:00:00+00:00",
      "author": {
        "name": "Henri Sivonen",
        "url": "https://hsivonen.fi/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4fe3c55c-a091-40c2-ada0-8c5d371afc31",
      "title": "Existential types in Rust",
      "content_text": "The Rust project I am working on is a caching layer, currently backed by Redis, and it came to a point where I needed to leverage pipelining. On its own, pipelining is straightforward as the redis crate implements it already. However all notions of a cache in our code are abstracted out behind a trait so we can have alternative implementations, such as an in-memory HashMap-backed implementation.\n\nThe problem arises with representing the pipeline in code. It would force any implementation of our cache to Redis‚Äôs notion of a pipeline. Not only would this make it difficult to introspect during testing, but it would also be nonsensical for our HashMap-backed cache. My usual answer to this in languages that support higher-kinded types is to use tagless-final algebras, but Rust‚Äôs type system currently doesn‚Äôt support higher-kinded types1. Fortunately, there is a pretty good alternative that Rust does support: existential types.",
      "url": "https://adelbertc.github.io/posts/2018-12-10-rust-existentials.html",
      "date_published": "2018-12-10T00:00:00+00:00",
      "author": {
        "name": "Adelbert Chang",
        "url": "https://adelbertc.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9303577c-bd85-4bfa-9b0c-30685300155c",
      "title": "Inside Rust‚Äôs Async Transform",
      "content_text": "As you likely know if you‚Äôre reading this post Rust has an upcoming async/await feature being tested in nightly. Because of Rust‚Äôs unique features and positioning fully understanding the implementation powering this syntax is very different to understanding other well-known implementations (C# and JavaScript‚Äôs being the ones I am familiar with). Instead of thinking of a CPS-like transform where an async function is split into a series of continuations that are chained together via a Future::then method, Rust instead uses a generator/coroutine transform to turn the function into a state machine (C# and probably most JavaScript implementations use a similar transform under the hood, but as far as I‚Äôm aware because of the garbage collector these are indistinguishable from the naive CPS transform they are normally described as). For more detail on why Rust is taking this approach you should read eRFC 2033: Experimental Coroutines, that lays out the why‚Äôs much better than I could here.\n\nWhat I‚Äôm going to try and provide instead, is a look into how this actually works today. What steps the compiler takes to turn an async fn into a normal function returning a state machine that you could write if you wanted to (but you definitely don‚Äôt).",
      "url": "https://blag.nemo157.com/2018/12/09/inside-rusts-async-transform.html",
      "date_published": "2018-12-09T00:00:00+00:00",
      "author": {
        "name": "Wim Looman",
        "url": "https://blag.nemo157.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2b4ef111-3f3b-416d-b94d-55fe01a94455",
      "title": "More on RLS version numbering",
      "content_text": "In a few days the 2018 edition is going to roll out, and that will include some new framing around Rust's tooling. We've got a core set of developer tools which are stable and ready for widespread use. We're going to have a blog post all about that, but for",
      "url": "https://www.ncameron.org/blog/more-on-rls-version-numbering/",
      "date_published": "2018-12-04T03:00:20+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b9206a7e-5ee3-4336-b756-afab50e9992f",
      "title": "Debugging Cargo Test",
      "content_text": "While developing some crates in rust, I ran into a few crashes in certain situations when using these crates from another application. In order to more easily reproduce the problem, and also minimize or eliminate future regressions, I decided to write some unit tests for these issues, and use them to more easily debug the problems‚Ä¶ or so I thought!",
      "url": "https://www.wihlidal.com/blog/general/2018-12-07-debugging-cargo-test/",
      "date_published": "2018-12-07T00:00:00+00:00",
      "author": {
        "name": "Graham Wihlidal",
        "url": "https://www.wihlidal.com/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3234baba-f03d-467c-b032-d7d0dec7a12d",
      "title": " A call for Rust 2019 Roadmap blog posts",
      "content_text": "Starting today and running until of January 15, we‚Äôd like to ask the community to write blogposts reflecting on Rust in 2018 and proposing goals and directions for Rust in 2019.",
      "url": "https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html",
      "date_published": "2018-12-06T00:00:00+00:00",
      "author": {
        "name": "The Rust Community Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language",
        "Rust 2019"
      ]
    },
    {
      "id": "a9fa887f-3615-45d9-ab2d-d400d30f1039",
      "title": "Rust 2018 is here‚Ä¶ but what is it?",
      "content_text": "Starting today, the Rust 2018 edition is in its first release. With this edition, we‚Äôve focused on making Rust developers as productive as they can be. But beyond that, it can be hard to explain exactly what Rust 2018 is.",
      "url": "https://hacks.mozilla.org/2018/12/rust-2018-is-here/",
      "date_published": "2018-12-06T16:13:55+00:00",
      "author": {
        "name": "Lin Clark",
        "url": "https://hacks.mozilla.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "18cf1853-dbff-4634-8045-fbcaf36bd4fc",
      "title": " Announcing Rust 1.31 and Rust 2018",
      "content_text": "The Rust team is happy to announce a new version of Rust, 1.31.0, and \"Rust 2018\" as well. Rust is a programming language that empowers everyone to build reliable and efficient software.",
      "url": "https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html",
      "date_published": "2018-12-06T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "400c4c0d-78d0-41fe-bd07-c4a720ade708",
      "title": "Haskell and Rust",
      "content_text": "Learn more about how the Rust programming language shares many of the advantages offered by Haskell such as a strong type system, great tooling, polymorphism, immutability, concurrency, and great software testing methodologies.  Rust is a good choice when you need to squeeze in extra performance.",
      "url": "https://www.fpcomplete.com/blog/2018/11/haskell-and-rust",
      "date_published": "2018-11-26T17:33:00+00:00",
      "author": {
        "name": "Chris Allen",
        "url": "https://www.fpcomplete.com/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5a0c9b1f-c433-44e6-947e-74076725fc32",
      "title": "Rust Flow, Part Two",
      "content_text": "Rust doesn‚Äôt have a language-level concept of generic mutability, which makes ‚Äúmethod threading‚Äù (which take `self` by some handle, and return it in the same way) hard to write. This article covers how to write in that pattern in a less painful way.",
      "url": "https://myrrlyn.net/blog/misc/rust-flow-part-two",
      "date_published": "2018-11-29T00:00:00+00:00",
      "author": {
        "name": "Alexander Payne",
        "url": "https://myrrlyn.net/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6afc7e52-af6d-4ecd-a5af-fb9e27a6ccf6",
      "title": "A new look for rust-lang.org",
      "content_text": "Today, we‚Äôd like to announce a beta of the new rust-lang.org. If you go to https://beta.rust-lang.org, you‚Äôll see a preview of the new site.",
      "url": "https://blog.rust-lang.org/2018/11/29/a-new-look-for-rust-lang-org.html",
      "date_published": "2018-11-29T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c1afc363-1078-4dbd-a3e4-e0f05f255d62",
      "title": "Getting started with nightly async/await support",
      "content_text": "Following on from my last post, I thought I would look at async/await support in Rust. The async/await support coming to Rust brings with it a much more ergonomic way to work with asynchronous computations. In this post I'll introduce std::future::Future, and run through how to make use of them, and how to interoperate with the current ecosystem which is built around version 0.1 of the futures package.",
      "url": "https://jsdw.me/posts/rust-asyncawait-preview/",
      "date_published": "2018-11-26T00:00:00+00:00",
      "author": {
        "name": "James Wilson",
        "url": "https://jsdw.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8c1f73a9-291c-4aa2-9e50-2cf4538f36db",
      "title": "Rust Quiz",
      "content_text": "Test your Rust knowledge with tricky Rust questions.",
      "url": "https://dtolnay.github.io/rust-quiz/",
      "date_published": "2018-11-29T00:00:00+00:00",
      "author": {
        "name": "David Tolnay and Alex Crichton",
        "url": "https://dtolnay.github.io/rust-quiz/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5ed5c8fa-d94a-44ab-836b-35ee61f1f048",
      "title": "Rust Survey 2018 Results",
      "content_text": "Another year means another Rust survey, and this year marks Rust‚Äôs third annual survey. This year, the survey launched for the first time in multiple languages. In total 14 languages, in addition to English, were covered. The results from non-English languages totalled 25% of all responses and helped pushed the number of responses to a new record of 5991 responses. Before we begin the analysis, we just want to give a big ‚Äúthank you!‚Äù to all the people who took the time to respond and give us your thoughts. It‚Äôs because of your help that Rust will continue to improve year after year.",
      "url": "https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html",
      "date_published": "2018-11-27T00:00:00+00:00",
      "author": {
        "name": "The Rust Survey Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ed652ceb-f7cd-4566-b37c-757f6d089240",
      "title": "Rust Language Cheat Sheet",
      "content_text": "This is the \"Rust Language Cheat Sheet\". It is for users who: are early Rust professionals (experienced programmers, intermediate Rust users), and prefer visual, example-driven content. Use cases, in order of priority: \"identification guide\" for unknown or symbolic constructs encountered in code. Provide further reading from easy to advanced (Book to Nomicon). Quick lookup for language related problems. Discover constructs in the language you might not know.",
      "url": "https://cheats.rs/",
      "date_published": "2018-11-28T00:00:00+00:00",
      "author": {
        "name": "Ralf Biedert",
        "url": "https://xr.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c9fdbd06-59fd-444f-b7a9-cd238817a72f",
      "title": "Still in love with Rust",
      "content_text": "I think I've discovered Rust somewhere around the year 2012. With time I grew more and more fond of Rust. The language kept evolving in a direction that was my personal sweet spot: a modern C. And at some point I realized I'm in love with Rust. And I still am today, after a couple of years of using it. So let me tell you why is Rust my darling programming language.",
      "url": "https://dpc.pw/still-in-love-with-rust",
      "date_published": "2018-11-06T07:38:10+00:00",
      "author": {
        "name": "Dawid Ciƒô≈ºarkiewicz aka `dpc`",
        "url": "http://dpc.pw/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "22495ae4-a7be-4899-92ab-ede35669df1b",
      "title": "Converting AsyncRead and AsyncWrite to Futures, Sinks and Streams",
      "content_text": "Prior to this experience, I had thought that Futures, Sinks and Streams were the smallest building blocks in the world of Tokio, and so I went looking through the Tokio documentation for these things. Actually, all of the fundamental objects to read and write bytes to things implement one or both of AsyncRead and AsyncWrite, but not the Future, Sink or Stream traits. In fact, there are lots of poll_x methods dotted around, so I realised I needed to figure out how to make use of them.",
      "url": "https://jsdw.me/posts/rust-futures-tokio/",
      "date_published": "2018-11-25T00:00:00+00:00",
      "author": {
        "name": "James Wilson",
        "url": "https://jsdw.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "40ed3562-277a-453f-84a6-29ab5314ed0c",
      "title": "Programming Servo: A background-hang-monitor",
      "content_text": "Let‚Äôs say you‚Äôre contributing to a system in Rust consisting of a bunch of different components, running in their own threads or processes, for example an engine to make the Web run.\n\nWhen one of those components seemingly hangs on something, how can you find out what it is hanging on? Maybe a backtrace of what that component is doing at that time would be useful?\n\nThat‚Äôs easy, for that we have thebacktrace-rs crate, right?\n\nWell, there‚Äôs a catch: how do we call Backtrace::new() from a thread that is hanging?",
      "url": "https://medium.com/programming-servo/programming-servo-a-background-hang-monitor-73e89185ce1",
      "date_published": "2018-11-16T12:30:06.212+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "24375765-7fa7-4729-8b69-734c409c47fb",
      "title": "Compile Time Feature Flags in Rust",
      "content_text": "Toggling feature flags when you compile for zero runtime cost",
      "url": "https://www.worthe-it.co.za/programming/2018/11/18/compile-time-feature-flags-in-rust.html",
      "date_published": "2018-11-18T00:00:00+00:00",
      "author": {
        "name": "Justin Worthe",
        "url": "http://worthe-it.co.za/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "18ce3041-0f7a-4bf8-8e5a-ccea2a6c8053",
      "title": "Can you Drop it?",
      "content_text": "Resource allocation & the implementation of drop logic in Rust.",
      "url": "http://optimistictypes.com/can-you-drop-it/",
      "date_published": "2018-11-17T00:00:00+00:00",
      "author": {
        "name": "J Haigh",
        "url": "https://debugsteven.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e8b911ca-d007-441e-93e3-d8f1f1b89a00",
      "title": "Program Synthesis is Possible in Rust",
      "content_text": "Program synthesis is the act of automatically constructing a program thatfulfills a given specification. I recently stumbled across Adrian Sampson‚Äôs Program Synthesis is Possible blog post. Adrian describes and implements minisynth, a toy program synthesizer that generates constants for holes in a template program when given a specification. What fun! As a way to learn more about program synthesis myself, I ported minisynth to Rust.",
      "url": "http://fitzgeraldnick.com/2018/11/15/program-synthesis-is-possible-in-rust.html",
      "date_published": "2018-11-15T00:00:00-08:00",
      "author": {
        "name": "Nick Fitzgerald",
        "url": "http://fitzgeraldnick.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4d211c62-3ab3-4db5-a900-94731f798765",
      "title": "Stacked Borrows Implemented",
      "content_text": "Three months ago, I proposed Stacked Borrows as a model for defining what kinds of aliasing are allowed in Rust, and the idea of a validity invariant that has to be maintained by all code at all times. Since then I have been busy implementing both of these, and developed Stacked Borrows further in doing so. This post describes the latest version of Stacked Borrows, and reports my findings from the implementation phase: What worked, what did not, and what remains to be done. There will also be an opportunity for you to help the effort!",
      "url": "https://www.ralfj.de/blog/2018/11/16/stacked-borrows-implementation.html",
      "date_published": "2018-11-16T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "858249f6-6979-48c9-a138-1b7fd2fc9502",
      "title": "Things Rust doesn‚Äôt let you do",
      "content_text": "A survey of things that Rust doesn‚Äôt let you do although arguably safe.",
      "url": "https://medium.com/@GolDDranks/things-rust-doesnt-let-you-do-draft-f596a3c740a5",
      "date_published": "2018-11-12T01:34:25.494+00:00",
      "author": {
        "name": "Pyry Kontio",
        "url": "https://medium.com/@GolDDranks"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c6c90807-5108-434e-9dc0-c5ba8135420d",
      "title": "Truly Zero Cost",
      "content_text": "I know it is claimed how Rust has zero cost abstractions and such and that all these levels of abstractions will just go away in a release build. But there‚Äôs a difference in hearing the theory and seeing it really happen in practice. And I don‚Äôt appreciate it because I‚Äôd consider it magic, but more because I understand how that is being done and it still looks cool.",
      "url": "https://vorner.github.io/2018/11/11/truly-zero-cost.html",
      "date_published": "2018-11-11T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d435191e-e40d-477d-a5ee-908808ee5eee",
      "title": "Rust Flow: Function and Method Sequences in Rust",
      "content_text": "Rust allows for a very functional style of value ‚Äúflow‚Äù without sacrificing the performance of a more traditionally imperative sequence. Furthermore, the functional flow may offer more clarity about value lifetimes and error handling that the imperative sequence might obscure.",
      "url": "https://myrrlyn.net/blog/misc/rust-flow",
      "date_published": "2018-11-11T14:44:00+00:00",
      "author": {
        "name": "Alexander Payne",
        "url": "https://myrrlyn.net/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "125dced7-207a-4c36-904b-3d17c903c508",
      "title": "Optional Arguments in Rust",
      "content_text": "When designing an API for your crate one topic which can come is how to handle optional arguments. Let‚Äôs explore our Options in Rust!",
      "url": "https://hoverbear.org/2018/11/04/optional-arguments/",
      "date_published": "2018-11-04T00:00:00+00:00",
      "author": {
        "name": "Andrew Hobden",
        "url": "https://hoverbear.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "364d5469-2447-49c8-ab4c-e0b82da96f27",
      "title": "Monadic do notation in Rust: Part I",
      "content_text": "Following last time, where we saw that, given parameterision over traits (rather than just types), we could implement functors and monads in Rust that supported existing ‚Äúmonad-like‚Äù traits like Iterator and Future, I thought it would be interesting to tackle another one of the arguments against monads in Rust.",
      "url": "https://varkor.github.io/blog/2018/11/10/monadic-do-notation-in-rust-part-i.html",
      "date_published": "2018-11-10T20:10:56+00:00",
      "author": {
        "name": "varkor",
        "url": "https://varkor.github.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "190265bb-a65b-4acd-99e9-3d6f8a06969c",
      "title": "proc_macro_attribute Revisited",
      "content_text": "Recently, the procedural macro interface was somewhat stabilized. OK, there‚Äôs still the unstable proc_macro_hygiene feature you have to activate, but at least the registrar and rustc_private are no longer needed.",
      "url": "https://llogiq.github.io/2018/11/10/proc-macro.html",
      "date_published": "2018-11-10T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4ace2654-b6a1-4a4a-9917-07f9e12c1ec2",
      "title": "How to get the size of Rust types with -Zprint-type-sizes",
      "content_text": "When optimizing Rust code it‚Äôs sometimes useful to know how big a type is, i.e. how many bytes it takes up in memory. std::mem::size_of can tell you, but often you want to know the exact layout as well. For example, an enum might be surprisingly big, in which case you probably will want to know if, for example, there is one variant that is much bigger than the others.",
      "url": "https://blog.mozilla.org/nnethercote/2018/11/09/how-to-get-the-size-of-rust-types-with-zprint-type-sizes/",
      "date_published": "2018-11-09T03:42:40+00:00",
      "author": {
        "name": "Nicholas Nethercote",
        "url": "https://blog.mozilla.org/nnethercote/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "89cf760b-0385-4e81-ad78-45b7eb3b2aa2",
      "title": "Making progress in await syntax",
      "content_text": "One thing we‚Äôve left as an unresolved question so far in the matter of async/await syntax is the exact final syntax for the await operation. In the current implementation, awaits are written using a compiler plugin:\n\nasync fn foo() {\nawait!(bar());\n}\n\nThis is not because of any technical limitation: the reason we have done this is that we have not decided on the precise, final syntax for the await operation.",
      "url": "https://boats.gitlab.io/blog/post/await-syntax/",
      "date_published": "2018-11-08T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9dae526e-703d-4726-b68c-92f847e3c85f",
      "title": "After NLL: Moving from borrowed data and the sentinel pattern",
      "content_text": "Continuing on with my ‚ÄúAfter NLL‚Äù series, I want to look at another common error that I see and its solution: today‚Äôs choice is about moves from borrowed data and the Sentinel Pattern that can be used to enable them.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/11/10/after-nll-moving-from-borrowed-data-and-the-sentinel-pattern/",
      "date_published": "2018-11-10T00:00:00-05:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "bfe6aa2d-0dbd-4966-81cc-eebed27ca28d",
      "title": "Higher-Order Functions in Rust",
      "content_text": "Rust is an imperative language but it provides many tools in the standard library which adhere to a more functional style, like the Iterator trait and its methods like map, for_each, and filter. This is a quick run-down of how to define your own higher-order functions in Rust which can both take closures as parameters and return closures in such a way that you can use the two together.",
      "url": "https://dev.to/deciduously/higher-order-functions-in-rust-287h",
      "date_published": "2018-11-03T00:00:00+00:00",
      "author": {
        "name": "Ben Lovy",
        "url": "https://dev.to/deciduously"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6e6bbbca-9a60-4c29-a050-1d34f08192ea",
      "title": "A New Way of Thinking",
      "content_text": "Rust was my language of the year. You know, that thing where programmers set out to learn a new programming language every year. Usually not to be productive at it but to familiarize themselves with current trends in language design, implementation, and paradigms. I had heard a lot of good stuff about Rust and decided late last year to make it my 2018 language. I‚Äôm only a few days in but I‚Äôve been smacked by some of what I consider the best ideas in programming I‚Äôve encountered yet.",
      "url": "https://boakye.yiadom.org/rust/new/",
      "date_published": "2018-11-04T23:59:50+00:00",
      "author": {
        "name": "Yaw Boakye",
        "url": "https://boakye.yiadom.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "495a9412-287b-4baf-af46-007603eff49a",
      "title": "A hammer you can only hold by the handle",
      "content_text": "Today we‚Äôre looking at the rust borrow checker from a different perspective. As you may know, the borrow checker is designed to safely handle memory allocation and ownership, preventing accessess to invalid memory and ensuring data-race freedom. This is a form of resource management: the borrow checker is tracking who‚Äôs in charge of a chunk of memory, and who is currently allowed to read or write to it. In this post, we‚Äôll see how these facilities can be used to enforce higher-level API constraints in your libraries and software. Once you‚Äôre familiar with these techniques, we‚Äôll cover how the same principles apply to advanced memory management and handling of other more abstract resources.",
      "url": "https://blog.systems.ethz.ch/blog/2018/a-hammer-you-can-only-hold-by-the-handle.html",
      "date_published": "2018-11-05T00:00:00+00:00",
      "author": {
        "name": "Andrea Lattuada",
        "url": "https://blog.systems.ethz.ch/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "bfd4f2e7-3e44-4383-a144-ae5da7c664fa",
      "title": "After NLL: Interprocedural conflicts",
      "content_text": "In my previous post on the status of NLL, I promised to talk about ‚ÄúWhat is next?‚Äù for ownership and borrowing in Rust. I want to lay out the various limitat...",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/11/01/after-nll-interprocedural-conflicts/",
      "date_published": "2018-11-01T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "dd822196-d8f4-4764-9727-6096581c035a",
      "title": "On dealing with owning and borrowing in public interfaces",
      "content_text": "I‚Äôve been writing on a few examples code lately to add to documentations of some crates of mine. I write a lot of code that creates new objects that need other objects in order to be built. Most of the APIs you can see around tend to love the borrow principle ‚Äì and I do.",
      "url": "https://phaazon.net/blog/on-owning-borrowing-pub-interface",
      "date_published": "2018-11-04T01:30:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7be81fee-ef29-448f-9e03-9be0fc63fbb7",
      "title": "Anchored and Uniform Paths",
      "content_text": "Rust 2018 is almost out the door, but there is one big decision the language team has yet to make. It has to do with the modules and paths system, so of course it is a very easy decision that no one has a strong opinion about. ;-)\nIn Rust 2018, we‚Äôll be making some big changes to how paths work to try to create a more consistent experience. The ‚Äúlodestar‚Äù (if you will) of these changes is an idea we call ‚Äú1path:‚Äù the idea no matter where you are in your project, whether in a use statement or normal code, a path is interpreted the same way.",
      "url": "https://boats.gitlab.io/blog/post/anchored-uniform/",
      "date_published": "2018-11-02T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3c73e50b-c4cd-43ea-9214-49f711bf3058",
      "title": "MIR-based borrowck is almost here",
      "content_text": "Now that the final Rust 2018 Release Candidate has shipped, I thought it would be a good idea to do another update on the state of the MIR-based borrow check (aka NLL). Let‚Äôs get the highlights out of the way. Most importantly, Rust 2018 crates will use NLL by default. Once the Rust 2018 release candidate becomes stable, we plan to switch Rust 2015 crates to use NLL as well, but we‚Äôre holding off until we have some more experience with people using it in the wild.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/10/31/mir-based-borrowck-is-almost-here/",
      "date_published": "2018-10-31T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1f6655e8-89c4-4e30-91e6-776449b88293",
      "title": "Finding and fixing memory leaks in a Hyper application or 'How I Learned to Stop Worrying and Love the Allocator'",
      "content_text": "I was doing some initial load testing of the next version our application, so that performance regressions can be tracked, when I noticed something. After only a few seconds of throwing wrk at it, our backend was using 1.3GB of memory, growing at around 50MB/s. Yikes.",
      "url": "https://blog.1aim.com/2018/10/finding-and-fixing-memory-leaks-in-a-hyper-application-or-how-i-learned-to-stop-worrying-and-love-the-allocator/",
      "date_published": "2018-10-29T00:00:00+00:00",
      "author": {
        "name": "Ferdia McKeogh",
        "url": "https://blog.1aim.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6bf46601-8824-4e8e-b625-f3b6f9d074da",
      "title": "From Rust to beyond: The PHP galaxy",
      "content_text": "This blog post is part of a series explaining how to send Rust beyond earth, into many different galaxies. The galaxy we will explore today is the PHP galaxy. This post will explain what PHP is, how to compile any Rust program to C and then to a PHP native extension.",
      "url": "https://mnt.io/2018/10/29/from-rust-to-beyond-the-php-galaxy/",
      "date_published": "2018-10-29T10:17:12+00:00",
      "author": {
        "name": "Ivan Enderlin",
        "url": "https://mnt.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e5f786a1-6dd9-427f-8202-03b5a38a7ace",
      "title": "My release checklist for Rust programs",
      "content_text": "After some practice with three of my Rust projects (fd, hyperfine and bat), my workflow has converged to something that works quite well and avoids many pitfalls that I have walked into in the past. My hope in writing this post is that this process can be useful for others as well. The following is my release checklist for fd, but I have very similar lists for other projects.",
      "url": "https://dev.to/sharkdp/my-release-checklist-for-rust-programs-1m33",
      "date_published": "2018-10-28T00:00:00+00:00",
      "author": {
        "name": "David Peter",
        "url": "https://dev.to/sharkdp"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "427d9cb0-4562-45c7-b6f0-3defc4df172b",
      "title": "Improving ndarray-csv: Goodbye failure, Hello Extension Traits",
      "content_text": "Two weeks ago, I wrote a blog post explaining some design decisions that I made for the ndarray-csv crate. Based on some excellent Reddit comments and GitHub issues from dtolnay, I have amended some of these decisions.",
      "url": "https://paulkernfeld.com/2018/10/27/improving-ndarray-csv.html",
      "date_published": "2018-10-27T00:00:00+00:00",
      "author": {
        "name": "Paul Kernfeld",
        "url": "https://paulkernfeld.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e64df9c0-3056-4720-837e-670543317c59",
      "title": "Problems Scaling A Large Multi-Crate Rust Project",
      "content_text": "We have 85K lines of Rust code implementing the backend of our Pernosco debugger. To impose some modularity constraints and to reduce build times, from the beginning we organized our code as a large set of crates in a single Cargo workspace in a single Gitlab repository. Currently we have 48 crates. This has mostly worked pretty well but as the number of our crates keeps increasing, we have hit some serious scalability problems.",
      "url": "https://robert.ocallahan.org/2018/10/problems-scaling-large-multi-crate-rust.html?m=1",
      "date_published": "2018-10-25T00:00:00+00:00",
      "author": {
        "name": "Robert O'Callahan",
        "url": "https://robert.ocallahan.org/?m=1"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "451e814b-f0e1-4d88-bdda-9862ab107902",
      "title": "The Case For Macros",
      "content_text": "I know a few Rustaceans who are wary of macros. One privately admitted to hating them with a passion. They are right; macros can make code harder to understand (both for humans and computers, for example many clippy lints have an explicit check to only lint outside of macros), so they should be used with some caution.",
      "url": "https://llogiq.github.io/2018/10/25/macros.html",
      "date_published": "2018-10-25T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3db4746e-d5ac-46c7-af24-a25e2db1b7d2",
      "title": "Announcing Rust 1.30",
      "content_text": "The Rust team is happy to announce a new version of Rust, 1.30.0. Rust 1.30 is an exciting release with a number of features: Procedural Macros, Module system improvements, Raw Identifiers, and more.",
      "url": "https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html",
      "date_published": "2018-10-25T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4c54199d-d367-4525-8202-cba2c82afa3d",
      "title": "Rust has higher kinded types already... sort of",
      "content_text": "In Rust, a type which takes type parameters (Rc<T>, Vec<T>, HashMap<K, V>, etc) is only a valid type when all type parameters are specified. In other words, Rc, Vec, and HashMap<K> are not types. You can‚Äôt have a variable of type Rc. You can‚Äôt pass Rc as a parameter to other types. The ability to have such things be actual types is a feature called higher kinded types (HKT).",
      "url": "https://joshlf.com/post/2018/10/18/rust-higher-kinded-types-already/",
      "date_published": "2018-10-18T00:00:00+00:00",
      "author": {
        "name": "Joshua Liebow-Feeser",
        "url": "https://joshlf.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c2e61957-0d95-43e3-af09-3173307bf95c",
      "title": "Rust's Orphan Rule Is Good, Actually",
      "content_text": "The orphan trait rule in Rust is interesting and works impressively well for what it intends to do. While I'm often frustrated by the limitations it imposes, it absolutely succeeds at removing ambiguity in whether or not a trait will be implemented for a type.",
      "url": "https://davidlegare.ghost.io/rusts-orphan-rule/",
      "date_published": "2018-10-20T05:42:04+00:00",
      "author": {
        "name": "David LeGare",
        "url": "https://davidlegare.ghost.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4f32d4ec-419f-4025-b508-3c486ffb059e",
      "title": "Towards fearless SIMD",
      "content_text": "SIMD is a powerful performance technique, and is especially valuable in signal and image processing applications. I will be using it very extensively in my synthesizer, and also it‚Äôs increasingly used in xi-editor to optimize string comparisons and similar primitives.",
      "url": "https://raphlinus.github.io/rust/simd/2018/10/19/fearless-simd.html",
      "date_published": "2018-10-19T17:03:42+00:00",
      "author": {
        "name": "Raph Levien",
        "url": "https://raphlinus.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b39581e7-2147-4b4a-bfdf-b19141e80d89",
      "title": "Is Rust functional?",
      "content_text": "Rust is an imperative systems programming language. Why does it have so much attention from functional programming advocates? Is it hiding a functional nature?",
      "url": "https://www.fpcomplete.com/blog/2018/10/is-rust-functional",
      "date_published": "2018-10-18T03:02:08+00:00",
      "author": {
        "name": "Michael Snoyman",
        "url": "https://www.fpcomplete.com/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0f56caac-74c9-414c-89d5-fe1cb9a74424",
      "title": "Rust and the Three Laws of Informatics",
      "content_text": "What are the most important properties of programs, and how much do existing languages help? How is Rust different?",
      "url": "https://medium.com/@schemouil/rust-and-the-three-laws-of-informatics-4324062b322b",
      "date_published": "2018-10-09T07:42:09.509+00:00",
      "author": {
        "name": "Simon Chemouil",
        "url": "https://medium.com/@schemouil"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "351bd1f1-82e3-4b80-882e-9b2aac228c5a",
      "title": "Future directions for cbindgen (rust-ffi)",
      "content_text": "There‚Äôs been a persistent set of issues we‚Äôve had with cbindgen that have not been solved. They all roughly result from the same problem; cbindgen is a standalone parser of rust code, not a rustc plugin. What this means is that cbindgen doesn‚Äôt understand your rust library like the compiler does. We‚Äôve tried to minimize the differences here by making cbindgen smarter, but it‚Äôs not obvious that‚Äôs the best approach going forward.",
      "url": "http://dreamingofbits.com/post/future-directions-for-cbindgen-rust-ffi/",
      "date_published": "2018-10-05T00:00:00+00:00",
      "author": {
        "name": "Ryan Hunt",
        "url": "http://dreamingofbits.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "476c5ab3-1148-4507-b294-8e4c06a188fd",
      "title": "Rust and features discoverability",
      "content_text": "Whatever the project you work on, you should must document your code. There are several situations ‚Äì let‚Äôs call this the First Hypothesis",
      "url": "https://phaazon.net/blog/rust-features-documentation",
      "date_published": "2018-10-13T23:37:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e7b5dffe-46bb-42a8-a17c-2ede829080ff",
      "title": "Const-fn compile-time SUBLEQ interpreter",
      "content_text": "With the minimal subset of const fn becoming stable soon (in the second next Rust version), I wanted to give const fns a try and test what is possible with them. We implemented a compile-time SUBLEQ interpreter which only uses const-fns, which you can find on the playground. Let's walk through the process of building this abomination :)",
      "url": "https://www.reddit.com/r/rust/comments/9o6vzo/constfn_compiletime_subleq_interpreter/",
      "date_published": "2018-10-15T09:10:49+11:00",
      "author": {
        "name": "u/oberien",
        "url": "https://www.reddit.com/user/oberien"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "08336620-497d-49b2-9e77-eeb36d26f512",
      "title": "Fixing a Clippy crash",
      "content_text": "3 weeks ago I set out to fix a crash in Clippy, this is what I learned along the way. I hope this blog post will be useful for other people diving into Clippy and maybe serve as motivation if things get difficult.",
      "url": "https://phansch.net/2018/10/10/fixing-a-clippy-crash/",
      "date_published": "2018-10-10T00:00:00+00:00",
      "author": {
        "name": "Philipp Hansch",
        "url": "https://phansch.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "492f5ab9-f95c-480b-8377-dc2f06e836b8",
      "title": "Notes on Type Layouts and ABIs in Rust",
      "content_text": "Over the years I've found myself with a weird amount of knowledge about how types and ABIs in Rust work, and I wanted to write it all down in one place so that... it's written down in one place. Much of this information can or should be found in the Rust Language Reference and the Rustonomicon.",
      "url": "https://gankro.github.io/blah/rust-layouts-and-abis/",
      "date_published": "2018-10-09T00:00:00+00:00",
      "author": {
        "name": "Alexis Beingessner",
        "url": "https://gankro.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ab2b9642-16a3-4d28-9f8b-5f6938964600",
      "title": "Porting C (minimp3) To Rust",
      "content_text": "So because it seemed like a good idea at the time, I decided to port the minimp3 library from C to Rust. I want a pure Rust MP3 decoder crate to exist under a permissive license, I wanted to learn a few things about the MP3 file format, and it seemed small enough to do in a single weekend. (In reality it was largely done in about a week.) I‚Äôm quite good at Rust, and I‚Äôm okay at C (but rusty; hah!), and I know nothing at all about MP3 decoding. So, it was a fun learning experience. It was very interesting seeing how C and Rust‚Äôs different feature set changed how the programs were written. minimp3 turned out to be a good choice for this, since it is standalone, pretty well-written C as far as I can tell, does nothing that needs to be unsafe, and small but not trivial. This article is an attempt to organize my thoughts, notes and observations as I went about the project, in the hopes that it will be useful or at least interesting to someone else.",
      "url": "https://wiki.alopex.li/PortingCToRust",
      "date_published": "2018-10-08T19:53:10+00:00",
      "author": {
        "name": "Simon Heath",
        "url": "http://patreon.com/icefox"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a8939774-cb65-4cca-b7c4-47f8f0249f96",
      "title": "Hunting for Bugs in Rust",
      "content_text": "Way back in August I announced that I was starting in on \"a project to QuickCheck Rust‚Äôs standard library data structures\", here. And I did! The project is called bughunt-rust and I've been poking at it on weekends since, adjusting my approach based on papers I've been reading, experience gained writing test code and the kind of results I've been getting. This post goes through what I've been up to, where I see the project heading in the near term.",
      "url": "https://blog.troutwine.us/2018/10/08/hunting-for-bugs-in-rust/",
      "date_published": "2018-10-08T17:27:54+00:00",
      "author": {
        "name": "Brian L. Troutwine",
        "url": "http://blog.troutwine.us/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a3b6b34c-174b-4738-9c06-c9ab251718c4",
      "title": "Rust has a static garbage collector",
      "content_text": "I‚Äôve often seen people make statements like this one, from the Rust subreddit this morning, \"Manual memory management requires more work than garbage collected. Its a trade off of course to be more performant or use lower resources. When and where should Rust be used or not used according to you?\". While I don‚Äôt completely disagree with this sentiment, it‚Äôs also never quite sat right with me. Yes, Rust is a bit harder at the start, but once you get over a hump, I don‚Äôt generally find writing Rust to be significantly harder than using a GC‚Äôd language. I‚Äôve been trying to figure out why that is.",
      "url": "https://words.steveklabnik.com/borrow-checking-escape-analysis-and-the-generational-hypothesis",
      "date_published": "2018-10-10T00:00:00+00:00",
      "author": {
        "name": "Steve Klabnik",
        "url": "https://words.steveklabnik.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e34760d5-658d-475a-91eb-c489a649ee86",
      "title": "Testing reqwest-based clients",
      "content_text": "In this article we will make a small Rust library that uses the reqwest http client library, and see what we can do to adequately test the business logic. We assume you have the Rust toolchain installed, and are at least passingly familiar with programming in Rust.",
      "url": "https://write.as/balrogboogie/testing-reqwest-based-clients",
      "date_published": "2018-10-05T20:57:27+00:00",
      "author": {
        "name": "balrogboogie",
        "url": "https://write.as/balrogboogie/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fd7f3d68-5d82-41ba-b841-d11a37e4b98d",
      "title": "Declarative Rust static analysis",
      "content_text": "Rust's Macros 2.0 are intuitive: demonstrate a pattern, and the compiler can insert the pattern into your program wherever you want it. Inspired by this syntax, I wondered: Could you ‚Äúrun a macro backwards‚Äù‚Äîuse the same by-example language to describe patterns to search for?",
      "url": "http://blog.lambdaverse.org/comacro/",
      "date_published": "2018-10-07T19:23:17+00:00",
      "author": {
        "name": "Kaz Wesley",
        "url": "http://blog.lambdaverse.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5c9a36df-c260-4d16-87b1-9b7e3107f7b8",
      "title": "Who authors the most popular crates on crates.io?",
      "content_text": "I had a question this morning: who authors the most popular crates on crates.io? First, we have to figure out what we mean by ‚Äúmost popular.‚Äù My first guess was ‚Äútop 100 by recent downloads‚Äù, so I looked at crates.io. Once I got to 100, I found... | Steve Klabnik | ‚ÄúThe most violent element in society is ignorance.‚Äù - Emma Goldman",
      "url": "https://words.steveklabnik.com/who-authors-the-most-popular-crates-on-crates-io",
      "date_published": "2018-10-04T00:00:00+00:00",
      "author": {
        "name": "Steve Klabnik",
        "url": "https://words.steveklabnik.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d7c70ce9-96bc-4518-8e3e-429503883006",
      "title": "Default values¬†..copy that",
      "content_text": "When I talk to folks foreign to Rust, I often get asked the question: ‚ÄúWhy doesn‚Äôt Rust have support for default arguments‚Äù. When I first started learning Rust I pondered the same question. Eventually I came to realize that it does, kind of. Rust just takes different approach based on it‚Äôs unique design choices, one which I now wish other languages supported.",
      "url": "https://medium.com/@softprops/default-values-copy-that-ae43831781f3",
      "date_published": "2018-10-04T17:06:48.457+00:00",
      "author": {
        "name": "Doug Tangren",
        "url": "https://medium.com/@softprops"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "11786513-db52-4fdb-ac03-e4a854b36f2b",
      "title": "Writing Rust NIFs for your Elixir code with the Rustler package",
      "content_text": "There will be times where code will run slow and Erlang/Elixir optimizations will only go so far. BEAM has several ways to interface with foreign code, the fastest way being with a Native Implemented Function (NIF) whose API expects them to be written in C. But speaking frankly, the last time I worked with C involved a lengthy debugging session that boiled down to the lack of type safety, so I‚Äôd rather not have to repeat that experience. It‚Äôs for this reason that Rust is such a compelling language.",
      "url": "https://medium.com/@jacob.lerche/writing-rust-nifs-for-your-elixir-code-with-the-rustler-package-d884a7c0dbe3",
      "date_published": "2018-09-28T01:54:27.302+00:00",
      "author": {
        "name": "Jacob Lerche",
        "url": "https://medium.com/@jacob.lerche"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "cbc812fb-b5ff-44cc-ae96-f4a5ae44e7dd",
      "title": "Announcing the Tokio Doc Push (we need you!)",
      "content_text": "In the past, there has been reoccurring feedback that Tokio is hard to understand. I believe a lack of good documentation plays a significant part. It‚Äôs time to fix this problem.\n\nAnd because Tokio is open source, it is on us (the community) to make this happen! üëè",
      "url": "https://tokio.rs/blog/2018-10-doc-blitz/",
      "date_published": "2018-10-04T00:00:00+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://tokio.rs/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0ec2fec4-ed74-4377-b1f5-1e6a5eec6025",
      "title": "Office Hours #1: Cyclic services",
      "content_text": "This is a report on the second ‚Äúoffice hours‚Äù, in which we discussed how to setup a series of services or actors that communicate with one another. This is a classic kind of problem in Rust: how to deal with cyclic data. Usually, the answer is that the cycle is not necessary (as in this case).",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/09/24/office-hours-1-cyclic-services/",
      "date_published": "2018-09-24T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9128e298-33fe-4f13-a9c7-7ff2361ee2da",
      "title": "An EFI App a bit rusty",
      "content_text": "After two tweets that I made last week, playing around with UEFI and Rust, some people asked to publish a blog post explaining how to create a UEFI application fully written in Rust and demonstrate all the testing environment.",
      "url": "https://medium.com/@gil0mendes/an-efi-app-a-bit-rusty-82c36b745f49",
      "date_published": "2018-09-30T21:56:12.954+00:00",
      "author": {
        "name": "Gil Mendes",
        "url": "https://medium.com/@gil0mendes"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0b2520e8-b69d-4edb-91b1-3558494fd0cd",
      "title": "rust-on-mobile: Example of creating and running a basic \"Hello World\" application on iOS",
      "content_text": "This repo is a place where examples can be added of iOS/android projects written entirely/mostly in rust.",
      "url": "https://github.com/mtak-/rust-on-mobile/blob/master/examples/ios/example01.md",
      "date_published": "2018-09-24T06:09:32+00:00",
      "author": {
        "name": "mtak-",
        "url": "https://github.com/mtak-"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "adea520f-a6b7-43f5-b705-62aefc4c00e6",
      "title": "Announcing Rust 1.29.1",
      "content_text": "A security vulnerability was found in the standard library where if a large number was passed to str::repeat it could cause a buffer overflow after an integer overflow. If you do not call the str::repeat function you are not affected. This has been addressed by unconditionally panicking in str::repeat on integer overflow.",
      "url": "https://blog.rust-lang.org/2018/09/25/Rust-1.29.1.html",
      "date_published": "2018-09-25T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "564060f8-e187-4947-80ca-867ed3762d1b",
      "title": "Office Hours #0: Debugging with GDB",
      "content_text": "This blog post is just going to be a quick summary of the basic workflow of using Rust with gdb on the command line. I‚Äôm assuming you are using Linux here, since I think otherwise you would prefer a different debugger. There are probably also nifty graphical tools you can use and maybe even IDE integrations, I‚Äôm not sure.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/09/21/office-hours-0-debugging-with-gdb/",
      "date_published": "2018-09-21T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a2d3880c-1803-4f4d-8345-b46f2d056985",
      "title": "A Rust FFI adventure in unsafety",
      "content_text": "This blog post covers my adventure in fixing a bug in the Rust bindings for the Capstone C library, a disassembly library that supports several CPU architectures. The capstone-rs crate attempts to provide a Rusty, object-oriented interface. You do not necessarily need previous experience in C code or foreign function (FFI) bindings to understand this blog post. I will cover some of the steps I used to debug this problem. Hopefully, readers can learn from my mistakes.",
      "url": "https://travisf.net/capstone-rs-unsafety-adventure",
      "date_published": "2018-09-21T00:00:00+00:00",
      "author": {
        "name": "Travis Finkenauer",
        "url": "https://travisf.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0e8e1d2a-729c-41b0-953f-e14de11b8c59",
      "title": "Trying to tackle the orphans problem",
      "content_text": "In this blog entry, I want to explore a specific problem of orphans and how I decided to solve it in a crate of mine. The problem is the following: Given a crate that has a given responsibility, how can someone add an implementation of a given trait without having to use a type wrapper or augment the crate‚Äôs scope?",
      "url": "https://phaazon.net/blog/orphans-problem",
      "date_published": "2018-09-20T12:30:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "63b188d7-d82f-425d-9d07-a17d7fdc43f8",
      "title": "How we integrate Rust with C#",
      "content_text": "Seq is a log server that's built using a few programming languages; we have a storage engine called Flare written in Rust, and a server application written in C#. Our language stack is something I've talked about previously.\n\nBetween Rust and C# we have a foreign function interface (FFI) that lets us call out to Rust code from within the .NET runtime. In this post I'd like to explore our approach to FFI between Seq and its storage engine using the API for reading log events as a reference.",
      "url": "https://blog.getseq.net/rust-at-datalust-how-we-integrate-rust-with-csharp/",
      "date_published": "2018-09-18T23:15:06+00:00",
      "author": {
        "name": "Ashley Mannix",
        "url": "https://blog.getseq.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b5f32e7e-843c-40cf-8c6c-126bc74e6c4e",
      "title": "Function composition in Rust using a custom smart pointer",
      "content_text": "Still drunk with the power of function composition, I started to play around with the technique in Rust, a language I've been experimenting with. Rust is a low-level language with a strict compiler that saves you from doing dangerous things. Furthermore, Rust is a functional language. It has several concepts and features inspired by Haskell (read more) and Scala for example. The design of Rust makes it highly expressive and attractive.",
      "url": "https://bsoptei.github.io/",
      "date_published": "2018-09-15T00:00:00+00:00",
      "author": {
        "name": "Bal√°zs S√∂ptei",
        "url": "https://bsoptei.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a64aef93-521d-414e-ae6e-853f147b1180",
      "title": "You can't \"turn off the borrow checker\" in Rust",
      "content_text": "Every once in a while, someone will talk about unsafe in Rust, and how it ‚Äúturns off the borrow checker.‚Äù I think this framing leads to misconceptions about unsafe and how it interacts with safe code. Here‚Äôs some code that causes a borrow checker... | Steve Klabnik | ‚ÄúThe most violent element in society is ignorance.‚Äù - Emma Goldman",
      "url": "https://words.steveklabnik.com/you-can-t-turn-off-the-borrow-checker-in-rust",
      "date_published": "2018-09-14T00:00:00+00:00",
      "author": {
        "name": "Steve Klabnik",
        "url": "https://words.steveklabnik.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "dc9c068f-0a7f-4a31-aec2-f30b51066b89",
      "title": "Announcing Rust 1.29",
      "content_text": "The Rust team is happy to announce a new version of Rust, 1.29.0. The two most significant things in this release aren‚Äôt even language features: they‚Äôre new abilities that Cargo has grown, and they‚Äôre both about lints: cargo fix can automatically fix your code that has warnings. cargo clippy is a bunch of lints to catch common mistakes and improve your Rust code.",
      "url": "https://blog.rust-lang.org/2018/09/13/Rust-1.29.html",
      "date_published": "2018-09-13T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0f587c1a-da0e-46d2-bee3-3a3cc6fc5352",
      "title": "Ownership Explained with Python",
      "content_text": "It‚Äôs not immediately obvious that calling min(squares) modifies squares. If squares were a list or even a range, we would be able to call min and max on it with no problem. It would be nice if the language prevented us from trying to use something twice that can only be used once. Almost all modern languages, both statically and dynamically typed, will fail at runtime in these situations.",
      "url": "https://paulkernfeld.com/2018/09/16/ownership-explained-with-python.html",
      "date_published": "2018-09-16T00:00:00+00:00",
      "author": {
        "name": "Paul Kernfeld",
        "url": "https://paulkernfeld.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b78327e0-5dc5-4187-be6b-9e06204b4631",
      "title": "Lockout, Part 2: And nary a function to be found",
      "content_text": "This is part of a blog series on working towards an intuitive mental model for lifetimes in Rust. When I tried to sit myself down and really, really write down an in-depth example‚Ä¶ I realized that there was no two ways about it. Before you can learn to appreciate why lifetimes exist, you must learn what life would be like without them. And in order to do that, well‚Ä¶",
      "url": "https://exphp.github.io/2018/09/18/lockout-part-2.html",
      "date_published": "2018-09-18T19:00:00+00:00",
      "author": {
        "name": "Michael Lamparski",
        "url": "https://exphp.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6c1f472d-337d-48c0-96d3-807afe8e58e3",
      "title": "Lockout, Part 1: Everything you know about lifetimes is wrong",
      "content_text": "This is part of a blog series on a new way to look at lifetimes in Rust's type system. I hope to cover some advanced aspects of lifetimes that are seldom discussed in the open, and my goal is ultimately to help convey new intuitions about how to use them correctly.",
      "url": "https://exphp.github.io/2018/09/17/lockout-part-1.html",
      "date_published": "2018-09-17T01:00:00+00:00",
      "author": {
        "name": "Michael Lamparski",
        "url": "https://exphp.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7f5b5694-9cda-4692-8cbe-42458122faff",
      "title": "Falling in love with Rust",
      "content_text": "We are living in a Golden Age of software, one that will produce artifacts that will endure for generations. Of course, it can be hard to hold such heady thoughts when we seem to be up to our armpits in vendored flotsam, flooded by sloppy abstractions hastily implemented. Among current languages, only Rust seems to share this aspiration for permanence, with a perspective that is decidedly larger than itself.",
      "url": "http://dtrace.org/blogs/bmc/2018/09/18/falling-in-love-with-rust/",
      "date_published": "2018-09-18T22:31:51+00:00",
      "author": {
        "name": "Bryan Cantrill",
        "url": "http://dtrace.org/blogs/bmc/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "bec949a2-4c38-4646-ae0b-1d8638c506a6",
      "title": "Parallelizing PNG, part 8: Rust macros for constant specialization",
      "content_text": "In my last posts I covered profiling and some tips for optimizing inner loops in Rust code while working on a multithreaded PNG encoder. Rust‚Äôs macro system is another powerful tool for simplifying your code, and sometimes awesomeizing your performance‚Ä¶",
      "url": "https://brionv.com/log/2018/09/12/parallelizing-png-part-8-rust-macros-for-constant-specialization/",
      "date_published": "2018-09-12T15:26:54+00:00",
      "author": {
        "name": "Brion Vibber",
        "url": "https://brionv.com/log/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "001f1e0d-3927-4e39-800e-68324a02887a",
      "title": "Rust Associated Type",
      "content_text": "Associated Types in Rust are similar to Generic Types; however, Associated Types limit the types of things a user can do, which consequently facilitates code management. Among the Generic Types of traits, types that depend on the type of trait implementation can be expressed by using the Associated Type syntax. By comparing the Associated and Generic Types, you can get a better understanding of Associated Types.",
      "url": "https://medium.com/codechain/rust-associated-type-2281dbf98229",
      "date_published": "2018-09-13T06:50:57.959+00:00",
      "author": {
        "name": "Seung Woo Kim",
        "url": "https://medium.com/@koreanboy1120"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6313ebb2-076c-449b-8fb1-372c9b025168",
      "title": "How we organize a complex Rust codebase",
      "content_text": "At Datalust we‚Äôve been busy building Flare: a storage engine for our log server, Seq, written in the Rust programming language. This post is a point-in-time look at how we've approached building this fairly complex piece of software in Rust in 2018. I‚Äôd like to share a few",
      "url": "https://blog.getseq.net/rust-at-datalust-how-we-organize-a-complex-rust-codebase/",
      "date_published": "2018-09-11T22:26:05+00:00",
      "author": {
        "name": "Ashley Mannix",
        "url": "https://blog.getseq.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f712f29b-efed-4c75-a4a0-8523fa0b6d52",
      "title": "Unit Type Params",
      "content_text": "I always enjoy reading blogs about patterns or tricks people have picked up writing Rust. I‚Äôve seen this a few times but not read about it anywhere.\n\nI‚Äôve been doing class assignments from Operating Systems cs140e. I highly recommend this class if you know a bit of Rust and would like to try writing some lower level code. The class involves building bits of an OS for the raspberry pi.",
      "url": "https://leshow.github.io/post/unit_type_pattern/",
      "date_published": "2018-09-10T12:28:03-04:00",
      "author": {
        "name": "Evan Cameron",
        "url": "https://leshow.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "35458bae-bc62-40d7-ac3d-2dcd8ab1f469",
      "title": "From Rust to beyond: The C galaxy",
      "content_text": "This blog post is part of a series explaining how to send Rust beyond earth, into many different galaxies. The galaxy we will explore today is the C galaxy. This post will explain what C is (shortly), how to compile any Rust program in C in theory, and how to do that practically with our Rust parser from the Rust side and the C side. We will also see how to test such a binding.",
      "url": "https://mnt.io/2018/09/11/from-rust-to-beyond-the-c-galaxy/",
      "date_published": "2018-09-11T07:49:07+00:00",
      "author": {
        "name": "Ivan Enderlin",
        "url": "https://mnt.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "83d6c5ed-e847-4807-8c6c-40e97f66b9d5",
      "title": "The Common Rust Traits",
      "content_text": "In Rust, data types - primitives, structs, enums and any other ‚Äòaggregate‚Äô types like tuples and arrays - are dumb. They may have methods but that is just a convenience (they are just functions). Types have no relationship with each other.\n\nTraits are the abstract mechanism for adding functionality to types and establishing relationships between them.",
      "url": "https://stevedonovan.github.io/rustifications/2018/09/08/common-rust-traits.html",
      "date_published": "2018-09-08T00:00:00+02:00",
      "author": {
        "name": "Steve Donovan",
        "url": "http://stevedonovan.github.io/rustifications/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e3bf830e-e1ed-462b-9a6a-edac9ba2d699",
      "title": "Why Rust Closures are (Somewhat) Hard",
      "content_text": "Rust closures are harder for three main reasons: The first is that it is both statically and strongly typed, so we‚Äôll need to explicitly annotate these function types. Second, Lua functions are dynamically allocated (‚Äòboxed‚Äô.) Rust does not allocate silently because it prefers to be explicit and is a system language designed for maximally efficient code. Third, closures share references with their environment. In the case of Lua, the garbage collector ensures that these references will live long enough. With Rust, the borrow checker needs to be able to track the lifetimes of these references.",
      "url": "http://stevedonovan.github.io/rustifications/2018/08/18/rust-closures-are-hard.html",
      "date_published": "2018-08-18T00:00:00+02:00",
      "author": {
        "name": "Steve Donovan",
        "url": "http://stevedonovan.github.io/rustifications/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5d84ad61-702d-400b-ac40-6325904e031d",
      "title": "Feasible functors in Rust",
      "content_text": "withoutboats, one of the Rust language design team, recently posted a thread on the infeasibility of monads as a useful abstraction technique in Rust, as a response to the persistence of some (usually from outside the Rust community) in claiming that ‚ÄúRust is doing things incorrectly‚Äù by developing specific solutions to problems, rather than using a general category theoretic framework for everything. The points demonstrate real difficulties with attempting to use a general framework for these problems and to me serves perfectly as a ‚Äúthe ball‚Äôs in your court now‚Äù to anyone claiming Rust is ignoring theory and coming up with unnecessary solutions to solved problems: if you think Rust could use monadic abstractions, you have to be able to address these counterarguments.",
      "url": "https://varkor.github.io/blog/2018/08/28/feasible-functors-in-rust.html",
      "date_published": "2018-08-28T12:20:10+00:00",
      "author": {
        "name": "varkor",
        "url": "https://varkor.github.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "44aebda5-9403-432d-b94e-d81449a1edbf",
      "title": "Using RwLock and CondVars in Rust",
      "content_text": "Read many, write exclusive locks ‚Äì RwLock Consider a situation where you have a resource that must be manipulated only a single thread at a time, but is safe to be queried by many‚Äîthat is, you have many readers and only one writer.\n\nWhile you could protect this resource with a mutex, the trouble is that the mutex makes no distinction between its lockers; every thread will be forced to wait, no matter what their intentions.",
      "url": "https://tutorialedge.net/rust/using-rwlocks-and-condvars-rust/",
      "date_published": "2018-09-01T15:09:49+01:00",
      "author": {
        "name": "Brian L. Troutwine",
        "url": "//plus.google.com/b/115194233692529836662"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7610bbc1-58a1-413b-a4a3-dad7877ca1bd",
      "title": "Rust pattern: Iterating an over a Rc<Vec<T>>",
      "content_text": "This post examines a particular, seemingly simple problem: given ownership of a Rc<Vec<u32>>, can we write a function that returns an impl Iterator<Item = u32>? It turns out that this is a bit harder than it might at first appear ‚Äì and, as we‚Äôll see, for good reason. I‚Äôll dig into what‚Äôs going on, how you can fix it, and how we might extend the language in the future to try and get past this challenge.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/09/02/rust-pattern-iterating-an-over-a-rc-vec-t/",
      "date_published": "2018-09-02T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "271f4485-7452-487c-a1ee-4043dac3c60e",
      "title": "Rust: Fail Fast and Loudly",
      "content_text": "To panic or to return a Result: why libraries in Rust must weigh their options rather than accepting a never-panic mandate.",
      "url": "https://blog.shivoa.net/2018/08/rust-fail-fast-and-loudly.html",
      "date_published": "2018-08-31T02:58:00.001+01:00",
      "author": {
        "name": "Shivoa Birch",
        "url": "https://plus.google.com/104688779548004579468"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c3d8acef-fe90-4a0c-9fc5-9061f0694581",
      "title": "Rust Factory Without Box (Trait Object)",
      "content_text": "I‚Äôve been playing around a lot with Rust recently and it‚Äôs quickly becoming my second-favourite programming language. One of the things I‚Äôve been playing with is some Object Oriented design concepts as they might apply.",
      "url": "https://singpolyma.net/2018/09/rust-factory-without-box-trait-object/",
      "date_published": "2018-09-01T17:52:00+00:00",
      "author": {
        "name": "Stephen Paul Weber",
        "url": "https://singpolyma.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "deb45294-d269-481c-a767-f4fd7c00cf0f",
      "title": "Primitives in Rust are Weird (and Cool)",
      "content_text": "I wrote a really small Rust program a while back because I was curious. I was 100% convinced itcouldn‚Äôt possibly run. And to my complete befuddlement, it compiled, ran, and produced a completely sensible output.",
      "url": "https://speice.io/2018/09/primitives-in-rust-are-weird.html",
      "date_published": "2018-09-01T00:00:00-04:00",
      "author": {
        "name": "Bradlee Speice",
        "url": "https://speice.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "90241d58-f6a1-4df5-9c3f-15c94998c6df",
      "title": "Thoughts on Rust from a PHP developer!",
      "content_text": "I first starting learning Rust about 6 months ago, I was looking for a new language to learn when I came across it. At first I thought Rust was only meant to be a low level, systems programming language, but the more I learned, the more I realised the potential it has for high level programming and web applications. Also, along the way I learned many ways in which Rust prevents many of the typical bugs often found in applications written in other programming languages.",
      "url": "https://www.smashing-bugs.tk/software-development/rust/2018/08/27/on-rust-from-a-php-developer.html",
      "date_published": "2018-08-27T14:41:11+00:00",
      "author": {
        "name": "Diego Cabrejas",
        "url": "https://www.smashing-bugs.tk/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a2e99609-1298-4f79-b2f3-0cce908a701f",
      "title": "Serde Deserialize This or That into u64",
      "content_text": "Recently I ran into a bug in my code; hey, it happens. The bug was that I had a struct which could serialize into json, but could not deserialize from its own json. The struct holds a value for a mac address, which is 48-bit integer (that i store in a u64), but it is serialized using the network interface name. For example on my mac, i have a network interface named en1 with the mac address of 20:c9:d0:b0:a4:71.",
      "url": "https://noyez.gitlab.io/post/2018-08-28-serilize-this-or-that-into-u64/",
      "date_published": "2018-08-28T00:00:00+00:00",
      "author": {
        "name": "Noyez",
        "url": "https://noyez.gitlab.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "09fcee2d-1825-46a0-952f-7035c41b2b32",
      "title": "Introduction to asynchronous programming in Rust",
      "content_text": "An alternate introdcution to the APR book. This book aims to be a comprehensive, up-to-date guide on the async story in Rust, appropriate for beginners and old hands alike. We assume you already know Rust fairly well, including having done some multi-threaded programming. If any Rust terms in this guide are unfamiliar, you should check out the Rust book.",
      "url": "https://github.com/nrc/apr-intro",
      "date_published": "2018-08-30T10:12:00+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "09bd9199-be43-439f-ad36-d22904a73fb1",
      "title": "Debugging an Rc<T> reference leak in Rust",
      "content_text": "The bug that caused two brown-paper-bag releases in librsvg ‚Äî because it was leaking all the SVG nodes ‚Äî has been interesting. Memory leaks in Rust? Isn't it supposed to prevent that? Well, yeah, but the leaks were caused by the C side of things, and by unsafe code in Rust, which does not prevent leaks.",
      "url": "https://people.gnome.org/~federico/blog/debugging-reference-leak-in-rust.html",
      "date_published": "2018-08-29T16:47:13-05:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7a251e22-3430-4226-85e0-a94e73b3e785",
      "title": "Experimental async / await support for Tokio",
      "content_text": "In case you haven‚Äôt heard, async / await is a big new feature that is being worked on for Rust. It aims to make asynchronous programming easy (well, at least a little bit easier than it is today). The work has been on going for a while and is already usable today on the Rust nightly channel.\n\nI‚Äôm happy to announce that Tokio now has experimental async / await support! Let‚Äôs dig in a bit.",
      "url": "https://tokio.rs/blog/2018-08-async-await/",
      "date_published": "2018-08-27T00:00:00+00:00",
      "author": {
        "name": "Carl Lerche",
        "url": "https://tokio.rs/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fcadb47a-753e-44c9-830e-0e2cda34b365",
      "title": "Programming Servo: The Debug Way",
      "content_text": "Servo is a huge project. I have counted the lines of code for you. There are almost a hundred thousand lines of code in the Servo project. To develop such a big project, knowing how to debug in a right way is very important, since you would like to find the bottleneck in a fast and efficient way.\n\nIn this article, I will teach you some tips to use GDB developing and debugging your Rust code in the Servo project.",
      "url": "https://medium.com/coding-neutrino-blog/programming-servo-the-debug-way-5db01f09b7f4",
      "date_published": "2018-08-26T14:55:42.024+00:00",
      "author": {
        "name": "Liu An Chi",
        "url": "https://medium.com/@tigercosmos"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "13973f76-d793-4df8-9529-bca5f5f84428",
      "title": "Easy proc_macro_derive's with synstructure",
      "content_text": "Recently, I found myself in the market for some quickcheck. However, there were custom types, which had no Arbitrary implementation. Wondering if someone had already written a procedural macro to derive it, I found panicbit‚Äôs quickcheck_derive crate. However, to my dismay, it was severely limited in that it could only derive Arbitrary for structs.",
      "url": "https://llogiq.github.io/2018/08/25/synstruct.html",
      "date_published": "2018-08-25T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b0c75f8a-24c3-449e-bc2d-97638d193d3e",
      "title": "Why an Interior Mutable abstraction is needed in the Rust core library",
      "content_text": "Interior mutabiliby is a concept known to anyone who have programmed in Rust for a while. And even though Rust's stdlib have several wrapper-types allowing interior mutability there is no trait unifying these types. Motivated by writing libraries suitable for no_std development that are fully safe to use with threads, this blog post will attempt to fill in one gap in the Rust stdlib.",
      "url": "http://blog.kjeka.com/rust/programming/tmcl/2018/08/24/interior-mut/",
      "date_published": "2018-08-24T00:00:00+00:00",
      "author": {
        "name": "Kjetil Kjeka",
        "url": "http://blog.kjeka.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4a0db6c9-2c0d-4455-b353-474e4f59c87a",
      "title": "Calling C# natively from Rust",
      "content_text": "A couple of months ago, I created my first Rust program; a music manager called seiri. seiri is actually a rewrite of a previous, much buggier program that I used to organize my music that was written in C#. The tag library of choice was of course, taglib-sharp, a port of the C++ library TagLib to the .NET ecosystem. Since Rust unfortunately doesn‚Äôt have its own native port of TagLib, and any C bindings available didn‚Äôt expose the picture API, the most obvious thing to do was to use the C# library with Rust somehow, right?",
      "url": "https://medium.com/@chyyran/calling-c-natively-from-rust-1f92c506289d",
      "date_published": "2018-08-24T01:07:46.707+00:00",
      "author": {
        "name": "Ronny Chan",
        "url": "https://medium.com/@chyyran"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4857abad-3757-40b8-a899-93442e4982e9",
      "title": "Oxidizing sourmash: Python and FFI",
      "content_text": "Last December I decided to give Rust a run: I spent some time porting the C++ bits of sourmash to Rust. The main advantage here is that it's a problem I know well, so I know what the code is supposed to do and can focus on figuring out syntax and the mental model for the language. I started digging into the symbolic codebase and understanding what they did, and tried to mirror or improve it for my use cases.",
      "url": "https://blog.luizirber.org/2018/08/23/sourmash-rust/",
      "date_published": "2018-08-23T17:00:00-03:00",
      "author": {
        "name": "Luiz Irber",
        "url": "https://blog.luizirber.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1332a957-6689-4053-884b-ec31ca39f505",
      "title": "Live Refreshing Cargo Docs",
      "content_text": "rustdoc is a great tool, but as of now there isn‚Äôt an official way to have its generated docs refresh as you make edits. Running cargo doc with the --open argument will open the generated docs in browser window. If you make changes to your source code, you‚Äôll need to re-run cargo doc to have the changes reflected in your browser. By chaining together a few other Rust tools, we can pretty easily get the functionality of live-reloading docs.",
      "url": "https://benjamincongdon.me/blog/2018/08/22/Live-Refreshing-Cargo-Docs/",
      "date_published": "2018-08-22T21:03:28+00:00",
      "author": {
        "name": "Benjamin Congdon",
        "url": "https://benjamincongdon.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7c167657-c185-479c-afc3-93b0187b8359",
      "title": "Two Kinds of Invariants: Safety and Validity",
      "content_text": "When talking about the Rust type system in the context of unsafe code, the discussion often revolves around invariants: Properties that must always hold, because the language generally assumes that they do. In fact, an important part of the mission of the Unsafe Code Guidelines strike force is to deepen our understanding of what these invariants are.\n\nHowever, in my view, there is also more than one invariant, matching the fact that there are (at least) two distinct parties relying on these invariants: The compiler, and (authors of) safely usable code. This came up often enough in recent discussions that I think it is worth writing it down properly once, so I can just link here in the future.",
      "url": "https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html",
      "date_published": "2018-08-22T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0c187e7b-4693-4f2c-b330-ce51a314c6eb",
      "title": "To Make or Not to Make ‚Äì Using cargo make for Rookeries v0.12.0",
      "content_text": "I recently continued with my exploration of Rust through Rookeries (my attempt at a static site generator/backing API server). This time I worked on switching over from using invoke and GNU make to using a nice build system called cargo-make. Overall I am quite happy with the result.",
      "url": "https://dorianpula.ca/2018/08/22/to-make-or-not-to-make-using-cargo-make-for-rookeries-v0-12-0/",
      "date_published": "2018-08-22T23:00:27+00:00",
      "author": {
        "name": "Dorian Pula",
        "url": "https://dorianpula.ca/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "edfe7063-b893-42db-aa08-61adcaddf56b",
      "title": "Another look at the pinning API",
      "content_text": "One thing has always nagged about the API we have right now though: the proliferation of different reference types that it implies. Today, the pin feature adds the PinMut and PinBox types, but in theory there ought to be a ‚Äúpinned‚Äù version of every pointer in the standard library: PinRc and PinArc and so on. This is a very unfortunate consequence, but so far we have not found a good way to make pinning work compositionally - to have a single adapter that could be combined with any pointer.\n\nLast night, a bit of inspiration struck me, and I realized that it is possible to make a compositional Pin type. This isn‚Äôt a fundamental change to the pinning model, just an API refactoring, but I‚Äôve put a blocking concern on the proposal to stabilize Pin so that we can consider this possibility.",
      "url": "https://boats.gitlab.io/blog/post/rethinking-pin/",
      "date_published": "2018-08-22T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "49ccf817-c69f-4467-9391-9fccc619e928",
      "title": "More on the RLS and a 1.0 release",
      "content_text": "In my last post, I announced a release candidate for the RLS 1.0. There has been a lot of feedback (and quite a lot of that was negative on the general idea), so I wanted to expand on what 1.0 means for the RLS, and why I think it is ready. I also want to share some of my vision for the future of the RLS, in particular changes that might warrant a major version release.",
      "url": "https://www.ncameron.org/blog/more-on-the-rls-and-a-1-0-release/",
      "date_published": "2018-08-23T09:10:11+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e3b3767b-4228-4432-a525-15d8cbc99f77",
      "title": "[blog series] From Rust to beyond: Prelude",
      "content_text": "This series of posts is about those bindings, and explains how to send Rust beyond earth, into many different galaxies. Rust will land in: The WebAssembly galaxy, The ASM.js galaxy, The C galaxy, The PHP galaxy, and The NodeJS galaxy. The ship is currently flying into the Java galaxy, this series may continue if the ship does not crash or has enough resources to survive!",
      "url": "https://mnt.io/2018/08/21/from-rust-to-beyond-prelude/",
      "date_published": "2018-08-21T08:46:20+00:00",
      "author": {
        "name": "Ivan Enderlin",
        "url": "https://mnt.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "29c7c773-0be7-4694-a11d-41717eac218c",
      "title": "Safe Partial Initialization In Rust",
      "content_text": "Say we have a struct, Foo, with multiple fields that we would like to partially initialize without resorting to using unsafe. We could write a procedural macro called PartialInit, for example, which would be invoked using derive.",
      "url": "https://scottjmaddox.github.io/Safe-partial-initialization-in-Rust/",
      "date_published": "2018-08-19T00:00:00+00:00",
      "author": {
        "name": "Scott J Maddox",
        "url": "https://scottjmaddox.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9f3fb115-f832-421a-bf28-18148cc3bde0",
      "title": "A Beginner‚Äôs Guide to Rust Macros ‚ú®",
      "content_text": "Demystifying one of Rust‚Äôs most powerful feature.",
      "url": "https://medium.com/@phoomparin/a-beginners-guide-to-rust-macros-5c75594498f1",
      "date_published": "2018-08-18T18:35:50.344+00:00",
      "author": {
        "name": "Phoomparin Mano",
        "url": "https://medium.com/@phoomparin"
      },
      "tags": [
        "Language",
        "Getting Started"
      ]
    },
    {
      "id": "bbb6ed5a-a451-4abf-bbff-2e0b33f6660a",
      "title": "Rust concurrency patterns: No context, no cancel, no leaks",
      "content_text": "Let‚Äôs put ourselves to the challenge of having an ‚Äòinfinite‚Äô generator, which will have to be told to stop generating by the consumer‚Ä¶",
      "url": "https://medium.com/@polyglot_factotum/rust-concurrency-patterns-no-context-no-cancel-no-leak-b6c1ec2dafa5",
      "date_published": "2018-08-07T10:54:56.242+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d711d36a-fa00-4b26-a367-26b70589af2e",
      "title": "Logging from Rust in librsvg",
      "content_text": "Over in this issue we are discussing how to add debug logging for librsvg.  A popular way to add logging to Rust code is to use the log crate. However, the log create is just a facade, and by default the messages do not get emitted anywhere. The calling code has to set up a logger. Crates like env_logger let one set up a logger, during program initialization, that gets configured through an environment variable. This is a problem for librsvg: we are not the program's initialization! Librsvg is a library; it doesn't have a main() function. And since most of the calling code is not Rust, we can't assume that they can call code that can initialize the logging framework.",
      "url": "https://people.gnome.org/~federico/blog/logging-in-librsvg.html",
      "date_published": "2018-08-03T19:29:43-05:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "26f81256-2d48-4d6e-b305-7ed0d88c216b",
      "title": "Writing Integration Tests in Rust",
      "content_text": "As part of my overall change over in Rookeries, from Python to Rust, I rewrote a suite of integration tests for the server API. To celebrate my successful transition, I released version 0.11.0 of Rookeries, whose tests use pure Rust now!",
      "url": "https://dorianpula.ca/2018/08/15/writing-integration-tests-in-rust-releasing-rookeries-v0-11-0/",
      "date_published": "2018-08-15T23:00:26+00:00",
      "author": {
        "name": "Dorian Pula",
        "url": "https://dorianpula.ca/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6c12615c-c39d-4123-993e-a8581915e2f0",
      "title": "Rust concurrency patterns: communicate by sharing your Sender",
      "content_text": "Doing concurrency in ‚Äòshare by communicating‚Äô style has been popularized by the Go community. It‚Äôs a valuable approach to concurrency in Rust too, however, one has to be aware of the different semantics of Rust vs Go channels when doing so.",
      "url": "https://medium.com/@polyglot_factotum/rust-concurrency-patterns-communicate-by-sharing-your-sender-11a496ce7791",
      "date_published": "2018-07-21T16:10:44.191+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c027288d-df1a-4945-ad6e-1ca444e689c8",
      "title": "Natively run OCaml from Rust",
      "content_text": "How to get Rust to execute OCaml code and libraries with zero-cost by sharing C libraries. Call OCaml functions from Rust through ffi, fast!",
      "url": "https://blog.s-m.ac/ocaml-rust-ffi/",
      "date_published": "2018-06-07T00:00:00+00:00",
      "author": {
        "name": "Mathias Sabl√©-Meyer and Lucas E. Morales",
        "url": "https://blog.s-m.ac/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "523b014f-5ec9-4569-b31f-44720fb3bbc4",
      "title": "Rust: _(underscore) Does Not Bind",
      "content_text": "Rust is a language that utilizes the RAII idiom, resulting in different code depending on when the object is destroyed.",
      "url": "https://medium.com/codechain/rust-underscore-does-not-bind-fec6a18115a8",
      "date_published": "2018-08-13T07:13:58.080+00:00",
      "author": {
        "name": "Seung Woo Kim",
        "url": "https://medium.com/@koreanboy1120"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a47db977-bb96-4ecf-9203-8c64b438062d",
      "title": "A FizzBuzzy Tour of Traits in Rust",
      "content_text": "Traits are a core part of the Rust programming language, and understanding traits, particularly those which are part of the standard library, is necessary in order to write idiomatic Rust. In this post I‚Äôll write several FizzBuzz implementations, each demonstrating the use of a different trait from the Rust standard library.",
      "url": "https://www.joshmcguigan.com/blog/fizzbuzz-tour-of-traits-rust/",
      "date_published": "2018-08-13T00:00:00+00:00",
      "author": {
        "name": "Josh Mcguigan",
        "url": "https://www.joshmcguigan.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4b9c619b-6d09-43a9-82bb-86887dbd3a53",
      "title": "Diagnosing A Weak Memory Ordering Bug",
      "content_text": "For the first time in my life I tracked a real bug's root cause to incorrect usage of weak memory orderings. Until now weak memory bugs were something I knew about but had subconciously felt were only relevant to wizards coding on big iron, partly because until recently I've spent most of my career using desktop x86 machines.",
      "url": "https://robert.ocallahan.org/2018/08/for-first-time-in-my-life-i-tracked.html",
      "date_published": "2018-08-14T15:18:00+12:00",
      "author": {
        "name": "Robert O'Callahan",
        "url": "http://www.blogger.com/profile/01801341049800948737"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "45c51d1f-97ea-41ad-a1fe-3aab3c51d9ee",
      "title": "A Short Serde Deserialize example",
      "content_text": "In my previous post, I described taking a simple enum and creating a custom type in diesel. This post will take that same enum and implement deserialize. I often get tripped up by the mechanics of deserializing so this simple enum makes for a good example. Again, this is to benefit anyone looking for more examples of Serde‚Äôs Deserialize as well as for myself, so I can remember next time I need to do this.",
      "url": "https://noyez.gitlab.io/post/2018-08-14-short-serde-deserialize-exapmle/",
      "date_published": "2018-08-14T00:00:00+00:00",
      "author": {
        "name": "Noyez",
        "url": "https://noyez.gitlab.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8a47c51e-2de1-47c2-8c3d-3f2d84ae13cb",
      "title": "Never patterns, exhaustive matching, and uninhabited types (oh my!)",
      "content_text": "One of the long-standing issues that we‚Äôve been wrestling with in Rust is how to integrate the concept of an ‚Äúuninhabited type‚Äù ‚Äì that is, a type which has no values at all. Uninhabited types are useful to represent the ‚Äúresult‚Äù of some computation you know will never execute ‚Äì for example, if you have to define an error type for some computation, but this particular computation can never fail, you might use an uninhabited type.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/08/13/never-patterns-exhaustive-matching-and-uninhabited-types-oh-my/",
      "date_published": "2018-08-13T00:00:00-07:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "91714b35-a84b-4ac0-a0ed-57e2bdedc9dc",
      "title": "I learnt Rust: less than a memoir",
      "content_text": "Over the past two months, I worked on a feature for Project Fluent. My feature was needed in the Rust implementation of Fluent and was published as a Rust crate, making my code available to the entire Rust community. Completing this project brought me a great sense of satisfaction, and having contributed a fundamental internationalization crate to the Rust ecosystem is possibly the biggest milestone in my career as a developer.",
      "url": "http://blog.kekoariggin.com/coding/i-learnt-rust-less-than-a-memoir/",
      "date_published": "2018-08-13T04:23:32+00:00",
      "author": {
        "name": "Kekoa Riggin",
        "url": "http://blog.kekoariggin.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e19ac48b-7995-4b64-82d8-64d149067b54",
      "title": "Object Models And Identities",
      "content_text": "In many things, Rust is very much like C++. It‚Äôs memory management strategy is mostly the same, threading models are copied vanilla, both compile to native code and do about the same optimisations at that time, and traits and templates have a lot in common too. Both tend to be rather feature-rich languages with quite a lot to learn. While Rust is definitely better teacher (I‚Äôm looking at you, C++ error message!) and has many more ‚Äûsafety covers‚Äú over the dangerous moving parts inside the engine, the design of the engine is more of an evolution from C++ than a completely new thing.\n\nBut I‚Äôve noticed one rather subtle difference in the philosophy of the languages I‚Äôd like to describe here. To make it somewhat more complete, I‚Äôll also throw what some other languages do in this area in.",
      "url": "https://vorner.github.io/2018/08/12/Object-models-and-identities.html",
      "date_published": "2018-08-12T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ff118dd1-1fe8-4cde-a359-a00325002ebd",
      "title": "Refactoring with Rust macros",
      "content_text": "Refactoring boilerplate code is always easy in dynamically-typed languages, but sometimes takes a bit more effort when constrained by strong typing. This is something I was puzzling over recently, when the penny dropped for me about how Rust's macros can be used to bridge the gap.",
      "url": "https://philbooth.me/blog/refactoring-with-rust-macros",
      "date_published": "2018-08-12T12:54:12+00:00",
      "author": {
        "name": "Phil Booth",
        "url": "https://philbooth.me/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6f49ae97-11d3-4e1f-ab95-0307bf406aa5",
      "title": "How to alleviate the pain of Rust compile times",
      "content_text": "A few days ago, I wrote about two Rust pain points when using Rust at work. One of these points were the long compile times. In this post, I want to share a few tips that can help alleviate that pain.",
      "url": "https://vfoley.xyz/rust-compile-speed-tips/",
      "date_published": "2018-08-11T00:00:00+00:00",
      "author": {
        "name": "Vincent Foley",
        "url": "http://vfoley.xyz/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "64be78c2-0f4e-413f-ac54-1e6b21215413",
      "title": "Clippy's \"cast_lossless\" Lint Warning",
      "content_text": "Recently, I was trying out clippy  ‚Äî a linting and static analysis tool for Rust, when I ran into a lint warning that wasn‚Äôt immediately clear to me: warning: casting u8 to u16 may become silently lossy if types change.",
      "url": "https://benjamincongdon.me/blog/2018/08/06/Clippys-cast_lossless-Lint-Warning/",
      "date_published": "2018-08-06T20:28:01+00:00",
      "author": {
        "name": "Benjamin Congdon",
        "url": "https://benjamincongdon.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e141f480-7f0d-4b15-82b6-44d0f807f09c",
      "title": "GSoC wrap-up - Splitting Servo's script crate",
      "content_text": "I am Peter Hrvola (retep007) Twitter Github. During my Google Summer of Code (GSoC) project, I have been working on investigating the monolithic nature of Servo‚Äôs script crate and prototyping separation to smaller crates. My goal was to improve the use of resources during compilation. Current debug build consumes over 5GB of memory and takes 347s.",
      "url": "https://blog.servo.org/2018/08/09/gsoc-generic-servo/",
      "date_published": "2018-08-09T00:00:00+00:00",
      "author": {
        "name": "Peter Hrvola",
        "url": "https://twitter.com/retep007"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9a82c540-b8ab-4635-a68b-82754b5fe8a1",
      "title": "Literate Programming in Rust",
      "content_text": "In which we explore how cargo and rustdoc make it possible to write documentation and unit tests at once, resulting in code that is explained and tested from the POV of a public API.",
      "url": "https://damien.codes/posts/literate-rust/",
      "date_published": "2018-08-09T00:00:00+00:00",
      "author": {
        "name": "Damien",
        "url": "https://damien.codes/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d6b87789-dd86-49e2-91b6-692607e32f67",
      "title": "How Rust made me rethink my view about compilers",
      "content_text": "It's funny how universe aligns things, just few days ago I stumbled upon Rust koans. Already familiar way of learning and exercising, patented by Ruby programmers, where you correct tests and make them work. Also whole method of learning was similar to reading 'Little Schemer' fairly popular book among fellow Lispers. So I'll use this blog post to summarize few early impressions about Rust, and let me tell you straight away, I am loving it so far!",
      "url": "https://defphil.com/post/2018/07/15/staying-rusty/",
      "date_published": "2018-07-15T00:00:00+00:00",
      "author": {
        "name": "Filip Miletic",
        "url": "https://defphil.com/"
      },
      "tags": [
        "Language",
        "Getting Started"
      ]
    },
    {
      "id": "f0133b81-60d3-416a-b58a-6d6c9c7afe6a",
      "title": "Launching the 2018 State of Rust Survey",
      "content_text": "It‚Äôs that time again! Time for us to take a look at how the Rust project is doing, and what we should plan for the future. The Rust Community Team is pleased to announce our 2018 State of Rust Survey! Whether or not you use Rust today, we want to know your opinions. Your responses will help the project understand its strengths and weaknesses and establish development priorities for the future.\n\nThis year, volunteers have also translated the survey into 14 languages!",
      "url": "https://blog.rust-lang.org/2018/08/08/survey.html",
      "date_published": "2018-08-08T00:00:00+00:00",
      "author": {
        "name": "The Rust Community Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8c27c640-fb7d-42f9-a31f-09e9f5b35c2d",
      "title": "Proposal: Rust Custom Test Frameworks",
      "content_text": "The Rust community recently approved a Custom Test Frameworks eRFC which lays out a series of goals and possible directions of exploration for implementing custom test frameworks. In this post, I present my own proposed fulfillment of the RFC with rationale.",
      "url": "https://blog.jrenner.net/rust/testing/2018/08/06/custom-test-framework-prop.html",
      "date_published": "2018-08-08T08:12:00+00:00",
      "author": {
        "name": "John Renner",
        "url": "https://blog.jrenner.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4f9e9645-78dc-4c18-a504-653e96a0c960",
      "title": "That weekend I wasted on newtyped indices",
      "content_text": "Today, ajyne posted a thread on users.rust-lang.org asking: What have been the drawbacks of static typing for you? Kornel was quick to reply with a variety of points, but this one in particular stands out to me, \"With powerful type systems there‚Äôs no end to how far you can go to guarantee things about your program, but you might create a complex monster\". As I see it, there is no truer answer. The type system can be a seductive beast, often promising correctness and performance at the low-low, one-time cost of your soul. I personally can name a number of examples from my own code base where I tried to abstract over something too big and failed. I call these my wasted weekends.",
      "url": "https://exphp.github.io/2018/07/30/that-weekend-i-wasted-on-newtyped-indices.html",
      "date_published": "2018-07-30T00:00:00+00:00",
      "author": {
        "name": "Michael Lamparski",
        "url": "https://exphp.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ea8d1190-c763-4f38-8181-1fc86193bfe4",
      "title": "Exploring inband lifetimes by converting librustc_mir",
      "content_text": "Inband lifetimes is a limited change, and does not feel like it greatly enhances code. However, it also doesn‚Äôt hurt much and feels slightly better in many cases.\n\nHowever, there are numerous edge cases and slight pain points, many having to do with a lack of known standard ways to do things. As such, many of the edge cases are likely to fall away as we develop after stabilization and come up with standard methods to work with the new feature.\n\nThe primary work to migrate is essentially just deleting ~all lifetime headers (<'a, 'b, 'c>) across impls and functions. More intensive migration would involve replacing untied/single-use lifetimes with '_ in all cases. This is quite hard to do from a person perspective (though compiler can likely do so fairly easily).",
      "url": "https://mark-simulacrum.github.io/2018/07/19/inband-lifetimes.html",
      "date_published": "2018-07-19T00:00:00+00:00",
      "author": {
        "name": "Mark Rousskov",
        "url": "https://mark-simulacrum.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b5f6a958-c0bd-4ea9-a1ae-d8e4f5549719",
      "title": "Stacked Borrows: An Aliasing Model For Rust",
      "content_text": "In this post, I am proposing ‚ÄúStacked Borrows‚Äù: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses.",
      "url": "https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html",
      "date_published": "2018-08-07T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "59c63ab5-9b88-498e-a6ce-989f77bcdffe",
      "title": "Enforcing style in CI for Rust Projects",
      "content_text": "This article will attempt to help you avoid the debate entirely, at least in your Rust projects, by explaining how you can use the rustfmt tool to enforce style guidelines using CI. We‚Äôll start with a brief introduction to rustfmt, so feel free to skip the next section if you are already familiar.",
      "url": "https://medium.com/@ag_dubs/enforcing-style-in-ci-for-rust-projects-18f6b09ec69d",
      "date_published": "2018-07-10T22:03:24.240+00:00",
      "author": {
        "name": "Ashley Williams",
        "url": "https://medium.com/@ag_dubs"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "415e9361-8fad-4317-ae02-7abeb1faad3d",
      "title": "The State of Rust on Haiku",
      "content_text": "With the recent addition of Rust 1.27.0 in the HaikuPorts repository, I thought it would be good to do a short, public write-up of the current state of Rust on Haiku, and some insight into the future.",
      "url": "https://www.haiku-os.org/blog/nielx/2018-07-05_the_state_of_rust_on_haiku/",
      "date_published": "2018-07-05T07:31:51+02:00",
      "author": {
        "name": "nielx",
        "url": "https://www.haiku-os.org/blog/"
      },
      "tags": [
        "Operating Systems",
        "Language"
      ]
    },
    {
      "id": "7d6c2d9c-16c8-42be-93d5-d61cc9dac117",
      "title": "Rust Modules In Less Than 5 Minutes",
      "content_text": "When I started learning Rust, the module system did not at first seem to be a shining beacon of intuitive design. The Rust documentation is phenomenal, but there are definitely some areas that I found difficult to follow; this being one such topic. So I thought I might take a stab at writing up a guide that I think would have helped me through the awkward growing pains a bit quicker.",
      "url": "https://medium.com/@erik.tate/rust-modules-in-less-than-5-minutes-9bff7f617798",
      "date_published": "2018-08-05T23:49:43.586+00:00",
      "author": {
        "name": "Erik Tate",
        "url": "https://medium.com/@erik.tate"
      },
      "tags": [
        "Getting Started",
        "Language"
      ]
    },
    {
      "id": "58e93b1c-f7b4-440f-88fb-fa5ab900f1c6",
      "title": "Rust and the Case of the Redundant Comparison",
      "content_text": "A couple of days ago I landed my second pull request in the Rust Programming Language repository. This is the story of how that went. This post is inspired by other posts about improving the Rust compiler.",
      "url": "https://blog.dend.ro/rust-and-the-case-of-the-redundant-comparison/",
      "date_published": "2018-08-04T00:00:00+00:00",
      "author": {
        "name": "dend",
        "url": "https://blog.dend.ro/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "02647906-fc14-42ea-87ec-19fc717cb3d7",
      "title": "Some Slight Improvements",
      "content_text": "Today I want to talk about two Rust PRs I recently wrote. The PRs in question are #52942 and #52997. Both are relatively small changes to Rust‚Äôs internally used data structures that improve performance and readability. Both have some basic benchmarks (the first one already had them and I wrote them for the second one), although it‚Äôs rather hard to gauge whether they really impacted compile times (as perf.rust-lang.org puts all changes of the specific day together). But that‚Äôs not the point I want to make right now.",
      "url": "https://llogiq.github.io/2018/08/04/improve.html",
      "date_published": "2018-08-04T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2cc12b2e-22fb-461a-be01-ffeab54caa9f",
      "title": "Solving the Generalized Streaming Iterator Problem without GATs",
      "content_text": "Generic Associated Types (GATs for short) are a long awaited extension to Rust‚Äôs type system. They offer a way to work with higher kinded types ‚Äì a necessity in a couple of situations. A common example is the streaming iterator: an iterator able to return items borrowing from self (the iterator itself). Unfortunately, GATs haven‚Äôt even landed in nightly yet. So while are waiting, we can try tackling the streaming iterator problem without GATs. In this post we explore three possible workarounds for situations where an associated type depends on the lifetime of a &self receiver.",
      "url": "http://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html",
      "date_published": "2018-08-03T00:00:00+00:00",
      "author": {
        "name": "Lukas Kalbertodt",
        "url": "http://lukaskalbertodt.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f7eba5d3-ef85-47cb-88ec-345cf3c46ade",
      "title": "Rust concurrency patterns: Natural Born Pipelines",
      "content_text": "There seems to be demand for a ‚ÄúRust concurrent pipeline‚Äù guide √† la https://blog.golang.org/pipelines, so let‚Äôs give it a try.",
      "url": "https://medium.com/@polyglot_factotum/rust-concurrency-patterns-natural-born-pipelines-4d599e7612fc",
      "date_published": "2018-07-28T09:12:33.449+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a243dc7d-5708-4a3d-bae8-20ccc3de53d0",
      "title": "My experience with the Rust 2018 preview",
      "content_text": "Recently, I wrote a little a side project to sign git commits without gpg. When I did this, I decided to use the Rust 2018 edition. I also transitioned an existing library from Rust 2015 to Rust 2018 to see how that tooling worked. I thought I‚Äôd write a blog post about my experience using the Rust 2018 preview and the state of things right now.",
      "url": "https://boats.gitlab.io/blog/post/my-experience-with-rust-2018/",
      "date_published": "2018-07-24T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "44372b96-a1e4-44ee-af79-4496c4f629e6",
      "title": "Announcing Rust 1.28",
      "content_text": "The Rust team is happy to announce a new version of Rust. This release includes the global_allocator attribute to customise the allocator, improved error messages for format strings, and a number of number related stabilisations.",
      "url": "https://blog.rust-lang.org/2018/08/02/Rust-1.28.html",
      "date_published": "2018-08-02T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "86add592-8587-406b-8233-a06e675452f0",
      "title": "Using a Mac to cross-compile Linux binaries",
      "content_text": "The cycle of development we‚Äôre most familiar with is: write code, compile your code, then run this code on the same machine you were writing it on. On most desktop OSes, you pick up a compiler by downloading one from your package manager. Xcode and Visual Studio are toolchains (actually IDEs) that leverage being platform-specific, each including tools tailored around the platform your code will run on and heavily showcasing the parent OS‚Äôs design language.",
      "url": "http://timryan.org/2018/07/27/cross-compiling-linux-binaries-from-macos.html",
      "date_published": "2018-07-27T13:22:00+00:00",
      "author": {
        "name": "Tim Ryan",
        "url": "http://timryan.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2dba28aa-a443-4887-9806-aba84cf787ef",
      "title": "A Snapshot of Rust's Popularity in July 2018",
      "content_text": "Talking about a language‚Äôs popularity is traditionally a tricky topic. How do you measure popularity? How do you compare one language to another when they‚Äôre focused on different styles and different audiences? So, rather than having one or two charts, I‚Äôm going to look at a number of ‚Äúslices‚Äù into Rust‚Äôs growth to see it front different angles.",
      "url": "http://www.jonathanturner.org/2018/07/snapshot-of-rust-popularity.html",
      "date_published": "2018-07-28T00:00:00+00:00",
      "author": {
        "name": "Jonathan Turner",
        "url": "http://www.jonathanturner.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8f26eb1d-8d0c-4785-a7fb-85c8cf5c6f27",
      "title": "Streaming UTF-8 in Haskell and Rust",
      "content_text": "An investigation into getting Haskell-like error handling ergonomics into a Rust application dealing with streaming UTF-8 encoding and decoding.",
      "url": "https://www.fpcomplete.com/blog/2018/07/streaming-utf8-haskell-rust",
      "date_published": "2018-07-30T09:00:00+00:00",
      "author": {
        "name": "Michael Snoyman",
        "url": "https://www.fpcomplete.com/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3b874195-0df6-40ca-8667-067d3440061b",
      "title": "Rust: controlling side effects from the test",
      "content_text": "Imagine you want to write a timestamping repository of some sorts, that will associate the timestamp of when the storage operation was invoked with the stored value. How to write it in Rust ? And more importantly - how to test it ? I would like to share a solution I found and talk a bit about how it works.",
      "url": "https://blog.cyplo.net/posts/2018/07/rust-injection.html",
      "date_published": "2018-07-30T00:00:00+00:00",
      "author": {
        "name": "Cyryl P≈Çotnicki",
        "url": "https://blog.cyplo.net/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "96eb15b8-5f51-403c-a699-805553293c16",
      "title": "Building Readable Tests with Fluent Testing APIs",
      "content_text": "One of the biggest challenges in software testing is defining the input for code under test in a way that is expressive and powerful enough to test complex situations but doesn‚Äôt distract from the intent of the test or clutter the test code to a degree that makes it difficult to read.\n\nMany dynamic languages have testing APIs which take advantage of their looser and later type checking to provide easy mocking and stubbing, but strict, statically typed languages can make it difficult to build up suitable instances of the types needed in the test.",
      "url": "https://leotindall.com/tutorial/building-readable-tests-with-fluent-testing-apis/",
      "date_published": "2018-07-23T09:56:24-05:00",
      "author": {
        "name": "Leo Tindall",
        "url": "https://leotindall.com/post/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4a0e6748-9562-4507-bbfe-3cdf49b6292b",
      "title": "On impl blocks, injection and surjection in Rust",
      "content_text": "Rust has this cool feature called impl block. An impl block is just a scope that introduces a way to augment a type with methods ‚Äì do not confuse impl blocks with trait impls, used to implement a given trait.",
      "url": "https://phaazon.net/blog/on-rust-impl-block",
      "date_published": "2018-07-22T22:05:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2c62015d-b849-4ab6-bbc9-e62255ca3473",
      "title": "What is Rust 2018?",
      "content_text": "The release of Rust 1.31.0 on December 6th will be the first release of ‚ÄúRust 2018.‚Äù This marks a culmination of the last three years of Rust‚Äôs development, and brings it together in one neat package. For example, there will be a 2018 edition of the book that incorporates features stabilized since the print edition was considered finalized.",
      "url": "https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html",
      "date_published": "2018-07-27T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d0dc161e-3fcc-4fc7-9032-f9847bf4f3b8",
      "title": "Version selection in Cargo",
      "content_text": "When there are multiple ways to resolve dependencies, Cargo generally chooses the newest possible version. The goal of this post is to explain why Cargo works this way, and how that rationale relates to several recent discussions, including:",
      "url": "http://aturon.github.io/2018/07/25/cargo-version-selection/",
      "date_published": "2018-07-25T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b4133437-b69d-4491-a40f-a368a8847627",
      "title": "Pointers Are Complicated, or: What's in a Byte?",
      "content_text": "This summer, I am again working on Rust full-time, and again I will work (amongst other things) on a ‚Äúmemory model‚Äù for Rust/MIR. However, before I can talk about the ideas I have for this year, I have to finally take the time and dispel the myth that ‚Äúpointers are simple: they are just integers‚Äù. Both parts of this statement are false, at least in languages with unsafe features like Rust or C: Pointers are neither simple nor (just) integers.\n\nI also want to define a piece of the memory model that has to be fixed before we can even talk about some of the more complex parts: Just what is the data that is stored in memory? It is organized in bytes, the minimal addressable unit and the smallest piece that can be accessed (at least on most platforms), but what are the possible values of a byte? Again, it turns out ‚Äúit‚Äôs just an 8-bit integer‚Äù does not actually work as the answer.\n\nI hope that by the end of this post, you will agree with me on both of these statements. :)",
      "url": "https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html",
      "date_published": "2018-07-24T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7e963a31-6451-4f7d-9817-1e8c33c4973d",
      "title": "Thoughts on Compile-Time Function Evaluation and Type Systems",
      "content_text": "For some time now (since the 1.26 release, to be precise), Rust has a very powerful machinery for CTFE, or compile-time function evaluation. Since then, there have been various discussions about which operations should be allowed during CTFE, which checks the compiler should do, how this all relates to promotion and which kinds of guarantees we should be able to expect around CTFE. This post is my take on those topics, and it should not be surprising that I am going to take a very type-system centric view. Expect something like a structured brain dump, so there are some unanswered questions towards the end as well.",
      "url": "https://www.ralfj.de/blog/2018/07/19/const.html",
      "date_published": "2018-07-19T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "40055859-95cc-47a0-89e3-fd3c8a000fba",
      "title": "Rust vs. Go",
      "content_text": "Welcome to the Rust Review‚Äôs bonus post, which I had promised from the very beginning. I‚Äôm here to cover the big elephant in the room: Rust vs. Go. Which one is better?\n\nThere is no good answer to this question because this comparison is unfounded. I think people tend to bundle the two languages together because they were released at about the same time and the release of Rust felt like a response to the release of Go. Moreover, both languages are supposed to focus on systems software. But they are vastly different, and even as they both target systems software, they target different kinds of such software.",
      "url": "http://julio.meroh.net/2018/07/rust-vs-go.html",
      "date_published": "2018-07-13T10:45:00+02:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f4903839-c307-4209-b760-15176676663f",
      "title": "#[test] in 2018",
      "content_text": "Lately, I‚Äôve been working implementing the Custom Test Frameworks eRFC for Rust. While exploring the compiler codebase, I‚Äôve learned about the internals of testing in Rust and figured it would be interesting to share.",
      "url": "https://blog.jrenner.net/rust/testing/2018/07/19/test-in-2018.html",
      "date_published": "2018-07-19T00:00:00+00:00",
      "author": {
        "name": "John Renner",
        "url": "https://blog.jrenner.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2d302e67-f458-4d07-b1f4-78cb9ed02914",
      "title": "Announcing Rust 1.27.2",
      "content_text": "The Rust team is happy to announce a new version of Rust, 1.27.2.",
      "url": "https://blog.rust-lang.org/2018/07/20/Rust-1.27.2.html",
      "date_published": "2018-07-20T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2a8864ba-0872-45d2-89f4-87e9f368374b",
      "title": "Futures 0.3.0-alpha.1",
      "content_text": "Welcome to the inaugural post of the new futures-rs blog!\n\nAfter several months of work, we‚Äôre happy to announce an alpha release of the new edition of future-rs, version 0.3. The immediate goal of this work is to support async/await notation (with borrowing) in Rust itself, which has entailed significant changes to the futures crate.",
      "url": "https://rust-lang-nursery.github.io/futures-rs/blog/2018/07/19/futures-0.3.0-alpha.1.html",
      "date_published": "2018-07-19T17:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "https://rust-lang-nursery.github.io/futures-rs/"
      },
      "tags": [
        "Language",
        "Crates"
      ]
    },
    {
      "id": "a721af0b-e469-40ba-8ddc-f5f2a305483f",
      "title": "Signal Hook: Unix signal handling in Rust",
      "content_text": "As promised in the previous article (thanks for all the valuable feedback ‚Äí I didn‚Äôt have the time to act on it yet, but I will), this talks about Unix signal handling.\n\nLong story short, I wasn‚Äôt happy about the signal handling story in Rust and this is my attempt at improving it.",
      "url": "https://vorner.github.io/2018/06/28/signal-hook.html",
      "date_published": "2018-06-28T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language",
        "Operating Systems"
      ]
    },
    {
      "id": "75ff979d-19df-4238-9064-d02708b64a00",
      "title": "Rust Pointers for C Programmers",
      "content_text": "I knew that there are a lot of different ‚Äúpointers‚Äù but I found all the descriptions of them lacking or confusing. Specifically, Rust calls itself a systems programming language, yet I found no clear description of how the different pointers map to C‚Äîthe systems programming language. Eventually, I stumbled across The Periodic Table of Rust Types, which made things a bit clearer, but I still didn‚Äôt feel like I truly understood.\n\nDuring my weekend expedition to Rust land, I think I‚Äôve grokked things enough to write this explanation of how Rust does things. As always, feedback is welcomed.",
      "url": "http://blahg.josefsipek.net/?p=580",
      "date_published": "2018-01-28T15:47:00+00:00",
      "author": {
        "name": "Josef ‚ÄúJeff‚Äù Sipek",
        "url": "http://blahg.josefsipek.net"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "80a9211d-dd65-4da8-b8d6-5d4223ee278d",
      "title": "Auditing popular Rust crates: how a one-line unsafe has nearly ruined everything",
      "content_text": "Following the actix-web incident (which is fixed now, at least mostly) I decided to poke other popular Rust libraries and see what comes of it.\n\nThe good news is I‚Äôve poked at 6 popular crates now, and I‚Äôve got not a single actually exploitable vulnerability. I am impressed. When I poked popular C libraries a few years ago it quickly ended in tears. The bad news is I‚Äôve found one instance that was not a security vulnerability by sheer luck, plus a whole slew of denial-of-service bugs. And I can‚Äôt fix all of them by myself. Read on to find out how I did it, and how you can help!",
      "url": "https://medium.com/@shnatsel/auditing-popular-rust-crates-how-a-one-line-unsafe-has-nearly-ruined-everything-fab2d837ebb1",
      "date_published": "2018-07-19T01:38:11.806+00:00",
      "author": {
        "name": "Sergey \"Shnatsel\" Davidoff",
        "url": "https://medium.com/@shnatsel"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a81b111b-b3d6-4515-81bc-00d00bf62fb9",
      "title": "How to help test the 2018 edition",
      "content_text": "An edition brings together the features that have landed into a clear package, with fully updated documentation and tooling. By the end of the year we are planning to release the 2018 edition, our first since the Rust 1.0 release. You can currently opt-in to a preview of the 2018 edition to try it out and help test it.\n\nIn fact, we really need help testing it out! Once you‚Äôve turned it on and seen its wonderful new features, what then? Here we‚Äôve got some specific things we‚Äôd like you to test.",
      "url": "https://www.ncameron.org/blog/how-to-help-test-the-2018-edition/",
      "date_published": "2018-07-18T03:08:04+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fbdc0364-12e8-49f4-914f-b3c4f17d43f0",
      "title": "Hello Content-o-Tron",
      "content_text": "Content-o-Tron is a project to help amplify the lesser heard voices in the Rust community.\n\nWe are able to do this by providing editorial assistance and technical reviews of draft blog posts.\n\nOnce your blog post is ready to publish, we will ensure it is disseminated through various channels such as Read Rust, MozHacks, social networks and of course the Rust Community‚Äôs own blog on community.rs.",
      "url": "http://blog.community.rs/content-team/2018/07/16/hello-content-o-tron.html",
      "date_published": "2018-07-16T00:00:00+00:00",
      "author": {
        "name": "Mark Sta Ana",
        "url": "http://blog.community.rs/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d52613f9-60c7-4448-89ed-72cd3da79346",
      "title": "Why I love Rust",
      "content_text": "I spent much of my free time over the past year learning Rust, and while it‚Äôs been a difficult language to fully grasp (it‚Äôs still a work in progress), I find it incredibly rewarding to write in. I also have had many conversations with people who don‚Äôt know much about Rust and are curious about the problems it solves.\n\nThis is my take on why Rust is important, and why I have fallen in love with the language.",
      "url": "https://alexkitchens.net/2018/07/06/why-i-love-rust.html",
      "date_published": "2018-07-06T08:46:39+00:00",
      "author": {
        "name": "Alex Kitchens",
        "url": "https://alexkitchens.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ca7cc808-b6f7-4650-a219-b2c92be95460",
      "title": "Rust: Raw string literals",
      "content_text": "While working with Rust, you will often come across r#\"something like this\"#, especially when working with JSON and TOML files. It defines a raw string literal. When would you use a raw string literal and what makes a valid raw string literal?",
      "url": "https://medium.com/@rahulthakoor/rust-raw-string-literals-9579c4feb231",
      "date_published": "2018-07-05T13:26:49.039+00:00",
      "author": {
        "name": "Rahul Thakoor",
        "url": "https://medium.com/@rahulthakoor"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "54242603-6ea7-4c99-8826-bbda3f8f63db",
      "title": "Surface Rust: The Missing IDE",
      "content_text": "This week I decided to do a little hacking on Rust. I thought I‚Äôd write down my first impressions of the language.",
      "url": "https://medium.com/@wolfshirts/surface-rust-6470d0075721",
      "date_published": "2018-07-04T21:45:48.367+00:00",
      "author": {
        "name": "@wolfshirts",
        "url": "https://medium.com/@wolfshirts"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b2fbac94-27b1-4c37-8c21-ead67edecf43",
      "title": "The Tale of a Bug in Arc: Synchronization and Data Races",
      "content_text": "While I was busy doing Rust-unrelated research, RustBelt continues to move and recently found another bug (after a missing impl !Sync that we found previously): It turns out that Arc::get_mut did not perform sufficient synchronization, leading to a data race.",
      "url": "https://www.ralfj.de/blog/2018/07/13/arc-synchronization.html",
      "date_published": "2018-07-13T00:00:00+00:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1b9d4f29-d237-4f3d-bc55-23b9ab2c5d77",
      "title": "Why Rust?",
      "content_text": "Programming is hard. Not because our hardware is complex, but simply because we‚Äôre all humans. Our attention span is limited, our memory is volatile‚Ää‚Äî‚Ääin other words, we tend to make mistakes.",
      "url": "https://medium.com/paritytech/why-rust-846fd3320d3f",
      "date_published": "2018-07-04T07:43:11.858+00:00",
      "author": {
        "name": "Dmitriy Kashitsyn",
        "url": "https://medium.com/@0x7cfe"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f12f8561-c983-40b4-a7b4-9da8b350b33d",
      "title": "Idioms of Dynamic Languages",
      "content_text": "Programmers think dynamic languages like Python are easier to use than static ones, but why? I look at uniquely dynamic programming idioms and their static alternatives, identifying a few broad trends that impact language usability.",
      "url": "http://willcrichton.net/notes/idioms-of-dynamic-languages/",
      "date_published": "2018-07-01T00:00:00+00:00",
      "author": {
        "name": "Will Crichton",
        "url": "http://willcrichton.net/notes/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3b171674-7223-48e4-95da-5f268ec6fa1f",
      "title": "llvm-tools: a new rustup component for binary inspection and profiling",
      "content_text": "Recent nightly releases provide an opt-in llvm-tools rustup component which you can install using the command: rustup component add llvm-tools. This component contains the following LLVM tools: llvm-nm, llvm-objcopy, llvm-objdump, llvm-profdata, and llvm-size. Most of these tools are LLVM alternatives to GNU binutils. The main advantage of these LLVM tools is that they support all the architectures that the Rust compiler supports.",
      "url": "https://internals.rust-lang.org/t/llvm-tools-a-new-rustup-component-for-binary-inspection-objdump-nm-size-and-profiling-profdata/7830",
      "date_published": "2018-06-29T11:22:00+00:00",
      "author": {
        "name": "Jorge Aparicio",
        "url": "http://blog.japaric.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "19aba600-95ff-4ba2-920f-0db67b3755e4",
      "title": "New Photon Release of Eclipse IDE Ships With Full Rust Support | ",
      "content_text": "The release delivers native Eclipse IDE experiences for Rust and C# through Language Server based plugins. The Language Server Protocol (LSP) ecosystem delivers editing support for popular and emerging programming languages. Combined with the move to a quarterly rolling release cadence, the LSP focus demonstrates a commitment to keeping pace with evolving developer and commercial needs.",
      "url": "https://www.eclipse.org/org/press-release/20180627_new-photon-release-of-eclipse-ide-ships-with-full-rust-support.php",
      "date_published": "2018-06-27T00:00:00+00:00",
      "author": {
        "name": "The Eclipse Foundation",
        "url": "https://www.eclipse.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "696ba27d-cdab-400f-9e86-a138422c2154",
      "title": "A Self-ish Bug",
      "content_text": "I recently found a bug in mutagen: The ‚Äúexchange arguments‚Äù mutation was actually ineffective. I was in the process of refactoring the code to pull coverage reporting into the mutagen calls (to reduce the amount of code generated), so the report_coverage call was to go away anyway. Except this bug masked another, more insiduous one: When I refactored, I found that one of the test would no longer compile methods with self arguments, running into Error E0424 (self keyword used in static method). Consider me confused.",
      "url": "https://llogiq.github.io/2018/06/28/self-bug.html",
      "date_published": "2018-06-28T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0a781f91-aca4-47ac-81d4-f9f606f33d0f",
      "title": "A Rusty Go at Channels",
      "content_text": "Channels Channels are a useful concurrency primitive that enable separate processes to safely communicate without the need for explicit synchronization. The term processes is used here to loosely describe independent threads of execution within a program. This can be an OS level thread or a runtime level thread. Channels can be seen as a pipe to connect these processes and allow them to share memory with one another. For example a program could spawn any number of processes along with a channel to transmit results that it gathers.",
      "url": "https://gsquire.github.io/static/post/a-rusty-go-at-channels/",
      "date_published": "2018-06-24T10:44:31-07:00",
      "author": {
        "name": "Garrett Squire",
        "url": "https://gsquire.github.io/static/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fa4c6fb5-3c9e-4831-86b1-3585c08398de",
      "title": "Programming Servo: The script event-loop",
      "content_text": "One thing I have come to appreciate over time in the design of Servo, is the concurrency story. Basically, it‚Äôs pretty much all done using channels(and their multi-process counterpart).\n\nWhat is so great about channels vs shared mutable state? One thing is, it makes it easier to reason about how various threads will synchronize their behavior as they go on about their business.\n\nThe way it‚Äôs done in Servo is by combining event-loops with multi-threading/processing. What does that mean?",
      "url": "https://medium.com/@polyglot_factotum/programming-servo-the-script-event-loop-be687b985b3e",
      "date_published": "2018-06-28T05:17:48.726+00:00",
      "author": {
        "name": "Gregory Terzian",
        "url": "https://medium.com/@polyglot_factotum"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "638f5073-3504-43de-af0b-dbce4b5ae6c6",
      "title": "Failure. Or: why Rust is probably the best programming language ever created",
      "content_text": "This post is two stories. One is about accepting and recognising personal failure, reflecting and growing from it; the other is about an incredibly and seemingly endlessly powerful programming language, called Rust.",
      "url": "https://spacekookie.de/blog/failure-or-why-rust-is-probably-the-best-programming-language-ever-created/",
      "date_published": "2018-03-11T00:00:00+00:00",
      "author": {
        "name": "Katharina Fey",
        "url": "https://spacekookie.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e9ac81fa-8018-4bb1-91a2-cfd0b705f780",
      "title": "Why choose Rust?",
      "content_text": "Many of the candidates we interview for a position at PassFort are intrigued by the fact that we use Rust, a language which is only three years old (since its 1.0 release).\n\nDespite its relatively young age, Rust has been voted the ‚Äúmost loved‚Äù language in the StackOverflow developer survey every one of those three years - an impressive feat!\n\nHowever, it‚Äôs not enough for a language to be well liked: the programming ecosystem changes rapidly, and many of these developers are rightly afraid to jump blindly onto the latest bandwagon. We chose Rust not because it is popular, but because we believe it is the best tool for the job we have to do, and I hope to explain that reasoning now.",
      "url": "https://blog.passfort.com/why-choose-rust/",
      "date_published": "2018-06-26T16:00:00+00:00",
      "author": {
        "name": "PassFort",
        "url": "https://blog.passfort.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "34e39003-edb1-4232-ad2a-aae9d4868d81",
      "title": "Compiler fuzzing, part 1",
      "content_text": "Much has been written about fuzzing compilers already, but there is not a lot that I could find about fuzzing compilers using more modern fuzzing techniques where coverage information is fed back into the fuzzer to find more bugs.\n\nIf you know me at all, you know I'll throw anything I can get my hands on at AFL. So I tried gcc. (And clang, and rustc -- but more about Rust in a later post.)",
      "url": "http://www.vegardno.net/2018/06/compiler-fuzzing.html",
      "date_published": "2018-06-24T15:02:00+02:00",
      "author": {
        "name": "Vegard",
        "url": "http://www.blogger.com/profile/04821963505711884515"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "03d374fc-9500-42d8-8515-7f98447fd62a",
      "title": "Making Arc more atomic",
      "content_text": "This is a story of a tiny feature I was missing in Rust‚Ä¶ so I created it (partly because I like the feature, because it felt wrong for Rust not to have it, but mostly for the practice and fun of beating a hard and interesting problem). You can read the story if you are interested about the behind the scenes, about the feature itself, how to use it or just for fun ‚ò∫.",
      "url": "https://vorner.github.io/2018/06/24/arc-more-atomic.html",
      "date_published": "2018-06-24T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "698090f0-fa77-43b5-aaed-dcd2b71d3c39",
      "title": "Rust 2018: an early preview",
      "content_text": "The Rust teams having been working hard to implement features of the 2018 edition. Today we have reached an important milestone: we are announcing that we have an alpha-quality preview of the 2018 edition ready for testing and feedback.\n\nThe preview presents a great opportunity for those of you using the stable channel to switch to nightly and try out how it feels to code in the new edition, both to help us fix bugs and to provide feedback ‚Äì positive and negative ‚Äì on features. Unfortunately, today‚Äôs nightly doesn‚Äôt work due to infrastructure issues, so you‚Äôll need to run rustup install nightly-2018-06-20 in order to get a nightly that‚Äôll work. If you‚Äôre already on the nightly channel, it‚Äôs likely that there‚Äôs no need to update the compiler.",
      "url": "https://internals.rust-lang.org/t/rust-2018-an-early-preview/7776",
      "date_published": "2018-06-23T08:19:19+10:00",
      "author": {
        "name": "Rust Team Members",
        "url": "https://internals.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "295dac4f-f095-4d04-b6ee-a6a2870cc7fb",
      "title": "Rust review: The ecosystem",
      "content_text": "In this part of the review, I would like to focus on Rust‚Äôs ecosystem: in other words, how Rust plays with other parts of a functioning system and how Rust‚Äôs standard library vs. external libraries interact with each other. There are a lot of pieces to cover in these areas and they have left me with mixed feelings. Let‚Äôs look at some.",
      "url": "http://julio.meroh.net/2018/06/rust-review-ecosystem.html",
      "date_published": "2018-06-22T09:00:00-04:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "41f94ae9-ac3a-42fe-bc78-fbc6dab42d85",
      "title": "Announcing Rust 1.27",
      "content_text": "This release has two big language features that people have been waiting for: SIMD, and dyn Trait. Additionally there is support for searching the Rust books, and a new book about rustc.",
      "url": "https://blog.rust-lang.org/2018/06/21/Rust-1.27.html",
      "date_published": "2018-06-21T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c883f036-9e31-44b2-995a-24b575c524b8",
      "title": "From ActiveRecord to Diesel",
      "content_text": "Recently I needed to run a simple SQL query on a Postgres database and produce a one-off report. I could have done this in 5 minutes using Ruby and ActiveRecord. Instead, I decided to use Rust and Diesel ‚Äì a language and a tool I hadn‚Äôt used before. Instead of 5 minutes it took several hours, but I learned something new. I‚Äôve written up the steps I took here today. Get your mind‚Äôs exercise for today and read on to learn how to execute a SQL statement using Rust.",
      "url": "http://patshaughnessy.net/2018/6/9/from-activerecord-to-diesel",
      "date_published": "2018-06-09T03:00:00+00:00",
      "author": {
        "name": "Pat Shaughnessy",
        "url": "http://patshaughnessy.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "220b4649-e853-4f07-9773-e4ae3d286a4f",
      "title": "Proposal for a staged RFC process",
      "content_text": "I consider Rust‚Äôs RFC process one of our great accomplishments, but it‚Äôs no secret that it has a few flaws. At its best, the RFC offers an opportunity for collaborative design that is really exciting to be a part of. At its worst, it can devolve into bickering without any real motion towards consensus. If you‚Äôve not done so already, I strongly recommend reading aturon‚Äôs excellent blog posts on this topic.\n\nThe RFC process has also evolved somewhat organically over time. What began as ‚Äújust open a pull request on GitHub‚Äù has moved into a process with a number of formal and informal stages (described below). I think it‚Äôs a good time for us to take a step back and see if we can refine those stages into something that works better for everyone.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/06/20/proposal-for-a-staged-rfc-process/",
      "date_published": "2018-06-20T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0122445e-8a19-4a52-bcd6-4ee7e55feb7c",
      "title": "Rust review: The book",
      "content_text": "‚ÄúThe Rust Programming Language‚Äù is one of the free books that the community has put together to teach the language. The book does a good job in general, but there are some things that could be better. Let‚Äôs cover these, but first, some background.",
      "url": "http://julio.meroh.net/2018/06/rust-review-book.html",
      "date_published": "2018-06-19T09:00:00-04:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b5fe7539-f996-4c57-9fc1-5fa06b6a68b2",
      "title": "Rust review: The match keyword",
      "content_text": "A commonly-acclaimed feature of Rust is its match keyword: a ‚Äúconditional on steroids‚Äù. match lets you take the value of an expression and compare it against a bunch of values‚Äîor, more generally, patterns.\n\nAs you write and read Rust, you will notice that this keyword is used everywhere because it‚Äôs the way to access certain types, like Option values or error codes.",
      "url": "http://julio.meroh.net/2018/06/rust-review-match-keyword.html",
      "date_published": "2018-06-15T09:00:00-04:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "67f2f6f8-75f9-458c-969f-4bcbe9c0223f",
      "title": "Rust + Diesel + GitLab + CI",
      "content_text": "It is very straightforward to get Rust projects to build within a CI environment. This post is going to take that build process one small step further, we‚Äôre going to build a Rust project that uses the Diesel ORM. This adds a step of complexity since to compile a Diesel project you need to have a postgresql database accessible if you‚Äôre using the infer_schema!() macro.",
      "url": "https://noyez.gitlab.io/post/2018-06-15-rust-plus-diesel-plus-gitlab/",
      "date_published": "2018-06-18T00:00:00+00:00",
      "author": {
        "name": "noyez",
        "url": "https://noyez.gitlab.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "41722089-9cfe-413c-aa51-02c244fb4d67",
      "title": "Rust Is Not So Hairy",
      "content_text": "TL;DR I decided to learn Rust on my nth attempt. Writing small programs helped me get stuff done. I converted a Java gRPC service into Rust for comparison I'm super-impressed with Rust's low CPU and memory footprint.",
      "url": "https://nevi.me/rust-is-not-so-hairy/",
      "date_published": "2018-06-16T14:05:48+00:00",
      "author": {
        "name": "Neville",
        "url": "https://nevi.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "977aa3cd-7136-4d69-84ac-0c15c6396ae4",
      "title": "Dynamic Casting for Traits",
      "content_text": "In Rust, traits are a powerful tool to use polymorphism, both static and dynamic. I‚Äôm going to skip the basics about the traits and just link to another blog post with a good explanation about static and dynamic dispatch in Rust: Traits and Trait Objects in Rust.\n\nInstead, I would like to do an experiment of making dynamic dispatch even more dynamic! Like in Java1.",
      "url": "http://idubrov.name/rust/2018/06/16/dynamic-casting-traits.html",
      "date_published": "2018-06-16T00:00:00+00:00",
      "author": {
        "name": "Ivan Dubrov",
        "url": "http://idubrov.name/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c55b518c-125b-4fb9-82c5-08c3367bb6c6",
      "title": "MIR-based borrow check (NLL) status update",
      "content_text": "I‚Äôve been getting a lot of questions about the status of ‚ÄúNon-lexical lifetimes‚Äù (NLL) ‚Äì or, as I prefer to call it these days, the MIR-based borrow checker ‚Äì so I wanted to post a status update.\n\nThe single most important fact is that the MIR-based borrow check is feature complete and available on nightly. What this means is that the behavior of #![feature(nll)] is roughly what we intend to ship for ‚Äúversion 1‚Äù, except that (a) the performance needs work and (b) we are still improving the diagnostics.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/06/15/mir-based-borrow-check-nll-status-update/",
      "date_published": "2018-06-15T00:00:00-07:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "79d23f1b-0e7b-4d75-a061-9e5b9930424b",
      "title": "From Go to Rust - JSON and YAML",
      "content_text": "One of Go's big selling points for me was its novel approach to JSON encoding. Learning about Rust's encoding has made me even more excited. In this post, we'll start with Go's JSON encoder, and then see how Rust does encoding. And we'll even through in some YAML!",
      "url": "http://technosophos.com/2018/06/12/from-go-to-rust-json-and-yaml.html",
      "date_published": "2018-06-12T00:00:00+00:00",
      "author": {
        "name": "Matt Butcher",
        "url": "http://technosophos.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4749d178-b87d-4946-b8e2-0a6d17d7495e",
      "title": "Automatic Type Coercions with Procedural Macros in Rust",
      "content_text": "I briefly demonstrate how to use procedural macros to automatically perform type coercion in Rust, mimicking the behavior of dynamic languages.",
      "url": "http://willcrichton.net/notes/automatic-type-coercions-macros-rust/",
      "date_published": "2018-06-12T00:00:00+00:00",
      "author": {
        "name": "Will Crichton",
        "url": "http://willcrichton.net/notes/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f6f3b55c-c39c-4366-9de1-ebf3b230ee6c",
      "title": "What do you think are the most interesting/exciting projects using Rust?",
      "content_text": "Last week I tweeted \"What do you think are the most interesting/exciting projects using Rust? (No self-promotion :-) )\". The response was awesome! Jonathan Turner suggested I write up the responses as a blog post, and here we are.",
      "url": "https://www.ncameron.org/blog/interesting_projects/",
      "date_published": "2018-06-13T16:26:29+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language",
        "Tools and Applications"
      ]
    },
    {
      "id": "2b4b4efe-3a50-4ceb-ac4c-267b708c2ce8",
      "title": "Traits and Trait Objects in Rust",
      "content_text": "I‚Äôve been really confused lately about Rust‚Äôs trait objects. Specifically when it comes to questions about the difference between &Trait, Box<Trait>, impl Trait, and dyn Trait.",
      "url": "https://joshleeb.com/posts/rust-traits-and-trait-objects/",
      "date_published": "2018-06-12T00:00:00+00:00",
      "author": {
        "name": "Josh Leeb-du Toit",
        "url": "https://joshleeb.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8e5085a4-0057-4ed8-81dc-93242e35b6e9",
      "title": "Rust review: Expressions, expressions, expressions",
      "content_text": "Rust resembles a functional language in many ways although it does not claim to be one. In fact, I have been thinking of Rust as a ‚Äúpragmatic Haskell‚Äù or as a ‚Äúwell-balanced mixture between C++ and Haskell‚Äù.\n\nOne of the ways the functional aspects show up is via expressions and how pretty much any construct in Rust can be treated as an expression. But before we begin, a little warning: the examples below are, by no means, idiomatic Rust‚ÄîI just hope they are simple enough to illustrate what I want to show.",
      "url": "http://julio.meroh.net/2018/06/rust-review-expressions.html",
      "date_published": "2018-06-12T09:00:00-04:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "34b26ba8-daa3-431f-ba53-9c0d9d873459",
      "title": "Where do Rust threads come from?",
      "content_text": "Last week, I wrote a post in which I discussed some of the things that I learned about Rust concurrency. One of the things that I pointed out was that when you spawn a thread within another thread, they both have the main process as their parent.",
      "url": "http://squidarth.com/rc/rust/concurrency/2018/06/09/rust-threads-detach.html",
      "date_published": "2018-06-09T09:00:38-04:00",
      "author": {
        "name": "Sid Shanker",
        "url": "http://www.squidarth.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4ab9c39f-72ed-4b84-a5e7-abe4c594c019",
      "title": "First Impressions of the Rust Programming Language",
      "content_text": "C is almost 50 years old, and C++ is almost 40 years old. While age is usually indicative of mature implementations with decades of optimization under their belts, it also means that the language's feature set is mostly devoid of modern advancements in programming language design. For that reason, you see a great deal of encouragement nowadays to move to newer languages - they're designed with contemporary platforms in mind, rather than working within the limitations of platforms like the PDP-11. Among said \"new languages\" are Zig, Myrddin, Go, Nim, D, Rust.. even languages like Java and Elixir that run on a virtual machine are occasionally suggested as alternatives to the AOT-compiled C and C++.\n\nI have plans to look into the characteristics that distinguish each and every one of these new programming languages, learning them and documenting my first impressions in the form of blog posts. This post is the beginning of that adventure: my first impressions of Rust.",
      "url": "http://jakob.space/blog/post/First+Impressions+of+the+Rust+Programming+Language",
      "date_published": "2018-06-08T13:02:33-05:00",
      "author": {
        "name": "Jakob",
        "url": "http://jakob.space/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "644f8b30-47a3-4da8-b4e9-1b72755d69b0",
      "title": "Rust review: Learning curve",
      "content_text": "Writing Rust code is not restricted to programming gurus‚Äîbut there is no denying that the learning curve is steeper than that of other languages. Or is it? In this post, I'll try to convince you that the curve does feel steep, but it isn't when taken into perspective.\nLet's first start by stating that learning a language is not the same as learning its syntax. Learning a language involves learning the syntax, of course, but it also involves familiarizing oneself with its common idioms and grabbing a good sense of what the standard libraries provide.",
      "url": "http://julio.meroh.net/2018/06/rust-review-learning-curve.html",
      "date_published": "2018-06-08T09:00:00-04:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "314ba2b8-5ace-4348-b96a-b704c628e2b3",
      "title": "Safe Concurrency with Rust",
      "content_text": "Last week, I started learning Rust, and published a post about the ‚Äúownership‚Äù system. One of the places where Rust‚Äôs ownership system really shines is in threading and concurrency. Kevin and I decided to dig into this more on Friday, and did some work on the dining philosophers problem.\n\nIn this post I‚Äôll be covering what we learned, and how the Rust compiler saves you from some scary concurrency issues.",
      "url": "http://www.squidarth.com/rc/rust/2018/06/04/rust-concurrency.html",
      "date_published": "2018-06-04T09:00:38-04:00",
      "author": {
        "name": "Sid Shanker",
        "url": "http://www.squidarth.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "cebd59fa-c884-49cd-9de7-4da401e26642",
      "title": "Why PhantomData",
      "content_text": "We‚Äôre not allowed to have a type parameter that goes unused. If we want to have a type that looks like the one above we have to add a marker to it like so: struct Tagged<T>(usize, PhantomData<T>);",
      "url": "http://troubles.md/posts/why-phantomdata/",
      "date_published": "2018-06-05T13:41:30+02:00",
      "author": {
        "name": "troubles.md",
        "url": "http://troubles.md/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "901dde63-68f7-45d0-b161-cf585e47d266",
      "title": "Announcing Rust 1.26.2",
      "content_text": "This patch release fixes a bug in the borrow checker verification of match expressions. This bug was introduced in 1.26.0 with the stabilization of match ergonomics. Specifically, it permitted code which took two mutable borrows of the bar path at the same time.",
      "url": "https://blog.rust-lang.org/2018/06/05/Rust-1.26.2.html",
      "date_published": "2018-06-05T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2b743aaf-6ae4-4bda-8de9-6bef817e9a4d",
      "title": "The Future of Clippy (the Rust Linter)",
      "content_text": "We‚Äôve recently been making lots of progress on future plans for clippy and I thought I‚Äôd post an update.",
      "url": "https://manishearth.github.io/blog/2018/06/05/the-future-of-clippy-the-rust-linter/",
      "date_published": "2018-06-05T00:00:00+00:00",
      "author": {
        "name": "Manish Goregaokar",
        "url": "https://manishearth.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "046762b0-c3da-4f38-8d4a-7bb515f73d4b",
      "title": "Rust review: Protect the data",
      "content_text": "The one thing that blew my mind about Rust is its approach to data sharing in concurrent situations.\n\nI had always thought of mutexes as something that is easy to get wrong and was convinced that the use of a RAII pattern to prevent lock leaks never happen (like with Abseil‚Äôs MutexLock) was the panacea. (I‚Äôm a fan of RAII in C++ by the way, in case you haven‚Äôt noticed.)",
      "url": "http://julio.meroh.net/2018/06/rust-review-protect-the-data.html",
      "date_published": "2018-06-05T09:00:00-04:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d4896054-d302-4629-8679-7456e1a741ef",
      "title": "Async Methods II: object safety",
      "content_text": "Last time, we introduced the idea of async methods, and talked about how they would be implemented: as a kind of anonymous associated type on the trait that declares the method, which corresponds to a different, anonymous future type for each implementation of that method. Starting this week we‚Äôre going to look at some of the implications of that. The first one we‚Äôre going to look at is object safety.",
      "url": "https://boats.gitlab.io/blog/post/async-methods-ii/",
      "date_published": "2018-06-04T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d8c6d9c0-38eb-4656-a28e-0125ca9e5cd1",
      "title": "The Secret Life of Cows",
      "content_text": "A lot of people at RustFest Paris mentioned Cows ‚Äì which may be surprising if you‚Äôve never seen std::borrow::Cow!\n\nCow in this context stands for ‚ÄúClone on Write‚Äù and is a type that allows you to reuse data if it is not modified. Somehow, these bovine super powers of Rust‚Äôs standard library appear to be a well-kept secret even though they are not new. This post will dig into this very useful pointer type by explaining why in systems programming languages you need such fine control, explain Cows in detail, and compare them to other ways of organizing your data.",
      "url": "https://deterministic.space/secret-life-of-cows.html",
      "date_published": "2018-06-02T00:00:00+02:00",
      "author": {
        "name": "Pascal Hertleif",
        "url": "https://deterministic.space/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e672721a-5577-4897-b440-619731384ac1",
      "title": "Newtype Index Pattern",
      "content_text": "Similarly to the previous post, we will once again add types to the Rust code which works perfectly fine without them. This time, we‚Äôll try to improve the pervasive pattern of using indexes to manage cyclic data structures.",
      "url": "https://matklad.github.io//2018/06/03/newtype-index-pattern.html",
      "date_published": "2018-06-03T21:21:45+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d5a4da56-2e7e-4f30-bd1a-d0211958a00a",
      "title": "Async Methods I: generic associated types",
      "content_text": "Async/await continues to move along swimmingly. We‚Äôve accepted an RFC describing how the async/await syntax will work in Rust, and work is underway on implementing support for it in the compiler. We‚Äôre hopeful that users will be able to start experimenting with the syntax on nightly by early July.\n\nThe RFC for async/await didn‚Äôt address one important thing: async methods. It is very important for people defining libraries to be able to define traits that contain async functions, like this:",
      "url": "https://boats.gitlab.io/blog/post/async-methods-i/",
      "date_published": "2018-05-31T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "19239f2e-41c0-44cb-8b3d-02199eaa57b1",
      "title": "Infinite Negative Utility: The Rust Language and Special Cases",
      "content_text": "I first came across Rust back in 2010 or 2011, and it was a very different language than the one it is today, both syntactically and semantically. I remember at the time that newcomers would often complain loudly about the terse keywords‚Äîlike the fact that the return keyword had been shortened to ret‚Äîand the omnipresent tildes scattered throughout the language like fallen leaves in autumn. My programming background was in functional languages‚Äîspecifically in Scheme and Haskell‚Äîand I found this language fascinating, sitting in an interesting and unexplored place in the spectrum of programming languages and bringing something genuinely new to the table.",
      "url": "https://blog.infinitenegativeutility.com/2018/6/the-rust-language-and-special-cases",
      "date_published": "2018-06-01T00:00:00+00:00",
      "author": {
        "name": "Getty Ritter",
        "url": "https://blog.infinitenegativeutility.com/archive"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1572c586-709c-44a9-9232-ae4d3b9466ec",
      "title": "The Go Developer's Quickstart Guide to Rust",
      "content_text": "As the co-author of Go in Practice, I have felt a certain obligation to Go. But I'm ready for a change. Rust topped the satisfaction survey in Stack Overflow's survey of languages (screenshot above). I've decided to give it a try. While Go and Rust are often compared, they are remarkably different languages.\n\nComing from a Go background, there are things about Rust that feel very natural, and things (like memory management) that feel utterly foreign. And so as I learn Rust, I am cataloging how it feels for a Go programmer. And rather than leading others to \"dive in at the deep end\" as I did (when I tried to write a full web service), I decided to approach Rust by starting with similarities and working toward differences.",
      "url": "http://technosophos.com/2018/05/27/the-go-developers-quickstart-guide-to-rust.html",
      "date_published": "2018-05-27T00:00:00+00:00",
      "author": {
        "name": "Matt Butcher",
        "url": "http://technosophos.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "09d6be59-4bee-49e0-aa34-d43622422cb8",
      "title": "Rust review: The borrow checker",
      "content_text": "Aaaah, the borrow checker: the dreaded enemy lurking within the Rust compiler, ready to make its move to bring pain to your life by preventing your code from compiling. Or that‚Äôs what everyone seems to say, which is one of the reasons I put off learning Rust for so long. In reality‚Ä¶ the borrow checker is a blessing, but it is true that getting past its gates is difficult at first.",
      "url": "http://julio.meroh.net/2018/06/rust-review-borrow-checker.html",
      "date_published": "2018-06-01T09:00:00-04:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ab635755-efd4-432a-8407-7b1c94649f8f",
      "title": "Tricking the HashMap",
      "content_text": "Is it possible to find something in a hashmap if the key you are looking for is not exactly the same as the one you put into that hashmap? At first glance, this might not make any sense at all. The whole purpose of a hashmap is to store something under some key and then look it up using the same key. Right?",
      "url": "https://idubrov.github.io/rust/2018/06/01/tricking-the-hashmap.html",
      "date_published": "2018-06-01T00:00:00+00:00",
      "author": {
        "name": "Ivan Dubrov",
        "url": "https://idubrov.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "80930880-f4a9-4485-b372-648928490dca",
      "title": "Assignment Semantics in Python, JavaScript, Java, C++, and Rust",
      "content_text": "What happens when a data collection is copied and then the new copy is changed? Does the original remain the same, or does it change too?\n\nIf you think of copying as creating a completely new object, of course you expect that any change to the new copy does not affect the original object. But if you think of copying as creating a new name for the same, single object, then you expect that any change to the object through the new name appears also when you access the same object through the old name.\n\nLet's see how is the behavior of Python, Javascript, Java, C++, and Rust regarding the assignment operator (\"=\") between collection variables.",
      "url": "https://www.apress.com/us/blog/all-blog-posts/assignment-semantics/15805464",
      "date_published": "2018-06-01T00:00:00+00:00",
      "author": {
        "name": "Carlo Milanesi",
        "url": "https://www.apress.com/us/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1f808812-4e70-4dcb-90a0-c45964863cd5",
      "title": "Fear not the Rust Borrow Checker",
      "content_text": "I spent pretty much the whole day banging my head against the wall trying to figure out how ownership and borrowing work in Rust, and finally have a grasp on what‚Äôs going on.\n\nIn this post I‚Äôm going to demonstrate how these concepts work through some examples of code that break Rust‚Äôs rules, and explain why they‚Äôre problematic. I assume very little knowledge of the Rust programming language. I‚Äôve also added comments to all of the code blocks that indicate whether the code is valid Rust or not.",
      "url": "http://www.squidarth.com/rc/rust/2018/05/31/rust-borrowing-and-ownership.html",
      "date_published": "2018-05-31T12:00:38-04:00",
      "author": {
        "name": "Sid Shanker",
        "url": "http://www.squidarth.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "aea72b83-8f56-4c8d-a9d7-c88fded0cfc7",
      "title": "Mutagen - An Inopportune Consumption",
      "content_text": "I just failed to implement what looked to be a relatively simple opportunistic replacement so that the compiler would accept the mutated code. But I‚Äôm getting ahead of myself.",
      "url": "https://llogiq.github.io/2018/05/30/inop.html",
      "date_published": "2018-05-30T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "12f71ab8-809a-45a6-8e95-fd98a92e7f60",
      "title": "Why put Rust in our Python Monitoring agent?",
      "content_text": "Prior to adding Python performance monitoring, we'd written monitoring agents for Ruby and Elixir. Our Ruby and Elixir agents had duplicated much of their code between them, and we didn't want to add a third copy of the agent-plumbing code. The overlapping code included things like JSON payload format, SQL statement parsing, temporary data storage and compaction, and a number of internal business logic components.\n\nThis plumbing code is about 80% of the agent code! Only 20% is the actual instrumentation of application code.\n\nSo, starting with Python, our goal became \"how do we prevent more duplication\". In order to do that, we decided to split the agent into two components. A language agent and a core agent. The language agent is the Python component, and the core agent is a standalone executable that contains most of the shared logic.",
      "url": "http://blog.scoutapp.com/articles/2018/04/10/why-put-rust-in-our-python-monitoring-agent",
      "date_published": "2018-04-05T07:46:00-04:00",
      "author": {
        "name": "Chris",
        "url": "http://blog.scoutapp.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d9877c7d-7175-490d-89a8-46fad05d9903",
      "title": "Rust review: Immutable by default",
      "content_text": "Let‚Äôs start the deep dive by looking into a powerful feature of Rust: all variables and references are immutable by default unless qualified with mut.\nTo understand why this is important, let‚Äôs cover some context first. One of my pet peeves when reviewing C++ code is to ask authors to sprinkle the const qualifier everywhere: if something ain‚Äôt mutated, say so explicitly. This includes marking local variables, function arguments, function return values, class attributes, etc.",
      "url": "http://julio.meroh.net/2018/05/rust-review-immutable-by-default.html",
      "date_published": "2018-05-29T09:00:00-04:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "da46cfde-97b2-4e16-9e08-4308a34d6826",
      "title": "Evolving Rust",
      "content_text": "When you're just building some very basic tool programs, I'd probably not even think about threading in C, but here it is so easy that I've been quick to drop a (for example, typically) 30ms loop down to 3.5ms. One of the things I've been somewhat missing is easy access to SIMD intrinsics, but this brings me to something else I've been enjoying this year: Rust is evolving.",
      "url": "https://blog.shivoa.net/2018/05/evolving-rust.html",
      "date_published": "2018-05-29T12:11:00+01:00",
      "author": {
        "name": "Shivoa Birch",
        "url": "https://plus.google.com/104688779548004579468"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ae63f930-3568-433f-b8e6-35feb516b4c2",
      "title": "Announcing Rust 1.26.1",
      "content_text": "A couple of issues were found in 1.26.0 which were deemed sufficient for a patch release.\n\nA quick summary of the changes:\n\nRLS no longer interferes with command line builds\nRustfmt stopped badly formatting text in some cases\nReturning from main via impl Trait where the Trait is not Termination is no longer permitted\n::<> (turbofish) no longer works for method arguments whose type is impl Trait\n\nNaN > NaN no longer returns true in const contexts\nrustup should no longer fail due to missing documentation on some platforms",
      "url": "https://blog.rust-lang.org/2018/05/29/Rust-1.26.1.html",
      "date_published": "2018-05-29T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "95a6f9d4-dcfa-4b20-8ee7-f240cde435b1",
      "title": "Exploring Rust fat pointers",
      "content_text": "Beware that at any point the code here may stop compiling, segfault, and otherwise behave in weird ways, some of which involve Velociraptors.\n\nNow that that‚Äôs out of the way, what is a fat pointer anyway? All pointers are the same right? Just a number indicating an address in memory. Well, yes and no.",
      "url": "https://iandouglasscott.com/2018/05/28/exploring-rust-fat-pointers/",
      "date_published": "2018-05-28T02:46:00-07:00",
      "author": {
        "name": "Ian Douglas Scott",
        "url": "https://iandouglasscott.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e0370259-0204-491d-9bd1-3769a682f6e1",
      "title": "Fuzz testing in Rust with Cargo-fuzz",
      "content_text": "In this post, I go through how I added the first automated fuzz test for my hobby project Hat‚Ää‚Äî‚Ääa snapshotting backup system written in Rust. I‚Äôll briefly go through what a fuzz test is and how it works. In a follow-up post, I will share how I made the test more effective by running it through Seasoned Software.",
      "url": "https://medium.com/@seasoned_sw/fuzz-testing-in-rust-with-cargo-fuzz-13b89feecc30",
      "date_published": "2018-05-25T10:08:45.112+00:00",
      "author": {
        "name": "Seasoned Software",
        "url": "https://medium.com/@seasoned_sw"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d25787d1-089e-4455-ac6a-1183548d48cd",
      "title": "Rust review: Introduction",
      "content_text": "I had been meaning to learn Rust since I first toyed with Go a couple of years ago. During this period, I‚Äôve written a non-trivial amount of Go code both inside and outside Google, but never found the chance to sit back and learn Rust.\n\nThis changed a month ago during my yearly family trip to Korea. This time around, I decided upfront that I would not work on any personal or work projects for the 2-week long vacation. Instead, I would focus all spare time in reading. And I would read ‚ÄúThe Rust Programming Language‚Äù, second edition. The plan worked: getting through the book took the two weeks and I barely wrote any code.",
      "url": "http://julio.meroh.net/2018/05/rust-review-introduction.html",
      "date_published": "2018-05-25T09:00:00-04:00",
      "author": {
        "name": "Julio Merino",
        "url": "http://julio.meroh.net/series.html#Rust%20review"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5b8ae1bc-5625-4115-ab3a-3f399e157314",
      "title": "Typed Key Pattern",
      "content_text": "In this post, I‚Äôll talk about a pattern for extracting values from a weakly typed map. This pattern applies to all statically typed languages, and even to dynamically typed ones, but the post is rather Rust-specific.",
      "url": "https://matklad.github.io/2018/05/24/typed-key-pattern.html",
      "date_published": "2018-05-24T10:18:13+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7518f181-39ba-4c9c-a76d-1a07b697d264",
      "title": "Moving out of a Drop struct in Rust?",
      "content_text": "Rust doesn‚Äôt allow you to move out of a value which type implements Drop, and this is quite logical. When Foo::take returns, because of self going out of scope, it must call its Drop::drop implementation. If you have moved out of it ‚Äì both a: A and b: B fields, the Drop::drop implementation is now a complete UB. So Rust is right here and doesn‚Äôt allow you to do this.\n\nBut imagine that we have to do this. For insance, we need to hand over both the scarce resources a and b to another struct (in our case, a (A, B), but you could easily imagine a better type for this).\n\nThere‚Äôs a way to, still, implement Foo::take with Foo implementing Drop. Here‚Äôs how:",
      "url": "http://phaazon.netkblog/rust-no-drop",
      "date_published": "2018-05-22T22:22:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "80818d94-c29b-47b1-8307-f5c9e1d03808",
      "title": "impl Trait in Rust explanation",
      "content_text": "In Rust 1.26 a new feature called impl Trait was stabilized. How does it work? Instead of specifying an exact type, you can say that your function either returns or takes something that implements a trait.",
      "url": "https://medium.com/@iopguy/impl-trait-in-rust-explanation-efde0d94946a",
      "date_published": "2018-05-23T04:37:08.411+00:00",
      "author": {
        "name": "Igor Polyakov",
        "url": "https://medium.com/@iopguy"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d2971f3f-a40d-45c9-a544-ed94f3b962f6",
      "title": "Rust is Incredibly Productive for CLIs",
      "content_text": "I built a little tool in Rust to convert an Evernote export file to Markdown. It was impressively easy.",
      "url": "https://www.chriskrycho.com/2018/rust-is-incredibly-productive-for-clis.html",
      "date_published": "2018-05-20T08:35:00-04:00",
      "author": {
        "name": "Chris Krycho",
        "url": "https://www.chriskrycho.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "940f0d10-67ee-49d4-a243-d4310077a962",
      "title": "Asynchronous warmy: a prequel",
      "content_text": "Last weeks were interesting for warmy, a crate I‚Äôve been writing for several weeks / months now that enables you to hot load and reload scarce resources ‚Äì e.g. textures, meshes, configuration, JSON parameters, dependency nodes, whatever. warmy received several interesting features.",
      "url": "http://phaazon.net/blog/asynchronous_warmy_prequel",
      "date_published": "2018-05-08T19:30:00+00:00",
      "author": {
        "name": "Dimitri Sabadie",
        "url": "http://phaazon.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "999b0809-c97d-42c2-b102-d8d2567e8979",
      "title": "A boolean's story",
      "content_text": "Earlier this month I told you about my pet project in Rust.\n\nAs a reminder, it‚Äôs a tool named rusync which contains some of the functionality offered by the rsync command-line tool.\n\nToday I‚Äôd like to talk about a feature I‚Äôve added recently, and take this opportunity to show you a few principles of good design along the way.",
      "url": "https://dmerej.info/blog/post/a-booleans-story/",
      "date_published": "2018-05-18T13:50:38+00:00",
      "author": {
        "name": "Dimitri Merejkowsky",
        "url": "https://dmerej.info/blog/humans.txt"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6e5c626c-f240-41fa-9520-a3d5586523b3",
      "title": "Rust for Android games using SDL2",
      "content_text": "I've been wanting to write a simple Android game for my daughter, and decided to use it as an excuse to learn Rust.  Thus began an odyssey.\n\nI'll ignore the game itself in this post in favour of describing how to get a simple Rust on Android game environment.  For my game I didn't want anything fancy - I wanted to load some jpg files and blit rectangles from those textures to the screen.  But I don't know OpenGL, and I don't really feel the need to learn for this project - if I hit the need to use a shader, then I backtracked and tried another approach.  The plan was to get a simple, high-level graphics API for Rust running on Android.",
      "url": "https://lliwynd.blogspot.com.au/2018/05/rust-for-android-games-using-sdl2.html",
      "date_published": "2018-05-19T16:15:00+10:00",
      "author": {
        "name": "William Uther",
        "url": "https://lliwynd.blogspot.com.au/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2bdd1638-e211-477d-8bb8-3ae0de703661",
      "title": "FizzBuzz Can Finally Be Implemented in Stable Rust",
      "content_text": "I have been editing my FizzBuzz repository since 2014. After four years, I was finally able to switch from nightly to stable due to the 1.26 release. Let‚Äôs back up a little bit and appreciate the changes since the first revision.",
      "url": "https://medium.com/@iopguy/fizzbuzz-can-finally-be-implemented-in-stable-rust-87649a882f2d",
      "date_published": "2018-05-17T17:23:27.319+00:00",
      "author": {
        "name": "Igor Polyakov",
        "url": "https://medium.com/@iopguy"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c1e5c8e3-46e1-412d-98fe-6735ad9e4f19",
      "title": "Compile Time Prevention of SQL-Injections in Rust",
      "content_text": "SQL injection vulnerabilities have been a plague ever since such databases have been combined with user facing applications. Such vulnerabilities arise when a SQL query string is naively combined with data that is controlled by an attacker.\n\nTo mitigate, people should make use of placeholders and prepared statements provided by SQL client libraries. This separates the variable data from the actual query, ensuring that these two never mix. Pretty much all modern SQL client libraries offer this functionality, but of course, it‚Äôs still possible to mix variable data and SQL by means of string concatenation.",
      "url": "https://polyfloyd.net/post/compile-time-prevention-of-sql-injections/",
      "date_published": "2018-05-18T00:00:00+00:00",
      "author": {
        "name": "polyfloyd",
        "url": "https://polyfloyd.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "50ca4f3e-2051-4779-adf4-a12615b72d99",
      "title": "Rust turns three",
      "content_text": "Three years ago today, the Rust community released Rust 1.0 to the world, with our initial vision of fearless systems programming. As per tradition, we‚Äôll celebrate Rust‚Äôs birthday by taking stock of the people and the product, and especially of what‚Äôs happened in the last year.",
      "url": "https://blog.rust-lang.org/2018/05/15/Rust-turns-three.html",
      "date_published": "2018-05-15T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c65ddae5-51e1-4eb4-96ab-365e0d819d0f",
      "title": "Announcing Rust 1.26",
      "content_text": "The past few releases have had a steady stream of relatively minor additions. We‚Äôve been working on a lot of stuff, however, and it‚Äôs all starting to land in stable. 1.26 is possibly the most feature-packed release since Rust 1.0.",
      "url": "https://blog.rust-lang.org/2018/05/10/Rust-1.26.html",
      "date_published": "2018-05-10T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a7a257bb-3da8-42f1-b341-dad7221b9ab3",
      "title": "Rust: Enterprise Services Need Not Suck",
      "content_text": "I practice Barbarian Leadership. Standing on the back lines with hand in pocket giving orders is missing the fun. More importantly, knowledge is created on the cutting edge of action. People you work with know this. They value modern, non-hierarchical organizations where a leader dives into the fray, sword in hand, and gets to know intimately the problems and tools for solving them. So I dove into the fight despite knowing that it is ‚Äúhard language‚Äù.",
      "url": "https://medium.com/@paulhoughton/rust-enterprise-services-need-not-suck-679b79edcab5",
      "date_published": "2018-05-07T12:59:10.610+00:00",
      "author": {
        "name": "Paul Houghton",
        "url": "https://medium.com/@paulhoughton"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7fe0f8aa-fbe1-4fef-bba3-e64b98b00bc2",
      "title": "Procedural Macros in Rust",
      "content_text": "Procedural macros are a really powerful language feature in Rust and something I haven‚Äôt seen in many other languages.\n\nThere are a heap of tutorials out there for procedural macros, including in The Rust Reference, and the first edition of the Rust Book. One of the more entertaining (and useful) posts is by Zach Mitchell where you get to ‚Äúlearn Rust procedural macros with Nic Cage‚Äù.\n\nI won‚Äôt go into depth about what procedural macros are and why they‚Äôre so powerful.",
      "url": "https://joshleeb.com/posts/rust-procedural-macros/",
      "date_published": "2018-05-04T00:00:00+00:00",
      "author": {
        "name": "Josh Leeb-du Toit",
        "url": "https://joshleeb.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "cb34566e-4c96-4191-9179-eca6bc9ac07f",
      "title": "Embedding Rustup into Cargo and the Wrapper",
      "content_text": "One of my issue when building a project from scratch is the amount of manual steps required to be able to run a simple project. This is not so much a concern when you are a single developer but the larger the team, the most obvious it becomes.",
      "url": "https://medium.com/@tibotz/embedding-rustup-into-cargo-and-the-wrapper-d5b447f381fc",
      "date_published": "2018-05-04T05:53:28.079+00:00",
      "author": {
        "name": "Tibo Delor",
        "url": "https://medium.com/@tibotz"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "266098f6-079e-42d6-8d15-3a7867687f49",
      "title": "Refactoring Apache Arrow to use traits and generics",
      "content_text": "I am currently working on a refactor of the Rust implementation of Apache Arrow to change the way that arrays are represented. This is a relatively large change even though this is a tiny codebase so far and I thought it would be good to write up this blog post to explain why I think this is needed. I think this information will also be interesting for any Rust developer who is struggling with making the right choice between (or using the right combination of) enums, structs, generics and traits. I was inspired to write this up after reading this blog post that was posted to Reddit just a few days ago.",
      "url": "https://andygrove.io/2018/05/apache-arrow-traits-generics/",
      "date_published": "2018-05-04T00:00:00+00:00",
      "author": {
        "name": "Andy Grove",
        "url": "https://andygrove.io/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ca367462-e3ba-4b03-9b46-05b7850bdcba",
      "title": "Encapsulating Lifetime of the Field",
      "content_text": "This is a post about an annoying Rust pattern and an annoyingworkaround, without a good solution :)",
      "url": "https://matklad.github.io/2018/05/04/encapsulating-lifetime-of-the-field.html",
      "date_published": "2018-05-04T17:47:23+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d9100be3-bb0c-4ea5-9aff-3fa3b7946b12",
      "title": "Rust in production at Figma",
      "content_text": "How Mozilla‚Äôs new language dramatically improved our server-side performance.",
      "url": "https://blog.figma.com/rust-in-production-at-figma-e10a0ec31929",
      "date_published": "2018-05-02T15:14:00.276+00:00",
      "author": {
        "name": "Evan Wallace",
        "url": "https://blog.figma.com/@evanwallace"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "fce158e9-2134-4c57-bbc8-67483dc0b0d8",
      "title": "rustref - memorable Rust reference links",
      "content_text": "This contains shorthand URLs for navigating to Rust documentation.",
      "url": "https://rustref.com/",
      "date_published": "2018-04-27T20:12:36+00:00",
      "author": {
        "name": "Mackenzie Hauck",
        "url": "https://github.com/nocduro"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4539d16d-f909-4fff-9eda-dc6763fa7a3b",
      "title": "Mutagen ‚Äì More opportunities",
      "content_text": "Recently I gave a talk at our Rust Meetup about mutagen, and I also showed how our opportunistic mutations work (I however left out that gnarly thing about shifts, but in my defense I was short on time). That got me thinking whether we always do the right thing elsewhere.",
      "url": "https://llogiq.github.io/2018/05/01/moreop.html",
      "date_published": "2018-05-01T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e5b4d06d-c604-42fa-9329-e4bec9f44cfd",
      "title": "Dataframes: Traits, Enums, Generics, and Dynamic Typing",
      "content_text": "I‚Äôm attempting to build a dataframe in Rust. I implemented a pattern using traits, generics, and enums in conjunction to deal with columns of different datatypes while allowing runtime reflection for accessing the data stored in a column.",
      "url": "https://blog.hwc.io/posts/dataframe1/",
      "date_published": "2018-03-28T09:57:53-04:00",
      "author": {
        "name": "hwc",
        "url": "https://blog.hwc.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "803b6bf7-0cde-4a49-9e63-a117e95de2c0",
      "title": "Adventures in Rust",
      "content_text": "A tale of my time in Rust-land",
      "url": "https://dev.to/tmr232/adventures-in-rust-56fc",
      "date_published": "2018-04-27T00:00:00+00:00",
      "author": {
        "name": "Tamir Bahar",
        "url": "https://dev.to/tmr232"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1d371a92-135a-4456-aca8-5537c9d53c81",
      "title": "Installing Rust Offline",
      "content_text": "I wanted to use Rust on an offline Linux system, but it seemed like there isn‚Äôt a nice guide to install Rust and some popular packages all in one go (like Anaconda, though what I describe here is much more ghetto), so I decided to summarize the procedure to install the Rust toolchain and some popular libraries all in one go on a system with no internet access.",
      "url": "https://hatsunearu.github.io/2018/04/29/rust-offline/",
      "date_published": "2018-04-29T14:00:00+00:00",
      "author": {
        "name": "hatsunearu",
        "url": "https://hatsunearu.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1c59d8b2-c755-4f10-859e-4847be81bc4c",
      "title": "How to speed up the Rust compiler in 2018",
      "content_text": "18 months ago I wrote about some work I did to speed up the Rust compiler (rustc). I‚Äôve recently taken this work up again. Also, in the meantime rustc‚Äôs build system has been replaced and its benchmark suite has been overhauled. So it‚Äôs a good time for an update.",
      "url": "https://blog.mozilla.org/nnethercote/2018/04/30/how-to-speed-up-the-rust-compiler-in-2018/",
      "date_published": "2018-04-30T04:13:45+00:00",
      "author": {
        "name": "Nicholas Nethercote",
        "url": "https://blog.mozilla.org/nnethercote/"
      },
      "tags": [
        "Language",
        "Performance"
      ]
    },
    {
      "id": "5e0ef28e-278a-48f1-92d1-256a37f76e47",
      "title": "Borrowing in async code",
      "content_text": "The networking working group is pushing hard on async/await notation for Rust, and @withoutboats in particular wrote a fantastic blog series working through the design space. I wanted to talk a little bit about some of the implications of async/await, which may not have been entirely clear. In particular, async/await is not just about avoiding combinators; it completely changes the game for borrowing.",
      "url": "http://aturon.github.io/2018/04/24/async-borrowing/",
      "date_published": "2018-04-24T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "282a816f-1c0b-4efc-9939-0674020ee1ef",
      "title": "An alias-based formulation of the borrow checker",
      "content_text": "Ever since the Rust All Hands, I‚Äôve been experimenting with an alternative formulation of the Rust borrow checker. The goal is to find a formulation that overcomes some shortcomings of the current proposal while hopefully also being faster to compute. I have implemented a prototype for this analysis. It passes the full NLL test suite and also handles a few cases ‚Äì such as #47680 ‚Äì that the current NLL analysis cannot handle. However, the performance has a long way to go (it is currently slower than existing analysis). That said, I haven‚Äôt even begun to optimize yet, and I know I am doing some naive and inefficient things that can definitely be done better; so I am still optimistic we‚Äôll be able to make big strides there.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/",
      "date_published": "2018-04-27T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "67b88f7c-7b39-43ad-863a-0d03dd180faf",
      "title": "Reflections on Rust, and the Sand Castle Metaphor",
      "content_text": "A month ago, I wrote about how I was frustrated with my progress in Rust. These days, I‚Äôm still no expert, but I‚Äôve made progress.",
      "url": "https://brandur.org/fragments/rust-reflections",
      "date_published": "2018-04-27T00:00:00+00:00",
      "author": {
        "name": "Brandur Leach",
        "url": "https://brandur.org"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "49014ace-e742-49f8-887a-8fa7d1b627cc",
      "title": "Rust Case Study: Chucklefish Taps Rust to Bring Safe Concurrency to Video Games [pdf]",
      "content_text": "Chucklefish, an independent game studio based in London, publishes hit video games like Stardew Valley and Starbound. Now, the company is developing its next game, code-named Witchbrook, using the Rust programming language instead of C++. Why the switch? Two main reasons: to get better performance on multiprocessor hardware and to have fewer crashes during game play.",
      "url": "https://www.rust-lang.org/pdfs/Rust-Chucklefish-Whitepaper.pdf",
      "date_published": "2018-04-23T17:38:56+00:00",
      "author": {
        "name": "The Rust Project Developers",
        "url": "https://www.rust-lang.org/en-US/whitepapers.html"
      },
      "tags": [
        "Language",
        "Games and Graphics"
      ]
    },
    {
      "id": "76fb9740-07d0-45c8-a6b3-17534f293c54",
      "title": "Ask an expert: How do you maintain Rust?",
      "content_text": "From team structure and annual surveys to RFCs and the release process, a staff research engineer on Mozilla‚Äôs Rust team shares what it takes.",
      "url": "https://increment.com/programming-languages/maintaining-rust/",
      "date_published": "2018-04-26T19:00:00+00:00",
      "author": {
        "name": "Jonathan Turner",
        "url": "https://increment.com/programming-languages/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "096f02f7-0ce4-41ef-8896-f8209ca126f5",
      "title": "GLib/GIO async operations and Rust futures + async/await",
      "content_text": "With the latest GIT version of the Rust bindings for GLib, GTK, etc it is now possible to make use of the Rust futures infrastructure for GIO async operations and various other functions. This should make writing of GNOME, and in general GLib-using, applications in Rust quite a bit more convenient.",
      "url": "https://coaxion.net/blog/2018/04/glib-gio-async-operations-and-rust-futures-async-await/",
      "date_published": "2018-04-23T08:46:32+00:00",
      "author": {
        "name": "Sebastian Dr√∂ge",
        "url": "https://coaxion.net/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4eb3e72f-dec7-445e-9cbe-5464f3df1ceb",
      "title": "Rust memory safety revolution",
      "content_text": "This introduction is written for people, who are programmers, but don‚Äôt know Rust or are at the very beginning of learning it. It‚Äôs easier to understand for readers who know C, C++ or other language with manually managed memory as well as some with garbage collector. It‚Äôs a high-level introduction intended to present core Rust concepts and encourage further learning. It‚Äôs not a tutorial, there is no Hello Rust in the end.",
      "url": "https://anixe.pl/content/news/rust_memory_safety_revolution",
      "date_published": "2018-04-03T00:00:00+00:00",
      "author": {
        "name": "Igor ≈ªuk",
        "url": "https://anixe.pl/news"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "017d9ce1-f259-4d95-bffc-b3d44dfc8cde",
      "title": "Dev-tools in 2018",
      "content_text": "This is a bit late (how is it the middle of April already?!), but the dev-tools team has lots of exciting plans for 2018 and I want to talk about them! Our goals for 2018 Here's a summary of our goals for the year. Ship it! We want to ship",
      "url": "https://www.ncameron.org/blog/dev-tools-in-2018/",
      "date_published": "2018-04-19T19:31:53+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4096f192-ba2d-4a25-b1be-f3e4b0b40b51",
      "title": "BYO Standard: An Explorer's Guide to Complier Plugins",
      "content_text": "The Rust programming language provides powerful guarantees around memory and thread safety. It also exposes all the knobs required for implementing custom rules, enabling a project to make additional guarantees and enforce opinions on best practice. Embedded standards are very opinionated about software practices‚Äîlike using floating point values as loop counters or the number of possible exit points of a function‚Äîand Rust‚Äôs defaults don‚Äôt prevent every runtime panic (for example, recursion that goes too deep and overflows the stack).\n\nFor PolySync, a runtime panic means the potential for an unsafe situation on the road, and with that in mind, we‚Äôve explored ways to restrict that potential. Of course, we aren‚Äôt the only ones thinking about ways to improve the quality of code at compile time by enforcing the right rules for the job. Active projects like rust-clippy are working to do that too by providing lints to supplement the rustc defaults.\n\nIn this post we‚Äôll explore how to enforce a rule by prohibiting a practice we‚Äôve formed an opinion about, the indexing of a vector or an array.",
      "url": "https://polysync.io/explorers-guide-to-compiler-plugins",
      "date_published": "2018-04-21T00:00:00+00:00",
      "author": {
        "name": "Shea Newton",
        "url": "https://polysync.io/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ba2b10d2-16a7-4036-8e8f-1fe0d113b0ac",
      "title": "Why Rust's error handling is awesome",
      "content_text": "This post is about the process of transforming something you would write as a one-off script in Python (or any other scripting language) into a library including error handling.",
      "url": "http://rantsideasstuff.com/posts/2018/04/20-rust-error-handling-awesome/",
      "date_published": "2018-04-20T10:00:00+02:00",
      "author": {
        "name": "Zoran Zaric",
        "url": "http://rantsideasstuff.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "89612f07-abeb-400f-8bf1-0826601e17d1",
      "title": "Rust pattern: Rooting an Rc handle",
      "content_text": "I‚Äôve decided to do a little series of posts about Rust compiler errors. Each one will talk about a particular error that I got recently and try to explain (a) why I am getting it and (b) how I fixed it. The purpose of this series of posts is partly to explain Rust, but partly just to gain data for myself. I may also write posts about errors I‚Äôm not getting ‚Äì basically places where I anticipated an error, and used a pattern to avoid it. I hope that after writing enough of these posts, I or others will be able to synthesize some of these facts to make intermediate Rust material, or perhaps to improve the language itself.",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/04/16/rust-pattern-rooting-an-rc-handle/",
      "date_published": "2018-04-16T00:00:00-04:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "447b930e-7350-4ef3-80d4-2ec23a4c5708",
      "title": "Implementing multiprocessing.pool.ThreadPool from Python in Rust",
      "content_text": "In this post, we will implement multiprocessing.pool.ThreadPool from Python in Rust. It represents a thread-oriented version of multiprocessing.Pool, which offers a convenient means of parallelizing the execution of a function across multiple input values by distributing the input data across processes. We will use an existing thread-pool implementation and focus on adjusting its interface to match that of multiprocessing.pool.ThreadPool.",
      "url": "https://blog.petrzemek.net/2018/04/16/implementing-multiprocessing-pool-threadpool-from-python-in-rust/",
      "date_published": "2018-04-16T15:14:15+00:00",
      "author": {
        "name": "Petr Zemek",
        "url": "https://blog.petrzemek.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c3057e94-6b2a-4f19-b109-d6f7b17aefbe",
      "title": "A Useful Feature Few Rust Programmers Know About",
      "content_text": "Surprisingly few know about the built-in pretty-printer. In the book, there is only a short passage that mentions {:#?} in passing. It aligns structs and enums based on nested positions and is automatically derived with Debug.",
      "url": "http://rickyhan.com/jekyll/update/2018/04/16/the-best-kept-secret-rust-feature.html",
      "date_published": "2018-04-16T04:00:00+00:00",
      "author": {
        "name": "Ricky Han",
        "url": "http://rickyhan.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f4d6ff64-87eb-466f-94a6-fbbaa28fab7d",
      "title": "From Chaos to Order -- Tools and Techniques for Testing TiDB, A Distributed NewSQL Database",
      "content_text": "As an open source distributed NewSQL Hybrid Transactional/Analytical Processing (HTAP) database, TiDB contains the most important asset of our customers--their data. One of the fundamental and foremost requirements of our system is to be fault-tolerant. But how do you ensure fault tolerance in a distributed database? This article covers the top fault injection tools and techniques in Chaos Engineering, as well as how to execute Chaos practices in TiDB.",
      "url": "https://pingcap.com/blog/chaos-practice-in-tidb/",
      "date_published": "2018-04-14T00:00:00+00:00",
      "author": {
        "name": "Siddon Tang",
        "url": "https://pingcap.com/blog"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "a38c18ee-88ab-46dd-994c-2c4e4d288d4c",
      "title": "Instance Identity in C++ and Rust",
      "content_text": "A document describing how (in my opinion) C++‚Äôs and Rust‚Äôs definitions of object instance differ.",
      "url": "https://jrvanwhy.github.io/instance-identity/",
      "date_published": "2018-04-10T21:04:09+00:00",
      "author": {
        "name": "Johnathan Van Why",
        "url": "https://jrvanwhy.github.io/instance-identity/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "b92200f5-9ac0-4104-9b0d-f444c55aceb8",
      "title": "Rust CLI Survey Results",
      "content_text": "Over the month of March 2018, we've been accepting responses to the Rust CLI Survey. This survey was designed to give us some areas of focus, according to the community, for the CLI Working Group (CLI-WG).\n\nOne of the goals of Rust 2018 is to make writing command line applications in Rust as frictionless (and fun!) as possible. And we are super excited to say: we've received 1,045 responses! The results, while varied, paint a pretty clear picture for tangible goals.",
      "url": "https://github.com/rust-lang-nursery/cli-wg/blob/master/survey-results/Readme.md",
      "date_published": "2018-04-12T22:26:15+00:00",
      "author": {
        "name": "Rust CLI Working Group",
        "url": "https://github.com/rust-lang-nursery/cli-wg"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ba7af9ee-e916-4d65-b7b2-c6afa2477ade",
      "title": "Down a Rusty Rabbit Hole",
      "content_text": "Last week I fell down a rather interesting rabbit hole in Rust, which was basically me discovering a series of quirks of the Rust compiler/language, each one leading to the next when I asked ‚Äúwhy?‚Äù",
      "url": "https://manishearth.github.io/blog/2018/04/12/down-a-rusty-rabbit-hole/",
      "date_published": "2018-04-12T00:00:00+00:00",
      "author": {
        "name": "Manish Goregaokar",
        "url": "https://manishearth.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "30fe522c-e827-436a-bd52-40314d80e95b",
      "title": "The Challenge of Using C in Safety-Critical Applications [pdf]",
      "content_text": "Software errors in safety-critical systems can have severe consequences: property-loss, environmental devastation, injury, or death. Despite the severity of these risks, software continues to be written for safety-critical applications in languages that permit common classes of failures, such as undefined behavior, state corruption, and unexpected termination. One such language is C. Language standards that define allowable subsets (e.g. MISRA) and static analysis tools are often used in an attempt to ameliorate these failures by detecting them in the program code before they result in a critical issue at runtime. These traditional methods are ultimately insufficient when it comes to providing ahead-of-time assurances about safe runtime behavior for safety-critical applications. Alternative approaches must be considered.",
      "url": "https://polysync.io/s/The-Challenge-of-Using-C-in-Safety-Critical-Applications.pdf",
      "date_published": "2018-04-11T08:54:41.128+00:00",
      "author": {
        "name": "Shea Newton, Nathan Aschbache",
        "url": "https://polysync.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2238849b-fcc8-4bd4-9828-66637c22f9af",
      "title": "Why would I use divergent functions?",
      "content_text": "Rust has some special syntax for ‚Äòdiverging functions‚Äô, which are functions that do not return.",
      "url": "https://medium.com/@yangnana11/rust-why-would-i-use-divergent-functions-d9dec59071bc",
      "date_published": "2018-04-11T08:54:41.128+00:00",
      "author": {
        "name": "Yang Nana",
        "url": "https://medium.com/@yangnana11"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d506eda8-cab3-4046-b0b7-3c16fd1bc53d",
      "title": "Rust all-hands (dev-tools stuff)",
      "content_text": "Last week (sigh, the week before last now) we held an 'all-hands' event in Berlin. It was a great event - fantastic to meet so many Rust people in real life and really energising to see how much is being planned and implemented. In this post I want to summarise some of the important dev-tools stuff that happened. Our planning and notes from some meetings is in the dev-tools team repo.",
      "url": "https://www.ncameron.org/blog/rust-all-hands-dev-tools-stuff/",
      "date_published": "2018-04-11T02:18:18+00:00",
      "author": {
        "name": "Nick Cameron",
        "url": "http://www.ncameron.org/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "68f328f0-50d5-4152-aa9a-f5ab3c69f397",
      "title": "A Shifty Riddle",
      "content_text": "When I finally implemented opportunistic mutations in mutagen, everything seemed fine until my co-maintainer gnieto found a problem. Code failed to compile with the mutagen plugin, something that should never happen as long as the code in question compiles without the plugin. We not only broke the code ‚Äì we broke the build.",
      "url": "http://llogiq.github.io/2018/04/11/shift.html",
      "date_published": "2018-04-11T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e497ecb9-788c-476e-bb28-c1746fbff940",
      "title": "Writing My Final Year Project in Rust",
      "content_text": "As part of my final year in university I have had to undertake a project and then write a twenty page paper on it. I ended up being assigned one on a type of machine learning algorithm called boosting. This wasn't my first choice unfortunately, so I decided I'd try to make it interesting for myself by implementing it in Rust. Rust was, and still is, quite immature when it comes to machine learning - as Are We Learning Yet? confirms. I thought it would be an interesting challenge to write some machine learning algorithms in a language that has yet to be used too much for this field.",
      "url": "http://mattyhall.github.io/posts/writing-my-final-year-project-in-rust.html",
      "date_published": "2018-03-30T23:00:00+00:00",
      "author": {
        "name": "Matthew Hall",
        "url": "http://mattyhall.github.io/blog.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d1d6e382-3b80-431e-ba08-5cbe1ccebce2",
      "title": "Dark Side Of Ergonomics",
      "content_text": "Despite having an experience with wide range of computer languages, including C++ and Haskell (both strong influences to Rusts design), I found Rust hard to learn. Sometimes I grind my teeth about something the compiler doesn‚Äôt let me do. Despite that, I didn‚Äôt put ergonomics as a wish in any poll. In fact, if I was to take a poll right now, I‚Äôd probably be against further ergonomics initiatives.",
      "url": "https://vorner.github.io/2018/04/08/Dark-side-of-ergonomics.html",
      "date_published": "2018-04-08T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "7fbe9c06-2e4a-4da4-aea0-45b4828f6687",
      "title": "Async & Await in Rust: a full proposal",
      "content_text": "I‚Äôm really excited to announce the culmination of much of our work over the last four months: a pair of RFCs for supporting async & await notation in Rust. This will be very impactful for Rust in the network services space. The change is proposed as two RFCs:\n RFC #2394: which adds async & await notation to the language. RFC #2395: which moves a part of the futures library into std to support that syntax.",
      "url": "https://boats.gitlab.io/blog/post/2018-04-06-async-await-final/",
      "date_published": "2018-04-06T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "e01d9c09-e66d-4fea-94e3-95db24137dd6",
      "title": "Sound and ergonomic specialization for Rust",
      "content_text": "Specialization holds the dubious honor of being among the oldest post-1.0 features remaining in unstable limbo. That‚Äôs for good reason, though: until recently, we did not know how to make it sound.",
      "url": "http://aturon.github.io/2018/04/05/sound-specialization/",
      "date_published": "2018-04-05T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Language",
        "Computer Science"
      ]
    },
    {
      "id": "4812042b-1d2a-4171-9a77-d2f0a0c44b91",
      "title": "Writing the Perfect 'Collect' Trait",
      "content_text": "I‚Äôve been spending some time thinking about garbage collection in rust. I know, shame on me, it‚Äôs a systems language, we hate garbage collection, but‚Ä¶ even in a systems programming language, garbage collection is still pretty damn useful.",
      "url": "https://mtak-blog.github.io/the_perfect_collect_trait",
      "date_published": "2018-04-05T00:00:00+00:00",
      "author": {
        "name": "mtak-blog",
        "url": "https://mtak-blog.github.io/"
      },
      "tags": [
        "Language",
        "Computer Science"
      ]
    },
    {
      "id": "cb113ba3-eaa8-40e1-8ff8-a8b710bf89db",
      "title": "Custom tasks in Cargo",
      "content_text": "One of the big requests from the Domain Working Groups for Rust 2018 is a richer feature set for framework- or domain-specific workflows in Cargo. At the simplest level, that might look like project templates ‚Äì the ability to direct cargo new to start with a custom template defined in crates.io. That‚Äôs already enough to get you cooking with frameworks like QuiCLI, which today involve a fixed set of initial scaffolding that you can fill in.",
      "url": "http://aturon.github.io/2018/04/05/workflows/",
      "date_published": "2018-04-05T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5eca0d0a-81f6-4804-869f-32ed307adb9f",
      "title": "The Rust Team All Hands in Berlin: a Recap",
      "content_text": "Last week we held an ‚ÄúAll Hands‚Äù event in Berlin, which drew more than 50 people involved in 15 different Rust Teams or Working Groups, with a majority being volunteer contributors. This was the first such event, and its location reflects the current concentration of team members in Europe. The week was a smashing success which we plan to repeat on at least an annual basis.",
      "url": "https://blog.rust-lang.org/2018/04/06/all-hands.html",
      "date_published": "2018-04-06T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "277652ec-bbeb-454c-85da-766438600d47",
      "title": "Cargo, Xargo, and Rustup",
      "content_text": "Another topic of discussion at the Berlin Rust All Hands was the long-term story around Cargo, Xargo, and Rustup. The latter two tools are both involved in managing your Rust toolchain, with Xargo allowing you to build custom stds and Rustup managing pre-built artifacts for mainstream targets. Xargo is most commonly used for cross-compiling to less common platforms, but can also be used to customize the standard library on mainstream platforms.",
      "url": "http://aturon.github.io/2018/04/06/rustup-xargo/",
      "date_published": "2018-04-06T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Embedded",
        "Language"
      ]
    },
    {
      "id": "8379ada9-43de-4764-88b1-aa3d24b114fd",
      "title": "A Formal Look at Pinning",
      "content_text": "Recently, a new API for ‚Äúpinned references‚Äù has landed as a new unstable feature in the standard library. The purpose of these references is to express that the data at the memory it points to will not, ever, be moved elsewhere. Others have written about why this is important in the context of async IO. The purpose of this post is to take a closer, more formal look at that API: We are going to take a stab at extending the RustBelt model of types with support for pinning.",
      "url": "https://www.ralfj.de/blog/2018/04/05/a-formal-look-at-pinning.html",
      "date_published": "2018-04-05T00:00:00+02:00",
      "author": {
        "name": "Ralf Jung",
        "url": "https://www.ralfj.de/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0dd3a72c-b43f-449a-92f3-fd25f164d224",
      "title": "Corner Cutting vs. Productivity",
      "content_text": "I recently got into a discussion with another very knowledgeable Rustacean, who (I paraphrase) claimed that Rust is about adding just enough roadblocks to keep you from cutting corners. This is a nice metaphor because it explains a lot: Rust may feel more cumbersome, because it won‚Äôt let you cut corners. On the other hand, once it compiles, many classes of errors will already have been taken care of, so your code will usually work as expected (or if you‚Äôre new to Rust, unexpectedly well).",
      "url": "https://llogiq.github.io/2018/04/03/corners.html",
      "date_published": "2018-04-03T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "680e9488-98e3-4a44-b462-761cf817ca10",
      "title": "Why We're Betting on Rust",
      "content_text": "Considering how the state of our art is ever changing, I re-evaluate which tools belong in my box of gizmos each year as well. In the past, I‚Äôve employed nginx as a high-performance cache and proxy, but it has been largely edged out by Envoy, which touts a hybrid non-blocking event model and has become wildly successful after being released in 2016. That very same principle, event-driven I/O, is the same reason I chose Node.js for most of the APIs I‚Äôve developed since 2011. Even if practices change, we retain successful engineering models.\n\nBeginning late last year, as I sketched our founding mission and initial product offerings, I also decided to select a new primary language that could handle most of our primary development tasks. After writing mostly JavaScript and compile-to-JS languages for half a decade, I longed for something more.",
      "url": "https://www.uptime.ventures/blog/2018/04/why-were-betting-on-rust/",
      "date_published": "2018-04-02T00:00:00+00:00",
      "author": {
        "name": "Nicholas Young",
        "url": "https://www.uptime.ventures/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d14f3e75-4047-441e-a67b-fc0de042845a",
      "title": "Removing Connection State In mob",
      "content_text": "I started writing mob, an multi-echo server using mio, in 2015. I coded mob into a mostly working state and then left it mostly alone, only updating it to work with the latest stable mio. Recently, I started looking at the code again and had the urge to improve it. In a previous post, I talked about managing the state of connections in mob. In this post, I will walk through what I did to remove the need to track connection state. I wanted to remove the state because the implementation required an O(n) operation every tick of the mio event loop. It also added a fair amount of complexity to the code.",
      "url": "http://hermanradtke.com/2018/03/29/removing-connection-state-from-mob.html",
      "date_published": "2018-03-29T00:00:00+00:00",
      "author": {
        "name": "Herman J. Radtke III",
        "url": "http://hermanradtke.com/"
      },
      "tags": [
        "Language",
        "Web and Network Services"
      ]
    },
    {
      "id": "dac3ce68-bfe5-4774-8b89-fb4351d53445",
      "title": "Reliable Systems Series: Model-Based Testing",
      "content_text": "This is the first article in a series on techniques I‚Äôve found useful for making my projects more reliable. These techniques are used in the distributed systems, database, automotive, embedded, and aerospace fields, but if you build services, user interfaces, or generally anything stateful, I think you will find something useful along the way.",
      "url": "https://medium.com/@tylerneely/reliable-systems-series-model-based-property-testing-e89a433b360",
      "date_published": "2018-03-28T12:52:27.284+00:00",
      "author": {
        "name": "Tyler Neely",
        "url": "https://medium.com/@tylerneely"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5941ab41-5269-4401-9978-f6f389922443",
      "title": "Rust: First impressions from a C++ developer",
      "content_text": "I started learning Rust 2 weeks back (yay!!) whenever I got free time. And all the time that I spent  learning it has been worthwhile. This is not going to be a deep technical post, but just my impressions about Rust from where I come from (C++).",
      "url": "http://templated-thoughts.blogspot.com.au/2018/03/rust-first-impressions-from-c-developer.html",
      "date_published": "2018-03-31T00:43:00-07:00",
      "author": {
        "name": "Arun Muralidharan",
        "url": "http://templated-thoughts.blogspot.com.au/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "980f0166-c073-42bc-a1df-7dab36421e10",
      "title": "You can't Rust that",
      "content_text": "The last year has been fun because I could build a lot for really nice stuff for Sentry in Rust and for the first time the development experience was without bigger roadblocks. While we have been using Rust before it now feels different because the ecosystem is so much more stable and we ran less against language or tooling issues.\n\nHowever talking to people new to Rust (and even brainstorming APIs with coworkers) it's hard to get rid of the feeling that Rust can be a mind bending adventure and that the best way to have a stress free experience is knowing upfront what you cannot (or should not attempt to) do. Knowing that certain things just cannot be done helps putting your mind back back on the right track.\n\nSo here are things not to do in Rust and what to do instead which I think should be better known.",
      "url": "http://lucumr.pocoo.org/2018/3/31/you-cant-rust-that/",
      "date_published": "2018-03-31T00:00:00+00:00",
      "author": {
        "name": "Armin Ronacher",
        "url": "http://lucumr.pocoo.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "79ebe691-fe8b-46ea-806c-996919b730ca",
      "title": "I've just learned Rust and I think I'm in love",
      "content_text": "I‚Äôve decided to learn some Rust recently while working on the Stanford‚Äôs experimental course on operating systems. Here‚Äôs a list of things that I think are great about it.",
      "url": "https://rskupnik.github.io/I-learned-rust-and-I-think-Im-in-love",
      "date_published": "2018-03-30T00:00:00+00:00",
      "author": {
        "name": "Rados≈Çaw Skupnik",
        "url": "https://rskupnik.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4a0c4c01-2597-4688-ac99-2726bb1a3505",
      "title": "Thoughts on Rust, a few thousand lines in",
      "content_text": "To say my first foray into Rust was a frustrating struggle would be an understatement. I picked a terrible first project that left me neck deep in Rust‚Äôs trickiest areas right off the bat. I was excited to try again. A few years ago I wrote Sumoshell, a CLI App for log analysis. I‚Äôd wanted to improve it for a while, so porting it to Rust seemed like a nice way to kill two birds with one stone.",
      "url": "https://rcoh.me/posts/things-learned-first-thousand-lines-of-rust/",
      "date_published": "2018-03-24T12:56:00-07:00",
      "author": {
        "name": "Russell Cohen",
        "url": "https://rcoh.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "dc304d16-2ec3-45b1-833b-a9536c1a7d95",
      "title": "Memory Safety and Lifetimes in Rust",
      "content_text": "A program is memory-safe if in any possible execution of the program , all expressions e in the program that refer to an object of type T resolve to an object of type T that has been initialized and not yet deallocated.\n\nThere are different ways to guarantee memory safety for all programs. One is to restrict the programming language and disallow pointers. But, this forces most programs to make unnecessary copies of data. Another strategy, called garbage collection, embeds a garbage collector with every program. The garbage collector periodically looks for objects in memory that cannot be accessed from the program and reclaims this memory. The drawbacks of this are the overhead of garbage collection and that deallocation of memory is no longer under the control of the programmer.",
      "url": "https://balu.github.io/lifetimes.html",
      "date_published": "2018-02-26T18:52:22+00:00",
      "author": {
        "name": "Balagopal Komarath",
        "url": "https://balu.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2cadbd86-48ec-4fab-95bb-5959818d5747",
      "title": "Announcing Rust 1.25",
      "content_text": "The Rust team is happy to announce a new version of Rust, 1.25.0. The last few releases have been relatively minor, but Rust 1.25 contains a bunch of stuff!",
      "url": "https://blog.rust-lang.org/2018/03/29/Rust-1.25.html",
      "date_published": "2018-03-29T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "04fdf0c8-05ab-46f3-b72d-c7e88eb6dc9b",
      "title": "Cargo got some new tricks, but is it still correct!?",
      "content_text": "I have been working with @alexcrichton to improve the resolver in Cargo.",
      "url": "https://www.reddit.com/r/rust/comments/87ss76/cargo_got_some_new_tricks_but_is_it_still_correct/",
      "date_published": "2018-03-28T15:25:46+00:00",
      "author": {
        "name": "Eh2406",
        "url": "https://www.reddit.com/user/Eh2406"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d4574214-e1ca-4fe8-858b-b5c9c64046ab",
      "title": "Closures 101",
      "content_text": "Closures are an interesting CS concept and one that will frequently come up in interviews. I know I've been asked, and have asked, questions about closures for frontend (Javascript) positions numerous times. And in all honesty they're a difficult concept to define, especially when you're under the scrutiny of an interviewer. In this post I'd like to show how Rust leverages the concept of closures and why they might be used. But first, we need to discuss the concept of scope because it is so important for the full understanding of closures.",
      "url": "http://mttyng.com/closures-101/",
      "date_published": "2018-03-25T00:00:00+00:00",
      "author": {
        "name": "Matt",
        "url": "http://mttyng.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "eef1f270-fb75-475a-b10c-8e3813990362",
      "title": "Atomics ‚ò¢ and memory ordering",
      "content_text": "Taming multiple threads is a mess. Not only many things can happen all at once, but what you wrote in the code isn‚Äôt exactly what happens in the CPU. To gain some more performance, the compiler cheats if it thinks nobody is watching. It can reorder instructions or throw some of them out if they look useless. The same happens in the hardware. Furthermore, there isn‚Äôt just one RAM, but each memory location can live in different caches at each time and some of them are private to each CPU. It would not make do to publish all the local changes to one‚Äôs cache right away.",
      "url": "https://vorner.github.io/2018/03/25/Atomics.html",
      "date_published": "2018-03-25T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ad4ba620-3dae-4618-abc7-e245c97369d3",
      "title": "Refactoring some repetitive code to a Rust macro",
      "content_text": "I have started porting the code in librsvg that parses SVG's CSS properties from C to Rust. Many properties have symbolic values. StrokeLinejoin is the first property that I ported. First I had to write a little bunch of machinery to allow CSS properties to be kept in Rust-space instead of the main C structure that holds them (upcoming blog post about that). But for now, I just want to show how this boiled down to a macro after refactoring.",
      "url": "https://people.gnome.org/~federico/blog/refactoring-some-repetitive-code-to-a-macro.html",
      "date_published": "2018-03-23T11:01:30-06:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "bf2c60f0-b2be-44c4-ba38-dce0f5b2e041",
      "title": "Mutating Rust: Under Cover",
      "content_text": "Any mutation testing tool worth its salt uses coverage to restrict the number of tests to run. mutagen is no exception, of course, so once we had a test runner, we wanted to extend it with coverage-based testing.",
      "url": "https://llogiq.github.io/2018/03/25/cover.html",
      "date_published": "2018-03-25T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "9e02b413-b1dd-42a3-a970-2d7b89354c0c",
      "title": "A look at Tokio: how this asynchronous event handler works (Russian)",
      "content_text": "–ò –¥–ª—è —á–µ–≥–æ –æ–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–µ –¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω—ã—Ö –±–ª–æ–∫—á–µ–π–Ω–æ–≤ Exonum Tokio ‚Äî —ç—Ç–æ —Ñ—Ä–µ–π–º–≤–æ—Ä–∫ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ —Å–µ—Ç–µ–≤—ã—Ö –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º—ã—Ö –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–π –Ω–∞ Rust,...",
      "url": "https://habrahabr.ru/company/bitfury/blog/351824/",
      "date_published": "2018-03-22T16:46:00+00:00",
      "author": {
        "name": "–ê–ª–∏–Ω–∞ –¢–µ—Å—Ç–æ–≤–∞",
        "url": "https://habrahabr.ru/company/bitfury/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6cf2d39d-3ea9-4af4-b9c7-a368be610189",
      "title": "Python Idioms in Rust",
      "content_text": "I‚Äôve been going through a period of programming language wanderlust over the past couple months. Recently, I‚Äôve been quite interested in Rust. Coming from Python, I‚Äôve found a lot of Rust‚Äôs language features to be quite powerful.",
      "url": "http://benjamincongdon.me/blog/2018/03/23/Python-Idioms-in-Rust/",
      "date_published": "2018-03-23T12:23:22+00:00",
      "author": {
        "name": "Benjamin Congdon",
        "url": "http://benjamincongdon.me/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "93eaac73-c49e-4d21-8d11-f9ca7e40721c",
      "title": "From python to Go to Rust: an opinionated journey",
      "content_text": "When looking for a new backend language, I naturally went from Python to the new cool kid: Go. But after only one week of Go, I realised that Go was only half of a progress. Better suited to my needs than Python, but too far away from the developer experience I was enjoying when doing Elm in the frontend. So I gave Rust a try.",
      "url": "http://tech.allo-media.net/point/of/view/2018/03/22/from-python-to-go-to-rust.html",
      "date_published": "2018-03-22T09:00:00+01:00",
      "author": {
        "name": "Allo-Media",
        "url": "http://tech.allo-media.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "afdcd322-eab4-4363-be76-cecaa050e867",
      "title": "Async/Await VI: 6 weeks of great progress",
      "content_text": "It‚Äôs hard to believe its been almost 6 weeks since the last post I made about async/await in Rust. So much has happened that these last several weeks have flown by. We‚Äôve made exceptionally good progress on solving the problem laid out in the first post of this series, and I want to document it all for everyone.\nFuture and the pinning API Last month I wrote an RFC called ‚ÄúStandard library API for immovable types‚Äù.",
      "url": "https://boats.gitlab.io/blog/post/2018-03-20-async-vi/",
      "date_published": "2018-03-20T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8bd1d21c-79d1-4470-9d49-907c26ab0057",
      "title": "Type-directed metaprogramming in Rust",
      "content_text": "I explore how to use Rust compiler internals to metaprogram Rust using information from the typechecker, e.g. to automatically insert garbage-collection into Rust code, and discuss the benefits and drawbacks of this approach.",
      "url": "http://willcrichton.net/notes/type-directed-metaprogramming-in-rust/",
      "date_published": "2018-03-18T00:00:00+00:00",
      "author": {
        "name": "Will Crichton",
        "url": "http://willcrichton.net/notes/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "03cf26ef-4e0f-4124-91ec-064467299583",
      "title": "Putting bors on a PIP",
      "content_text": "We have a problem: the average queue of ready-to-test PRs to the main Rust repo has been steadily growing for a year. And at the same time, the likelihood of merge conflicts is also growing, as we include more submodules and Cargo dependencies that require updates to Cargo.lock.",
      "url": "http://aturon.github.io/2018/03/19/bors/",
      "date_published": "2018-03-19T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "908c4bee-bf00-4e80-8136-9282eb8de6f6",
      "title": "Rust Lifetimes or: How I Learned to Stop Free-ing and Love the Borrow",
      "content_text": "To me one of the initial shocks of learning Rust was figuring out lifetimes. As a frontend-by-day developer I don't come face-to-face with the 'Double free' and 'Use after free' problems all that often. Actually, it could be easily argued that my backend-brethren don't really either or, for that matter, anyone who's typically dealing with a garbage collected language. I'm looking over at you JS, Java, and Ruby devs. I'd bet most neckbea.. *cough, excuse me, C developers are comfortable with these issues but alas, I am not. As such, lifetimes were kinda difficult to wrap my head around but I think I get them a little better now so let me try to explain.",
      "url": "http://mttyng.com/rust-lifetimes-or-how-i-learned-to-stop-free-ing-and-love-the-borrow/",
      "date_published": "2018-03-09T00:00:00+00:00",
      "author": {
        "name": "Matt",
        "url": "http://mttyng.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "1fe95cfd-488a-41a5-adca-a44d8f79c679",
      "title": "What's a where clause?",
      "content_text": "I've been trying to get a hang of some of the more advanced, and weird, concepts of Rust. With any new language it's a little difficult to know where to begin. How do you throw yourself into the deep-end of something without knowing where the deep-end is?",
      "url": "http://mttyng.com/whats-a-where-clause/",
      "date_published": "2018-02-20T00:00:00+00:00",
      "author": {
        "name": "Matt",
        "url": "http://mttyng.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f5ba053a-1bbb-465d-a430-55bd0a1d357a",
      "title": "How Rust Implements Tagged Unions",
      "content_text": "The Rust compiler implements tagged unions, which prevent you from crashing your program by initializing a union with one variant and accessing it with another. Rust uses enum to improve on both C enums and C unions at the same time.",
      "url": "http://patshaughnessy.net/2018/3/15/how-rust-implements-tagged-unions",
      "date_published": "2018-03-15T03:00:00+00:00",
      "author": {
        "name": "Pat Shaughnessy",
        "url": "http://patshaughnessy.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "81e14040-a499-4802-9d1b-c58deeb2be79",
      "title": "Deciding if two types are equal",
      "content_text": "mutagen until recently suffered a bug that rendered both the return input and the interchange arguments mutation inapplicable.\n\nTo explain, the former mutation compares each input type with the return type and allows code to return inputs of the same type, if any, while the latter compares input arguments‚Äô types and exchanges two equally-typed inputs.",
      "url": "https://llogiq.github.io/2018/03/15/types.html",
      "date_published": "2018-03-15T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "eabc9692-30cf-4511-89f4-9068b46aadd8",
      "title": "A Comparison Between Rust and Erlang",
      "content_text": "This article will focus on a comparison between Erlang and Rust, detailing their similarities and differences. It may be interesting to both Erlang developers looking into Rust and Rust developers looking into Erlang. A final section will detail more about each of the language capabilities and shortcomings and argue for the possibility of leveraging both languages' strengths in the same project.",
      "url": "https://www.infoq.com/articles/rust-erlang-comparison",
      "date_published": "2018-03-13T00:00:00+00:00",
      "author": {
        "name": " Krishna Kumar Thokala",
        "url": "https://www.infoq.com/profile/Krishna-Kumar-Thokala"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "24afdde0-ef13-4e26-b39e-b2f9d52ab901",
      "title": "How to use external crates with macros in Rust",
      "content_text": "A simple approach to use external crates with our macros in Rust.",
      "url": "https://medium.com/@kimond/how-to-use-external-crates-with-our-macros-in-rust-6dfe025351e0",
      "date_published": "2018-03-14T12:45:30.700+00:00",
      "author": {
        "name": "Kim Desrosiers",
        "url": "https://medium.com/@kimond"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "962abf61-6061-4e8d-90b1-1d3ba90d5e1d",
      "title": "mutagen: Pattern Boldness",
      "content_text": "At the moment, mutagen only considers top-level idents in function arguments (e.g.foo(x: X, y: Y)), but function arguments are actually patterns, so we could have foo((x, y): (X, Y)) or bar(Bar { bla, bazz } : Bar). For now, this means we have no type information for either of those examples.",
      "url": "http://llogiq.github.io/2018/03/13/patterns.html",
      "date_published": "2018-03-13T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4ed8ee1b-6f71-4ac5-b7e5-142509562231",
      "title": "Rust's 2018 Roadmap",
      "content_text": "Each year the Rust community comes together to set out a roadmap. This year, in addition to the survey, we put out a call for blog posts in December, which resulted in 100 blog posts written over the span of a few weeks. The end result is the recently-merged 2018 roadmap RFC.",
      "url": "https://blog.rust-lang.org/2018/03/12/roadmap.html",
      "date_published": "2018-03-12T00:00:00+00:00",
      "author": {
        "name": "The Rust Core Team",
        "url": "https://blog.rust-lang.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "90d39fbf-c75d-4943-9069-4b65d11b1be9",
      "title": "Should You Learn Rust?",
      "content_text": "Oftentimes, I see a variant of this question posted or asked somewhere. In general, most of the times I think the answer is ‚ÄûYes‚Äú, but maybe for reasons other than you‚Äôd think at first.",
      "url": "https://vorner.github.io/2018/03/11/Should-you-learn-rust.html",
      "date_published": "2018-03-11T00:00:00+00:00",
      "author": {
        "name": "Michal 'vorner' Vaner",
        "url": "https://vorner.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "bd4b8e12-dd4d-4bf8-b553-f5f912ec4e87",
      "title": "The Union of Parallel Universes",
      "content_text": "Rustdoc has a pretty powerful feature that feels pretty unknown. It doesn‚Äôt help that it‚Äôs currently restricted by a nightly feature gate, but it‚Äôs still cool enough that I want to talk about it.",
      "url": "https://quietmisdreavus.net/code/2018/03/09/the-union-of-parallel-universes/",
      "date_published": "2018-03-09T14:30:00-06:00",
      "author": {
        "name": "QuietMisdreavus",
        "url": "https://quietmisdreavus.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "db7ea4c5-14ae-4a9d-9bf4-a314c20225f7",
      "title": "Exploring Function Overloading",
      "content_text": "Overloading is the ability to create multiple functions of the same name with different implementations.\n\nRust has no traditional overloading, you cannot define two methods with the same name. The compiler will complain that you have a duplicate definition regardless of the different argument types.",
      "url": "http://casualhacks.net/blog/2018-03-10/exploring-function-overloading/",
      "date_published": "2018-03-10T00:00:00+09:00",
      "author": {
        "name": "Casper",
        "url": "http://casualhacks.net/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0d2f8636-6f6c-42f3-8159-beac5a856009",
      "title": "Redefining Failure",
      "content_text": "I recently got the chance to redo the error handling in two different crates I help maintain. For liquid, I decided to write the error types by hand rather than use something like error-chain. In the case of assert_cli, I decided to finally give failure a try.",
      "url": "https://epage.github.io/blog/2018/03/redefining-failure/",
      "date_published": "2018-03-09T03:08:23+00:00",
      "author": {
        "name": "Ed Page",
        "url": "https://epage.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8da41ef1-4c51-4269-bec3-fc377a0f387f",
      "title": "Coping with Mutable State in Multiple Threads with Rust",
      "content_text": "One of the value propositions most frequently lauded by Rust developers is its freedom from data races. The compiler will literally not allow you to build code that could ever produce a situation where two threads can mutate the same data.",
      "url": "https://medium.com/@KevinHoffman/coping-with-mutable-state-in-multiple-threads-with-rust-9059c83b6c01",
      "date_published": "2018-03-05T17:42:58.844+00:00",
      "author": {
        "name": "Kevin Hoffman",
        "url": "https://medium.com/@KevinHoffman"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "79704e4b-5e9f-4366-84a8-53d5a3431e2f",
      "title": "Getting A Handle On Things",
      "content_text": "Today we will take a very simple intrusive linked list written in Rust and make it safe. Kind of, anyway.\n\nBefore we start making something safe we need an unsafe thing to make safe. Let‚Äôs not pretend that what we are doing here is the least bit useful, let us instead do it just for the fun of it. (What we are doing actually is useful, the explanation of which this margin is too narrow to contain.)",
      "url": "https://eno.space/blog/2018/03/Getting-a-handle-on-things",
      "date_published": "2018-03-03T00:00:00+01:00",
      "author": {
        "name": "@u0060",
        "url": "https://eno.space/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "0c9a85c5-9017-4922-b07a-050f36b8db84",
      "title": "Compiling Cargo crates natively with Meson",
      "content_text": "Recently we have been having discussions about how Rust and Meson should work together, especially for mixed language projects. One thing which multiple people have told me (over a time span of several years, actually) is that Rust is Special in that everyone uses crates for everything. Thus there is no point in having any sort of Rust support, the only true way is to blindly call Cargo and have it do everything exactly the way it wants to.\n\nThis seems like a reasonable recommendation so I did what every reasonable person would do and accepted this as is.\n\nBut then curiosity takes hold of you and you start to wonder. Is that really the case?",
      "url": "https://nibblestew.blogspot.com.au/2018/03/compiling-cargo-crates-natively-with.html",
      "date_published": "2018-03-04T05:35:00-08:00",
      "author": {
        "name": "Jussi",
        "url": "https://nibblestew.blogspot.com.au/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "85925a6b-30c1-4c0f-8caf-b6ccd9e3e19c",
      "title": "Encheapening Cernan Internal Metrics",
      "content_text": "In the new 0.7.x series of cernan we stumbled on a neat, cheap approach for making internal metrics available inside a rust codebase, an approach that has legs in other projects, I'd say. This is going to be a quick note describing what cernan is, what we were doing before and how our current approach works.",
      "url": "http://blog.troutwine.us/2017/08/31/encheapening-cernan-internal-metrics/",
      "date_published": "2018-03-04T00:00:00+00:00",
      "author": {
        "name": "Brian L. Troutwine",
        "url": "http://blog.troutwine.us/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c59a9688-62e5-4919-8687-e5ff82c3c5a3",
      "title": "Why Rust Has Macros",
      "content_text": "When I recently told a coworker that Rust has macros, his first reaction was that this was bad. Previously I would have had the same reaction, but a part of what learning Rust has taught me is that macros don‚Äôt need to be bad. This post exists to help explain why that is, by diving into what problems macros solve, with a brief look at their downsides as well. In other words, this post is not a technical deep dive on how macros work, but focuses on the use cases for macros, and doesn‚Äôt require much knowledge about Rust to follow.",
      "url": "https://kasma1990.gitlab.io/2018/03/04/why-rust-has-macros/",
      "date_published": "2018-03-04T00:00:00+00:00",
      "author": {
        "name": "Kasper Andersen",
        "url": "https://kasma1990.gitlab.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "95bd2ff7-1a99-4092-931a-b17d782282d3",
      "title": "Serializing awkward data with serde",
      "content_text": "Recently I‚Äôve been writing Rust code to work with a third-party data source in TOML format. In other languages I‚Äôd just load the data with some standard TOML library and have my program rummage through it, but I‚Äôve been hearing lovely things about the Rust serialization library serde, so I figured I‚Äôd try it out.",
      "url": "http://zork.net/~st/jottings/Serializing_awkward_data_with_serde.html",
      "date_published": "2018-03-04T07:43:09+00:00",
      "author": {
        "name": "Screwtape",
        "url": "http://zork.net/~st/jottings/all_pages.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "39d1ac9b-501b-46c3-b2e6-68f2d4aabe1d",
      "title": "Making a Brainf*ck to C Compiler in Rust",
      "content_text": "Let‚Äôs make a tokenizer and code generator to understand the basics behind tiny compilers.",
      "url": "https://medium.com/@CanHasCommunism/making-a-brainf-ck-to-c-compiler-in-rust-10f0c01a282d",
      "date_published": "2018-03-03T18:13:20.377+00:00",
      "author": {
        "name": "Aesl",
        "url": "https://medium.com/@CanHasCommunism"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "2f386775-d0a5-474b-a9de-c14af7453c40",
      "title": "Opportunistic Mutations",
      "content_text": "As you may know, my current mutagen project deals with mutation testing in Rust. However, as I remarked, Rust‚Äôs famed flexibility leaves us little room to do mutations while keeping the type checker happy. For example, other mutation testing frameworks can mutate x + y to x - y.\n\nThis is an interesting mutation, because it‚Äôs so easy to do in languages like Java, which have full type information available at the bytecode level and so hard to do in Rust, because the std::ops traits make everything so hecking flexible.",
      "url": "https://llogiq.github.io/2018/03/03/opportune.html",
      "date_published": "2018-03-03T00:00:00+00:00",
      "author": {
        "name": "Llogiq",
        "url": "http://llogiq.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "407d3ba2-d0af-4121-b13a-468b1f0f66cd",
      "title": "Stopping a Rust worker",
      "content_text": "This is a small post about a specific pattern for cancellation in the Rust programming language. The pattern is simple and elegant, but it‚Äôs rather difficult to come up with it by yourself.",
      "url": "https://matklad.github.io/2018/03/02/stopping-a-rust-worker.html",
      "date_published": "2018-03-02T20:11:50+00:00",
      "author": {
        "name": "Aleksey Kladov",
        "url": "https://matklad.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ab076ead-649f-47ff-8fa2-a7c243ba3dca",
      "title": "Docker Multi-Stage Build",
      "content_text": "On June 13, 2017 took place the Paris Container Day. They unveiled a new docker feature: multi-stage build. That's the subject of this article.",
      "url": "https://blog.jawg.io/docker-multi-stage-build/",
      "date_published": "2018-03-01T14:00:00+00:00",
      "author": {
        "name": "Jones Magloire",
        "url": "http://blog.jawg.io/"
      },
      "tags": [
        "Language",
        "DevOps and Deployment"
      ]
    },
    {
      "id": "257617e2-c1fe-44c7-9cb9-7c07495b96ec",
      "title": "Object Shadowing for Serialization of Complex Types",
      "content_text": "Presently, I‚Äôm busy writing a capture the flag (CTF) scoreboard, it requires rather complex structures and relationships with other internal objects. Being a security event, I‚Äôd also like to maintain explicit control of user data. While serialization in Rust has come a significant way, leveraging auto-generation presents some issues.",
      "url": "https://commiebstrd.github.io/rustlang/serde/json/2018/03/01/object-shadowing.html",
      "date_published": "2018-03-01T05:00:00+00:00",
      "author": {
        "name": "Spenser Reinhardt",
        "url": "https://commiebstrd.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ca98f7f9-8927-48e9-8028-15e81f20f8a6",
      "title": "Add examples to your Rust¬†libraries",
      "content_text": "When you‚Äôre writing a library for other programs to depend on, it is paramount to think how the developers are going to use it in their code.\n\nThe best way to ensure they have a pleasant experience is to put yourself in their shoes. Forget the internal details of your package, and consider only its outward interface. Then, come up with a realistic use case and just implement it.\n\nIn other words, you should create complete, end-to-end, and (somewhat) usable example applications.",
      "url": "http://xion.io/post/code/rust-examples.html",
      "date_published": "2018-02-28T08:37:00+01:00",
      "author": {
        "name": "Karol Kuczmarski",
        "url": "http://xion.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "d001ce02-fbfb-4a08-8389-0f713b09bf72",
      "title": "My Rust Dockerfile",
      "content_text": "Lets deploy small docker images for Rust",
      "url": "https://blog.sedrik.se/posts/my-docker-setup-for-rust/",
      "date_published": "2018-02-26T00:00:00+00:00",
      "author": {
        "name": "Fredrik Park",
        "url": "https://blog.sedrik.se/"
      },
      "tags": [
        "Language",
        "DevOps and Deployment"
      ]
    },
    {
      "id": "cec6c9fd-a92b-4f5a-8d9b-9b84c263c48f",
      "title": "Writing a doubly linked list in Rust is easy",
      "content_text": "This is a response to the recently submitted blog post titled Why Writing a Linked List in (safe) Rust is So Damned Hard. The post on Reddit was even more dramatic: Why Writing a Linked List in Rust is Basically Impossible.\n\nI see exaggarated claims like these very often - and strongly disagree. Writing a doubly linked list in Rust is not hard - in fact, it's fairly easy! The best strategy, in my opinion, is creating a vector for allocating nodes and using indices instead of pointers. This strategy is often overlooked, getting a 'honorauble mention' at best.",
      "url": "https://www.reddit.com/r/rust/comments/7zsy72/writing_a_doubly_linked_list_in_rust_is_easy/",
      "date_published": "2018-02-24T00:35:43+00:00",
      "author": {
        "name": "/u/stjepang",
        "url": "https://www.reddit.com/user/stjepang"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5e572868-98d0-4944-b897-14cca13a39a4",
      "title": "Reasoning with Types in Rust",
      "content_text": "Rust is a modern programming language which is marketed primarily on the basis of its very nice type system, and I‚Äôd like to tell you about how you can use this type system to reason about your programs in interesting ways. Most of the time when its type system is discussed, the focus is on its guarantee of data race freedom and ability to enable so-called fearless concurrency (and rightfully so‚Äîthis is a place where Rust truly shines!). Today, I have a different focus in mind, characterized perhaps most succinctly as follows:",
      "url": "https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust.html",
      "date_published": "2018-02-26T00:00:00+00:00",
      "author": {
        "name": "Aaron Weiss",
        "url": "https://aaronweiss.us/archive.html"
      },
      "tags": [
        "Language",
        "Computer Science"
      ]
    },
    {
      "id": "0493daa3-4abb-46eb-82de-e75daea4bbac",
      "title": "Pushing Rust To 2019",
      "content_text": "Some of these suggestions are not entirely new and have been added as posts/ comments on /r/rust, Github threads. But I believe better listing down all in a one place, because now we are in the correct time even I am bit late.",
      "url": "https://medium.com/@dumindu/pushing-rust-to-2019-9616d82172d3",
      "date_published": "2018-02-23T15:44:16.399+00:00",
      "author": {
        "name": "Dumindu Madunuwan",
        "url": "https://medium.com/@dumindu"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "516e4eaf-1ce1-49be-a457-a471e9f97329",
      "title": "How doctests get made",
      "content_text": "One of rustdoc‚Äôs greatest features is the ability to take code samples within your documentation and run them like tests. This ensures that all your samples stay up to date with your library‚Äôs API changes. However, there are some steps that need to happen to massage these ‚Äúdoctests‚Äù into something that can be compiled and run like a regular program.",
      "url": "https://quietmisdreavus.net/code/2018/02/23/how-the-doctests-get-made/",
      "date_published": "2018-02-23T16:00:00-06:00",
      "author": {
        "name": "QuietMisdreavus",
        "url": "https://quietmisdreavus.net/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "450ba7fc-c3ea-4af5-bda4-06842f062de8",
      "title": "Rust Typestates",
      "content_text": "A long time ago, the Rust language was a language with typestate. Officially, typestates were dropped long before Rust 1.0. In this entry, I‚Äôll get you in on the worst kept secret of the Rust community: Rust still has typestates.",
      "url": "https://yoric.github.io/post/rust-typestate/",
      "date_published": "2018-02-22T15:15:55+01:00",
      "author": {
        "name": "David Teller",
        "url": "https://yoric.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "45772a5b-1f22-4db9-9eee-f888c0c82660",
      "title": "Why Writing a Linked List in Rust is Basically Impossible [in safe Rust]",
      "content_text": "Before I start this post, let me preface it by saying that I‚Äôm not an experienced Rustacean by any means. Errata and corrections are appreciated. This post is aimed at helping other fledgling rust-learners avoid my mistake. First, by helping Rust learners pick good introductory projects that will fit naturally in idiomatic rust. Second, by helping Rust learners start building Rust-friendly design intuition. I‚Äôd heard about Rust and it‚Äôs inscrutable borrow checker for years, but after reading a few blog posts about compiler error improvements, I figured it might be user-friendly enough to give it a try.",
      "url": "https://rcoh.me/posts/rust-linked-list-basically-impossible/",
      "date_published": "2018-02-20T08:55:56-08:00",
      "author": {
        "name": "Russell Cohen",
        "url": "https://rcoh.me/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "3dc17991-d359-4205-917a-80b37a564b37",
      "title": "Rust for Cross-Language System Libraries",
      "content_text": "We have been building libpasta as a simple, usable solution to password hashing and migration. The goal for libpasta is to be a cross-platform, cross-language system library. libpasta is written in Rust, exports a C-style API, and builds to a static/shared library. Most languages support calling external libraries through foreign function interfaces (FFIs), and the end result can be seen in the documentation where each language has access to the libpasta functionality.",
      "url": "https://libpasta.github.io/blog/bindings/",
      "date_published": "2018-02-21T00:00:00+00:00",
      "author": {
        "name": "libpasta",
        "url": "https://libpasta.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "8e33c7c4-2788-418b-8e47-ca8990ae0d38",
      "title": "Snips Uses Rust to Build an Embedded Voice Assistant",
      "content_text": "The team at Paris-based Snips has created a voice assistant that can be embedded in a single device or used in a home network to control lights, thermostat, music, and more. You can build a home hub on a Raspberry Pi and ask it for a weather report, to play your favorite song, or to brew up a double espresso. Manufacturers like Keecker are adding Snips‚Äô technology to products like multimedia home robots. And Snips works closely with leaders across the value chain, like NVIDIA, EBV, and Analog Devices, in order to voice-enable an increasingly wider range of device types, from speakers to home automation systems to cars.",
      "url": "https://blog.mozilla.org/blog/2018/02/21/snips-uses-rust-build-embedded-voice-assistant/",
      "date_published": "2018-02-21T12:34:56-08:00",
      "author": {
        "name": "Judy DeMocker",
        "url": "https://blog.mozilla.org/blog/author/jdemockermozilla-com/"
      },
      "tags": [
        "Language",
        "Tools and Applications"
      ]
    },
    {
      "id": "c078b1d0-a902-42c5-84d0-5d262146e64c",
      "title": "Using macro to generate generic docs?",
      "content_text": "We were recently able to finally make the docs for integer primitive types much more accurate (thanks to @antoyo!). Now, the code examples match the type for which they're written. No more i32 examples for i128 (I think you got the idea at this point)! Now, I think a few people might be interested by the method we used to achieve such a result so let's talk about it.",
      "url": "https://blog.guillaume-gomez.fr/articles/2018-02-19+Using+macro+to+generate+generic+docs%3F",
      "date_published": "2018-02-19T00:00:00+00:00",
      "author": {
        "name": "Guillaume Gomez",
        "url": "https://blog.guillaume-gomez.fr/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "5ecd2c77-20dd-4fd5-84a7-6c8e2364ebde",
      "title": "Ferrous Oxide For Jaguars And Incremented Crocodiles",
      "content_text": "Caveat lector: the primary purpose of the article is to introduce a reader proficient in one of the popular object-oriented languages how not to program in Rust. While each feature of the language will be briefly introduced where it is used, no great efforts will be made to explain the feature in detail. Links to the Rust book should provide that.",
      "url": "https://eno.space/blog/2018/02/Ferrous-oxide-for-jaguars-and-incremented-crocodiles",
      "date_published": "2018-02-15T00:00:00+01:00",
      "author": {
        "name": "@u0060",
        "url": "https://eno.space/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6d0e61c5-087e-48dc-abd8-ded4f3e43a8a",
      "title": "Rust things I miss in C",
      "content_text": "Librsvg feels like it is reaching a tipping point, where suddenly it seems like it would be easier to just port some major parts from C to Rust than to just add accessors for them. Also, more and more of the meat of the library is in Rust now. I'm switching back and forth a lot between C and Rust these days, and C feels very, very primitive these days.",
      "url": "https://people.gnome.org/~federico/blog/rust-things-i-miss-in-c.html",
      "date_published": "2018-02-18T21:26:04-06:00",
      "author": {
        "name": "Federico Mena Quintero",
        "url": "https://people.gnome.org/~federico/blog/index.html"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "f77cc701-eca9-4b85-a450-dd10c1766966",
      "title": "Sorting in Rust: Selection, Insertion, and Counting Sort",
      "content_text": "Sorting is an invaluable skill and often covered early in a computer science curriculum. Have you ever tried to look up a friends phone number in an unsorted list!? You‚Äôd have to look at every single entry. Sorting creates all sorts of ways to access data quicker.",
      "url": "https://medium.com/@spyr1014/sorting-in-rust-selection-insertion-and-counting-sort-2c4d3575e364",
      "date_published": "2018-02-18T23:57:10.254+00:00",
      "author": {
        "name": "Andrew Jakubowicz",
        "url": "https://medium.com/@spyr1014"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ff94e8a6-c203-4cbe-af46-8f99e2896dd8",
      "title": "Borrow cycles in Rust: arenas v.s. drop-checking",
      "content_text": "Ownership and borrowing are the fundamentals of data structures in Rust. However, both taking owneship of a value (moving it) or taking a reference to it can only happen after the value was created. This ordering seems to prevent having any cycle in a data structure, even though that‚Äôs sometimes useful or necessary. For example in a web page‚Äôs content tree, from any DOM node, one can easily access (if any) its first and last child, previous and next sibling, (so children of a node form a doubly-linked list) and parent. Some other applications might need to manipulate arbitrary graphs in their full generality.",
      "url": "https://exyr.org/2018/rust-arenas-vs-dropck/",
      "date_published": "2018-02-17T00:00:00+00:00",
      "author": {
        "name": "Simon Sapin",
        "url": "https://exyr.org/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "938457b4-8905-4954-9007-88c80a2c24d6",
      "title": "\"The Expressive C++17 Coding Challenge (in Rust)\" Revisited",
      "content_text": "In October of last year, I wrote a post, ‚ÄúThe Expressive C++17 Coding Challenge (in Rust)‚Äù. For various reasons, it got brought up again in the D world, and seb has written a new post. It‚Äôs good, you should check it out! However, it links to my gist, not my blog post. As I said back then: I held myself to the same constraints as the original contest; no external packages is a bit painful in Rust, but it‚Äôs not too bad. Mostly it would let me eliminate boilerplate while also improving correctness, and making the code a bit shorter. So, that got me thinking: What would this look like if I could use external packages? I took about an hour, and knocked it out. I have two versions to show you today, one where I pay no attention to allocations, and one where it‚Äôs zero-allocation.",
      "url": "http://words.steveklabnik.com/the-expressive-c-17-coding-challenge-in-rust-revisited",
      "date_published": "2018-02-14T10:12:15-08:00",
      "author": {
        "name": "Steve Klabnik",
        "url": "http://words.steveklabnik.com/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "28ce1b60-8837-4443-87fb-669bf176db9b",
      "title": "Reflecting on ppbert",
      "content_text": "I had an itch: I was pretty-printing the BERT-encoded terms that we use in a production system at work and it was very slow. The Erlang shell took more than two minutes to dump the largest file. (It took about 0.1 second to read and parse the file; the rest was spent in io:format.) I decided to scratch that itch: I wrote ppbert, a command-line utility that reads BERT-encoded values and pretty-prints them. I‚Äôve worked sporadically on ppbert for almost a year now, I use it daily at work, I‚Äôm happy with it, and I want to write about some of the things I learned during that journey.",
      "url": "https://vfoley.xyz/ppbert/",
      "date_published": "2018-02-09T00:00:00+00:00",
      "author": {
        "name": "Vincent Foley",
        "url": "http://vfoley.xyz/"
      },
      "tags": [
        "Tools and Applications",
        "Language"
      ]
    },
    {
      "id": "c7a9c9d2-8858-4f47-afa3-19ec1f2f6b86",
      "title": "Maximally minimal specialization: always applicable impls",
      "content_text": "So aturon wrote this beautiful post about what a good week it has been. In there, they wrote: \"Breakthrough #2: @nikomatsakis had a eureka moment and figured out a path to make specialization sound, while still supporting its most important use cases (blog post forthcoming!). Again, this suddenly puts specialization on the map for Rust Epoch 2018\". Sheesh I wish they hadn‚Äôt written that! Now the pressure is on. Well, here goes nothing =).",
      "url": "http://smallcultfollowing.com/babysteps/blog/2018/02/09/maximally-minimal-specialization-always-applicable-impls/",
      "date_published": "2018-02-09T00:00:00-05:00",
      "author": {
        "name": "Niko Matsakis",
        "url": "http://smallcultfollowing.com/babysteps/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "325af8a8-af88-4a07-9c8f-16d2865f01f3",
      "title": "Closing out an incredible week in Rust",
      "content_text": "This week has been so amazing that I just had to write about it. Here‚Äôs a quick list of some of what went down in one week:",
      "url": "http://aturon.github.io/2018/02/09/amazing-week/",
      "date_published": "2018-02-09T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "4924a3b4-b71f-4a15-ae2d-0a77bcb30e98",
      "title": "Async/Await V: Getting back to the futures",
      "content_text": "Two posts ago I proposed a particular interface for shipping self-referential generators this year. Immediately after that, eddyb showed me a better interface, which I described in the next post. Now, to tie everything together, its time to talk about how we can integrate this into the futures ecosystem. Starting point: this Generator API To begin, I want to document the generator API I‚Äôll be using in this post, which is roughly what followed from my previous post:",
      "url": "https://boats.gitlab.io/blog/post/2018-02-08-async-v-getting-back-to-the-futures/",
      "date_published": "2018-02-08T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "ac0c5546-f21b-4b47-b4a4-950464472aad",
      "title": "Async/Await IV: An Even Better Proposal",
      "content_text": "I did not plan to write this blog post. I thought that the fourth post in my series would explain how we could go from the generator API in my previous post to a futures API in which you don‚Äôt have to heap allocate every async call. But eddyb surprised me, and now I have to revisit the API in the previous post, because we can implement everything we need from immovability with a safe interface afterall.",
      "url": "https://boats.gitlab.io/blog/post/2018-02-07-async-iv-an-even-better-proposal/",
      "date_published": "2018-02-07T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "6e3c698d-7f42-43d4-9c08-2ee084945e5c",
      "title": "A vision for portability in Rust",
      "content_text": "TL;DR: This post proposes to deprecate the std facade, instead having a unified std that uses target- and capability-based cfgs to control API availability. Leave comments on internals!",
      "url": "http://aturon.github.io/2018/02/06/portability-vision/",
      "date_published": "2018-02-06T00:00:00+00:00",
      "author": {
        "name": "Aaron Turon",
        "url": "http://aturon.github.io/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "c0b3d7ad-673f-4eb9-aa54-45447d1eafb0",
      "title": "Rust Lifetimes for the Uninitialised",
      "content_text": "Lifetimes are a interesting subject: a lot of people seem to gain a day-to-day familiarity with them, without fully understanding what they are. Maybe, they are truly Rust's Monads. Let's talk about what they are, where you encounter them and then how to get competent with them.",
      "url": "http://asquera.de/blog/2018-01-29/rust-lifetimes-for-the-uninitialised/",
      "date_published": "2018-01-29T15:30:00+01:00",
      "author": {
        "name": "Florian Gilcher",
        "url": "http://asquera.de/blog"
      },
      "tags": [
        "Language",
        "Getting Started"
      ]
    },
    {
      "id": "f4e99fe5-2dab-418d-9256-813a75036164",
      "title": "Introduction to Procedural Macros",
      "content_text": "As a newcomer to Rust, I heard the phrase ‚Äúprocedural macro‚Äù thrown around a lot without really understanding what it meant. I figured that I would learn about them if I ever needed them. Well, I‚Äôm working on the guts of relm, and a large chunk of it is procedural macros. I‚Äôve learned enough about procedural macros to be dangerous, so I thought I would pass on some knowledge.",
      "url": "https://tinkering.xyz/posts/introduction-to-proc-macros/",
      "date_published": "2018-02-03T19:36:37-05:00",
      "author": {
        "name": "Zach Mitchell",
        "url": "https://tinkering.xyz/"
      },
      "tags": [
        "Language"
      ]
    },
    {
      "id": "25060712-7d38-4492-991d-a52a9111891c",
      "title": "Async/Await III: Moving Forward with Something Shippable",
      "content_text": "In the first post, we looked at the relationship between generators and a more general notion of self-references. In the second post, we narrowed down exactly what problem we need to solve to make generators work, and talked about some solutions that we‚Äôve considered but don‚Äôt feel like we could ship in the near future.\nIn the original post, I promised that I would have a near term solution by the end of this series.",
      "url": "https://boats.gitlab.io/blog/post/2018-01-30-async-iii-moving-forward/",
      "date_published": "2018-02-04T00:00:00+00:00",
      "author": {
        "name": "withoutboats",
        "url": "https://boats.gitlab.io/blog/"
      },
      "tags": [
        "Language"
      ]
    }
  ]
}