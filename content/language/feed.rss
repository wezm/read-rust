<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Compile-time coprocessor codegen, with Rust macros</title><link>https://guiand.xyz/blog-posts/macro-assembly-codegen.html</link><description><![CDATA[Motivation: The Nintendo 3DS uses an ARM standard peripheral, the CoreLink DMA engine, for copying memory among DRAM and memory-mapped peripherals.

This DMA engine, unlike most other IO devices on the 3DS, actually has its own instruction set where the CPU merely uploads a stream of instructions for the peripheral to execute (other examples of this, on the 3DS, are the DSP audio processor and the PICA graphics chip).

I‚Äôd like to compile and run DMA instructions in Rust, in a hopefully ergonomic manner, without needing to use any dynamic memory allocation. This imposes a particular constraint that I need to know the number of instruction bytes at compile time so I can use an appropriately-sized array.]]></description><guid isPermaLink="false">433737c5-300e-4095-82c3-2ca05e51b029</guid><pubDate>Fri,  3 May 2019 00:00:00 +0000</pubDate><dc:creator>Gui Andrade</dc:creator></item><item><title>Risp (Lisp (in (Rust)))</title><link>https://m.stopa.io/risp-lisp-in-rust-90a0dad5b116</link><description><![CDATA[Many years ago, Peter Norvig wrote a beautiful article about creating a lisp interpreter in Python. It‚Äôs the most fun tutorial I‚Äôve seen, not just because it teaches you about my favorite language family (Lisp), but because it cuts through to the essence of interpreters, is fun to follow and quick to finish.

Recently, I had some time and wanted to learn Rust. It‚Äôs a beautiful systems language, and I‚Äôve seen some great work come out from those who adopt it. I thought, what better way to learn Rust, than to create a lisp interpreter in it?

Hence, Risp‚Ää‚Äî‚Ääa lisp in rust‚Ää‚Äî‚Ääwas born. In this essay you and I will follow along with Norvig‚Äôs Lispy, but instead of Python, we‚Äôll do it in Rust üôÇ.]]></description><guid isPermaLink="false">4ce6618d-d773-4260-85c6-639aaf6ec7fc</guid><pubDate>Thu,  2 May 2019 17:44:37 +0000</pubDate><dc:creator>Stepan Parunashvili</dc:creator></item><item><title>How XV uses Panics</title><link>https://medium.com/@chrisvest/how-xv-uses-panics-ba22bd6152a5</link><description><![CDATA[XV is a terminal hex viewer that I am working on. It is the first ‚Äúreal‚Äù Rust project that I am working on, coming from a Java background.

Java has exceptions. Both checked exceptions, identified by having the Exception class as a parent class, and unchecked exceptions, which have RuntimeException as a parent class.

Rust does not have exceptions. Rust has panics, which, depending on build-time configurations, are either catch-able when they unwind the stack, or only produce a backtrace, or just immediately aborts the process. This is controlled by the ‚Äúpanic‚Äù setting in the ‚Äúprofile‚Äù sections of your Cargo.toml file.]]></description><guid isPermaLink="false">0bc705c5-726c-4967-84cc-264f7a6338df</guid><pubDate>Thu,  2 May 2019 16:26:24 +0000</pubDate><dc:creator>Chris Vest</dc:creator></item><item><title>Cargo in 2019</title><link>https://www.ncameron.org/blog/cargo-in-2019/</link><description><![CDATA[I recently published a post detailing a vision for the next few years (hah! Not so recently now, this took a lot longer than expected). Here I'll get into more detail about 2019.]]></description><guid isPermaLink="false">ae1f3c27-6a45-4b49-ac3c-e081adfe52c9</guid><pubDate>Wed,  1 May 2019 22:37:35 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Extending Python with Rust</title><link>https://medium.com/@p_chhetri/extending-python-with-rust-84e9299d34c1</link><description><![CDATA[Python is a great programming language but sometimes it can be a bit of slowcoach when it comes to performing certain tasks. That‚Äôs why developers have been building C/C++ extensions and integrating them with Python to speed up the performance. However, writing these extensions is a bit difficult because these low-level languages are not type-safe, so doesn‚Äôt guarantee a defined behavior. This tends to introduce bugs with respect to memory management. Rust ensures memory safety and hence can easily prevent these kinds of bugs.]]></description><guid isPermaLink="false">f759c500-da13-4765-81f1-dd59918b09d1</guid><pubDate>Wed,  1 May 2019 17:37:44 +0000</pubDate><dc:creator>Pradeep Chhetri</dc:creator></item><item><title>Stacked Borrows 2</title><link>https://www.ralfj.de/blog/2019/04/30/stacked-borrows-2.html</link><description><![CDATA[Recently, I have significantly updated Stacked Borrows in order to fix some issues with the handling of shared references that were uncovered in the previous version. In this post, I will describe what the new version looks like and how it differs from Stacked Borrows 1. I assume some familiarity with the prior version and will not explain everything from scratch.]]></description><guid isPermaLink="false">f2a55dcd-b163-42ac-8660-311e1cc384d0</guid><pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>My Key Learnings after 30,000 LOC in Rust</title><link>https://medium.com/@jondot/my-key-learnings-after-30-000-loc-in-rust-a553e6403c19</link><description><![CDATA[For me, Rust takes a stroll over the memory lane above and picks and drives home the best experiences from all those languages‚Ää‚Äî‚Ääwhich is a]]></description><guid isPermaLink="false">094e167c-f023-449e-9976-247d314fd269</guid><pubDate>Mon, 29 Apr 2019 17:57:26 +0000</pubDate><dc:creator>Dotan Nahum</dc:creator></item><item><title>Creating cross-platform Rust terminal apps</title><link>http://www.jonathanturner.org/2019/04/porting-the-pikachu.html</link><description><![CDATA[I‚Äôve been wanting to play around with the cool spinning Pikachu demo everyone was talking about. Sadly, it used termion to do its magic, which meant that unfortunately it wouldn‚Äôt work for me. Termion has been a boon for Rust, with lots of folks using it to create terminal applications. Unfortunately, as a Windows user, I know there‚Äôs a good chance that if the crate depends on termion that‚Äôs the end of the line for me, as termion apps just don‚Äôt work in Windows. Surely, I thought, there must be a better way, but I never managed to find one. Enter crossterm.]]></description><guid isPermaLink="false">28c59573-37da-46b6-92c0-f6fbb4a5e613</guid><pubDate>Sat, 27 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item><item><title>Announcing Rust 1.34.1</title><link>https://blog.rust-lang.org/2019/04/25/Rust-1.34.1.html</link><description><![CDATA[This patch release fixes two false positives and a panic when checking macros in Clippy. Clippy is a tool which provides a collection of lints to catch common mistakes and improve your Rust code.]]></description><guid isPermaLink="false">ce78473f-6f58-428d-ba3e-cbbbfc778345</guid><pubDate>Thu, 25 Apr 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>How Rust Solved Dependency Hell</title><link>https://stephencoakley.com/2019/04/24/how-rust-solved-dependency-hell</link><description><![CDATA[Every once in a while I'll be involved in a conversation about dependency management and versions, often at work, in which the subject of ‚Äúdependency hell‚Äù will come up. If you're not familiar with the term, then I encourage you to look it up. A brief summary might be: "The frustration that comes from dealing with application dependency versions and dependency conflicts". With that in mind, let's get a little technical about dependency resolution.]]></description><guid isPermaLink="false">91b5c36e-a3f8-4cbd-ad0e-cd796ee6ea24</guid><pubDate>Wed, 24 Apr 2019 05:00:00 +0000</pubDate><dc:creator>Stephen Coakley</dc:creator></item><item><title>Rust&apos;s 2019 roadmap</title><link>https://blog.rust-lang.org/2019/04/23/roadmap.html</link><description><![CDATA[Each year the Rust community comes together to set out a roadmap. This year, in addition to the survey, we put out a call for blog posts in December, which resulted in 73 blog posts written over the span of a few weeks. The end result is the recently-merged 2019 roadmap RFC. To get all of the details, please give it a read, but this post lays out some of the highlights.]]></description><guid isPermaLink="false">c66e7e63-ea76-4d35-a15b-0bf56a905b07</guid><pubDate>Tue, 23 Apr 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Elements of Rust: style and philosophy</title><link>https://github.com/ferrous-systems/elements-of-rust</link><description><![CDATA[A collection of software engineering techniques for effectively expressing intent with Rust.]]></description><guid isPermaLink="false">bda9c409-db67-4283-aadc-ffb54c3ad00d</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Ferrous Systems </dc:creator></item><item><title>Generic returns in Rust</title><link>https://blog.jcoglan.com/2019/04/22/generic-returns-in-rust/</link><description><![CDATA[After casting around for a new platform to learn recently, I‚Äôve decided to dive into Rust. Being mostly familiar with untyped languages like Ruby and JavaScript, it‚Äôs interesting to learn a statically typed language and see how it changes how one writes programs. There‚Äôs a common misconception amongst dynamic typing fans that static typing means you write the same programs, they‚Äôre just more verbose and come with more restrictions. And while there is certainly a cost to only being allowed to write type-safe programs, a good type system actually lets you write programs you cannot write in dynamic languages. In Rust, generic return values are a good example of this.]]></description><guid isPermaLink="false">036c9563-3d69-4cf8-a59a-718976fded92</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>James Coglan</dc:creator></item><item><title>Things I Enjoy in Rust: Error Handling</title><link>https://blog.jonstodle.com/things-i-enjoy-in-rust-error-handling/</link><description><![CDATA[I‚Äôve already talked about how I like how enums are used in Rust. They make it easy to express multiple states and the state‚Äôs related data. One place this is excellently utilized is error handling.]]></description><guid isPermaLink="false">8fbc326e-e356-480c-8708-c6b4d8d66719</guid><pubDate>Sun, 21 Apr 2019 12:00:00 +0200</pubDate><dc:creator>Jon Grythe St√∏dle</dc:creator></item><item><title>Lessons moving from iOS delegates to Rust async</title><link>https://thomask.sdf.org/blog/2019/04/19/lessons-moving-from-ios-delegates-to-rust-async.html</link><description><![CDATA[The majority of my async programming experience is on iOS and let me tell you, life is good. You can easily dispatch work to background threads. You can bring work back to the main thread. You can mark your classes as delegates and when you need to handle some event the OS will use a magic pre-existing thread pool to invoke your method and you can do whatever you like. It works perfectly almost all the time, except for when it doesn‚Äôt because of race conditions or it crashes due to concurrency. Life is good.

Rust is less tolerant about the crashing part. While I agree that crashing is bad in principle, avoiding it has significant ramifications for how you can write async code at all. Recently I‚Äôve been finding out what the differences are. Obviously this means I‚Äôm more of a noob than an expert, but I‚Äôm currently in a good position to point out what the confusing parts are and what the Rust solutions seem to be. (But I‚Äôm a noob so take it with a grain of salt.)]]></description><guid isPermaLink="false">0cc3f8b6-7cd9-423f-96f2-569b660e2bf3</guid><pubDate>Fri, 19 Apr 2019 19:30:00 +1000</pubDate><dc:creator>Thomas Karpiniec</dc:creator></item><item><title>Things I Enjoy in Rust: Enums</title><link>https://blog.jonstodle.com/things-i-enjoy-in-rust-enums/</link><description><![CDATA[I‚Äôve been diving into Rust for the last couple of months, after my colleague started talking about it. I‚Äôve been wanting to learn a lower level language, but C++ or something of the like have always seemed too daunting for me to even start.

I‚Äôd heard of Rust before, and great things too, but hadn‚Äôt set apart time to look into it. I finally took the dive. And boy, am I glad I did.

A lot of people talk about the borrowing system of Rust, or how fast it, or the strict type system. All of which are great things, but it‚Äôs not what I‚Äôm going to write about here. I‚Äôm excited about enums.]]></description><guid isPermaLink="false">675975c8-b21a-4d87-8ac3-7e8c74fd8897</guid><pubDate>Thu, 18 Apr 2019 18:00:00 +0200</pubDate><dc:creator>Jon Grythe St√∏dle</dc:creator></item><item><title>Learning Parser Combinators With Rust</title><link>https://bodil.lol/parser-combinators/</link><description><![CDATA[This article teaches the fundamentals of parser combinators to people who are already Rust programmers. It assumes no other knowledge, and will explain everything that isn't directly related to Rust, as well as a few of the more unexpected aspects of using Rust for this purpose. It will not teach you Rust if you don't already know it, and, if so, it probably also won't teach you parser combinators very well.]]></description><guid isPermaLink="false">a085423c-ec98-4fff-ba66-7c23926175d9</guid><pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Bodil Stokke</dc:creator></item><item><title>Proper Notation for Scalar Multiplication in Rust: Dispatching on the Right-Hand Side of Operators and Rusts&apos;s Orphan Rule</title><link>https://www.jstuber.net/2019/04/17/scalar-multiplication-in-rust/</link><description><![CDATA[The scalar multiplication in a vector space is written kv in math, where k is a scalar value (e.g. a number) and v is a vector. It would be nice to write k * v in programming languages, to stay close to the familiar notation. Object-oriented languages typically only support calling methods on the first argument. But the scalar normally doesn't know about vectors, so it can't easily do that.]]></description><guid isPermaLink="false">524e6489-33da-4635-977c-9d86e839d185</guid><pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate><dc:creator>J√ºrgen Stuber</dc:creator></item><item><title>Rust Associated Type</title><link>https://medium.com/codechain/rust-associated-type-b0193c22eacd</link><description><![CDATA[Associated Types in Rust are similar to Generic Types; however, Associated Types limit the types of things a user can do, which consequently facilitates code management. Among the Generic Types of traits, types that depend on the type of trait implementation can be expressed by using the Associated Type syntax. By comparing the Associated and Generic Types, you can get a better understanding of Associated Types.]]></description><guid isPermaLink="false">77c8e0ed-ccb6-4f29-8ab7-1e8c3cd5d39d</guid><pubDate>Tue, 16 Apr 2019 10:08:09 +0000</pubDate><dc:creator>Park Juhyung</dc:creator></item><item><title>Rust: beyond the typechecker</title><link>https://blog.merigoux.ovh/en/2019/04/16/verifying-rust.html</link><description><![CDATA[This post will be different from the previous ones, since I‚Äôm going to present some of the early results of my work as a PhD student at the Prosecco team in ...]]></description><guid isPermaLink="false">8770e0f9-eca2-4f58-b2f4-7761dbcf81bb</guid><pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Denis Merigoux</dc:creator></item><item><title>More than coders</title><link>http://smallcultfollowing.com/babysteps/blog/2019/04/15/more-than-coders/</link><description><![CDATA[Lately, the compiler team has been changing up the way that we work. Our goal is to make it easier for people to track what we are doing and ‚Äì hopefully ‚Äì get involved. This is an ongoing effort, but one thing that has become clear immediately is this: the compiler team needs more than coders.]]></description><guid isPermaLink="false">b35d346f-7773-44c5-8db5-4cbe95fb3749</guid><pubDate>Mon, 15 Apr 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>for await loops (Part I)</title><link>https://boats.gitlab.io/blog/post/for-await-i/</link><description><![CDATA[The biggest unresolved question regarding the async/await syntax is the final syntax for the await operator. There‚Äôs been an enormous amount of discussion on this question so far; a summary of the present status of that discussion and the positions within the language team is coming soon. Right now I want to separately focus on one question which impacts that decision but hasn‚Äôt been considered very much yet: for loops which process streams.]]></description><guid isPermaLink="false">8c6f2335-8fba-4cb5-9da1-2baba7f59159</guid><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Chess vocabulary in Rust</title><link>https://backscattering.de/chess/vocabulary/</link><description><![CDATA[Recently I've been using Rust to build a server for the new 7-piece Syzygy endgame tablebases. Using Rust was quite enjoyable and I plan to use it for many future projects. This series is intended to order and share my thoughts, and as a primer to discuss some open questions I have.]]></description><guid isPermaLink="false">37ea8a58-93a1-4e5c-b125-d98a250e601c</guid><pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Niklas Fiekas</dc:creator></item><item><title>Neat new feature in Rust: iter::from_fn</title><link>https://weblog.latte.ca/blake/tech/rust/makingiterators.html</link><description><![CDATA[Recently Rust has introduced a couple of new features, and the one that caught my eye in particular was std::iter::from_fn, which let‚Äôs you make an iterator from a function, which is most of what that macro was trying to do, so I thought I would try to convert the various places I was using the macro to use the new function instead‚Ä¶]]></description><guid isPermaLink="false">c16ea768-9518-4a40-b51d-9c5e978994a2</guid><pubDate>Sat, 13 Apr 2019 20:49:00 +0000</pubDate><dc:creator>Blake Winton</dc:creator></item><item><title>Using Rust Generics to Enforce DB Record State</title><link>https://fy.blackhats.net.au/blog/html/2019/04/13/using_rust_generics_to_enforce_db_record_state.html</link><description><![CDATA[I‚Äôm currently working on a (private in 2019, public in july 2019) project which is a NoSQL database writting in Rust. To help us manage the correctness and lifecycle of database entries, I have been using advice from the Rust Embedded Group‚Äôs Book. As I have mentioned in the past, state machines are a great way to design code, so let‚Äôs plot out the state machine we have for Entries]]></description><guid isPermaLink="false">ad1e9e94-37b0-4328-93d5-216cb58cd905</guid><pubDate>Sat, 13 Apr 2019 00:00:00 +0000</pubDate><dc:creator>firstyear</dc:creator></item><item><title>Building a pub/sub server with Sonr (part 2)</title><link>https://hagsteel.com/posts/building-a-pub-sub-with-sonr-part-2/</link><description><![CDATA[This is the second part in a two part series on writing a pub/sub server in Rust using Sonr. We will jump straight in building the publisher. This is the biggest piece of code so far in this project.]]></description><guid isPermaLink="false">b7836b84-068e-4db1-9c0c-2dea0652626d</guid><pubDate>Thu, 11 Apr 2019 01:00:00 +0100</pubDate><dc:creator>Jonas</dc:creator></item><item><title>Announcing Rust 1.34.0</title><link>https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html</link><description><![CDATA[The largest feature in this release is the introduction of alternative cargo registries. The release also includes support for ? in documentation tests, some improvements for #[attribute(..)]s, as well as the stabilization of TryFrom. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">c652e06d-95e4-4da0-8ce8-a94c007587d7</guid><pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Mysteriously Low Hanging Fruit: A Big Improvement To LLD For Rust Debug Builds</title><link>https://robert.ocallahan.org/2019/04/mysteriously-low-hanging-fruit-big.html</link><description><![CDATA[LLD is generally much faster than the GNU ld.bfd and ld.gold linkers, so you would think it has been pretty well optimised. You might then be surprised to discover that a 36-line patch dramatically speeds up linking of Rust debug builds, while also shrinking the generated binaries dramatically, both in simple examples and large real-world projects.]]></description><guid isPermaLink="false">afbe8437-4dca-40c1-b6ab-034fbd57c9cd</guid><pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item><item><title>Building a pub/sub server with Sonr (part 1)</title><link>https://hagsteel.com/posts/building-a-pub-sub-with-sonr-part-1/</link><description><![CDATA[This is the first part in a two part series where we explore Sonr by writing a pubsub server in Rust using Sonr.]]></description><guid isPermaLink="false">8042dc34-344d-452f-818c-bebe0f6cf573</guid><pubDate>Wed, 10 Apr 2019 00:00:00 +0100</pubDate><dc:creator>Jonas</dc:creator></item><item><title>A Love Letter to Rust Macros</title><link>https://happens.lol/posts/a-love-letter-to-rust-macros/</link><description><![CDATA[It‚Äôs no secret to people who know me that I‚Äôm a huge fan of the Rust programming language. I could talk for hours about the brilliance of the ownership system, my irrational longing for natively compiled languages without garbage collection, or the welcoming community that finally moved me to take a more active part in open source projects. But for a start, I just want to highlight one of my favourite features: Macros.]]></description><guid isPermaLink="false">749e48bb-50e5-4e7e-8e17-9dd73e1776f2</guid><pubDate>Tue,  9 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Hilmar Wiegand</dc:creator></item><item><title>Javascript evaluator part 2: Parser and Basic evaluator</title><link>https://medium.com/@retep007/javascript-evaluator-part-2-parser-and-basic-evaluator-d306ff1aec83</link><description><![CDATA[This is the second part of writing Javascript evaluator series. I‚Äôm going to talk about my project developing Javascript evaluator in Rust. This post is going to briefly introduce Parsing that‚Äôs build on top of the results from Lexer in the first post. Then I will cover elements of evaluation of abstract syntax tree (AST).]]></description><guid isPermaLink="false">63c81ff0-ee39-437f-a299-70173f639777</guid><pubDate>Mon,  8 Apr 2019 06:39:05 +0000</pubDate><dc:creator>Peter Hrvola</dc:creator></item><item><title>Rustacean Hat Pattern</title><link>http://edunham.net/2019/04/06/rustacean_hat_pattern.html</link><description><![CDATA[Making a Ferris the Rustacean hat.]]></description><guid isPermaLink="false">facd2bd5-bb49-449e-b8d9-c9f353545c32</guid><pubDate>Sat,  6 Apr 2019 00:00:00 +0000</pubDate><dc:creator>E. Dunham</dc:creator></item><item><title>Tricks In Arc Swap</title><link>https://vorner.github.io/2019/04/06/tricks-in-arc-swap.html</link><description><![CDATA[This is a continuation of the Making Arc more atomic post. In short, ArcSwap is a place where you can atomically store and load an Arc, similar to RwLock<Arc<T>> but without the locking. It‚Äôs a good tool if you have some data that is very frequently read but infrequently modified, like configuration or an in-memory database that answers millions of queries per second, but is replaced only every 5 minutes. The canonical example for this is routing tables ‚Äí you want to read them with every passing packet, but you change them only when routing changes.]]></description><guid isPermaLink="false">30a32647-13d1-4d87-89c0-804ef7d456e6</guid><pubDate>Sat,  6 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Our journey from nightly to stable Rust</title><link>https://blog.datalust.co/our-journey-from-rust-nightly-to-stable/</link><description><![CDATA[When we shipped Seq 5.0 back in November, our new storage engine was compiled against Rust's unstable nightly channel. As of Seq 5.1, we can instead use the supported stable channel. That feels like a bit of a milestone so I'd like to share a few details about our journey from nightly to stable, and celebrate the progress the community has made on the language, libraries, and tooling over the last twelve months that made that journey painless for us.]]></description><guid isPermaLink="false">7e90b841-ce0c-47f1-b6ab-420aa7d7bb35</guid><pubDate>Thu,  4 Apr 2019 23:44:23 +0000</pubDate><dc:creator>Ashley Mannix</dc:creator></item><item><title>Complex data types and the Rust FFI</title><link>http://kmdouglass.github.io/posts/complex-data-types-and-the-rust-ffi/</link><description><![CDATA[There are a few good resources on the internet about using the Rust FFI to expose functions written in Rust to other languages. However, I found little information about passing data types between languages. To help remedy this situation, I describe in this post a simple Rust library that I wrote to explore how to pass complex data types from Rust to C.]]></description><guid isPermaLink="false">d171d946-7117-4e2a-bfae-0a4089cdfa9d</guid><pubDate>Thu,  4 Apr 2019 17:51:55 +0000</pubDate><dc:creator>Kyle M. Douglass</dc:creator></item><item><title>Crossing the Rust FFI frontier with Protocol Buffers</title><link>https://hacks.mozilla.org/2019/04/crossing-the-rust-ffi-frontier-with-protocol-buffers/</link><description><![CDATA[The Firefox Application Services engineering team made the decision to use Rust to build cross-platform components for Firefox Sync, powering Firefox Accounts across many devices. They are implementing core business logic using Rust and wrapping it in a thin platform-native layer, such as Kotlin for Android and Swift for iOS.]]></description><guid isPermaLink="false">3046fc78-93d2-4298-a8ae-134f2fbd29b9</guid><pubDate>Tue,  2 Apr 2019 14:42:47 +0000</pubDate><dc:creator>Edouard Oger</dc:creator></item><item><title>Javascript evaluator part 1: Lexing</title><link>https://medium.com/@retep007/javascript-lexing-for-high-performance-f9a800ec930d</link><description><![CDATA[In this post I will describe my latest findings from writing my own Javascript lexer in Rust-lang. I will start by briefly describing what lexing is. Then, I will continue explaining how to implement state machines in Rust-lang. Next, I talk about how to use state machines for Javascript lexing. Last but not least, I cover further performance optimizations of my lexer.]]></description><guid isPermaLink="false">0ee4dffd-3f5f-4c26-9a66-5a2c94db3ace</guid><pubDate>Tue,  2 Apr 2019 06:08:32 +0000</pubDate><dc:creator>Peter Hrvola</dc:creator></item><item><title>An interview with the creator of Gleam: an ML like language for the Erlang VM with a compiler written in Rust</title><link>https://notamonadtutorial.com/an-interview-with-the-creator-of-gleam-an-ml-like-language-for-the-erlang-vm-with-a-compiler-e94775f60dc7</link><description><![CDATA[An interesting thing about Gleam is that its compiler is written in Rust. I think that Rust is a sort of ML + C language. I like C since the developer is at the driver seat driving with manual transmission. I can‚Äôt explain very well but I have always seen C as a simple and powerful language but I have always disliked C++. Knowing that I like ML and C you might understand why I find Rust an interesting language. To sum up we (me and Juan Bono) decided to do this interview with Louis Pilfold not only because of what it is, but also because it is implemented in Rust.]]></description><guid isPermaLink="false">da05eb25-52b2-48f6-9008-944a9a95ccaa</guid><pubDate>Mon,  1 Apr 2019 16:30:35 +0000</pubDate><dc:creator>unbalancedparentheses</dc:creator></item><item><title>How to Write Better Compilation Error Message In Rust</title><link>https://blog.knoldus.com/how-to-write-better-compilation-error-message-in-rust/</link><description><![CDATA[While exploring Rust's standard libraries, I came across a beautiful feature of Rust - compile_error.]]></description><guid isPermaLink="false">9197a635-8114-4c33-ae94-226af2147624</guid><pubDate>Sun, 31 Mar 2019 14:08:04 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>How to Mock Time in Rust Tests and Cargo Gotchas We Met</title><link>https://blog.iany.me/2019/03/how-to-mock-time-in-rust-tests-and-cargo-gotchas-we-met</link><description><![CDATA[I'm working in a team developing a big Rust project recently. The project has some features depending on time. We, the developers, want to be able to mock the time in test. In this post, I'll talk about the problems we have met, mostly related to Cargo.]]></description><guid isPermaLink="false">54d19ed4-0cb7-4ab9-939e-5afcdf8b0ca5</guid><pubDate>Sun, 31 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Ian Yang</dc:creator></item><item><title>Mocking in Rust with conditional compilation</title><link>https://klausi.github.io/rustnish/2019/03/31/mocking-in-rust-with-conditional-compilation.html</link><description><![CDATA[When writing automated unit tests for your application you will probably need to use mocks at some point. Classical object-oriented programming languages such as PHP solve this with reflection where mock object types are created during test runtime. The code under test expects a certain interface or class and the test code passes mock objects that implement the interface or are a subclass.]]></description><guid isPermaLink="false">5b355e5c-bc78-4134-91a2-c383b350d5f8</guid><pubDate>Sun, 31 Mar 2019 00:00:00 +0000</pubDate><dc:creator>klausi</dc:creator></item><item><title>A Story of Rust</title><link>https://jobs.zalando.com/tech/blog/story-rust/</link><description><![CDATA[Introducing Rust in an Enterprise Environment...]]></description><guid isPermaLink="false">f0be7972-25a7-4ff9-af00-904780465c8f</guid><pubDate>Thu, 28 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Christian Douven</dc:creator></item><item><title>Miri available as rustup component</title><link>https://www.ralfj.de/blog/2019/03/26/miri-as-rustup-component.html</link><description><![CDATA[Running your unsafe code test suite in Miri has just gotten even easier: Miri is now available as a rustup component!]]></description><guid isPermaLink="false">ff71674c-714c-4d6d-adde-bca7a03d697e</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Understanding Futures In Rust - Part 1</title><link>https://www.viget.com/articles/understanding-futures-in-rust-part-1/</link><description><![CDATA[Futures make async programming in Rust easy and readable. Learn how to use futures by building them from scratch.]]></description><guid isPermaLink="false">03a41715-2772-48f5-8a75-bd0d4d1d04c7</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Joe Jackson</dc:creator></item><item><title>Kickstarting a database working group</title><link>https://internals.rust-lang.org/t/kickstarting-a-database-wg/9696</link><description><![CDATA[I posted the idea of a database WG on twitter recently and it was met with a lot of excitement. Also there was a post on reddit recently that proposed the same idea, taken from examples of where using Rust with databases is currently a painful experience. I would as part of this also want to work out a base charter to start the WG as well as setting up when and how to have regular meetings to discuss roadmaps and current projects that are being worked on.]]></description><guid isPermaLink="false">29538906-a949-430f-a129-f9c8dca4eb54</guid><pubDate>Mon, 25 Mar 2019 09:53:26 +0000</pubDate><dc:creator>Katharina Fey</dc:creator></item><item><title>The Phantom Builder</title><link>https://wiredforge.com/blog/phantom-builder/index.html</link><description><![CDATA[Recently on twitter, someone asked fora a practical explainer for PhantomData and while I don't have that I did want to share one place I have found PhantomData to be useful. This blog post is an overview of how I ended up using PhantomData in my builder patterns that require a generic type argument.]]></description><guid isPermaLink="false">c24a6d4f-b367-4b18-ad85-52fe59b7e6b3</guid><pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>My First 3 Weeks of Professional Rust</title><link>https://www.wezm.net/technical/2019/03/first-3-weeks-of-professional-rust/</link><description><![CDATA[For the last 15 years as a professional programmer I have worked mostly with dynamic languages. First Perl, then Python, and for the last 10 years or so, Ruby. I‚Äôve also been writing Rust on the side for personal projects for nearly four years. Recently I started a new job and for the first time I‚Äôm writing Rust professionally. Rust represents quite a shift in language features, development process and tooling. I thought it would be interesting to reflect on that experience so far.]]></description><guid isPermaLink="false">98e50b2b-889a-49d1-9973-f1d39c9cc389</guid><pubDate>Sat, 23 Mar 2019 22:45:00 +0000</pubDate><dc:creator>Wesley Moore</dc:creator></item><item><title>Handmade Rust Part 3: Containers</title><link>http://stevenlr.com/posts/handmade-rust-3-containers/</link><description><![CDATA[The most commonly used kinds of containers are arrays and maps. Pretty much any other container type can be built using those two, so that‚Äôs what we‚Äôll build today! Of course, just like for Unq, we won‚Äôt be making simple replacements, instead we‚Äôll be making the most minimal containers necessary for now and add features later as needed, but we‚Äôll be make them allocator aware.]]></description><guid isPermaLink="false">6ed35d04-359f-4971-9cf6-19d824cdcf72</guid><pubDate>Sat, 23 Mar 2019 17:12:54 +0100</pubDate><dc:creator>Steven Le Rouzic</dc:creator></item><item><title>Are we Database Yet?</title><link>https://www.reddit.com/r/rust/comments/b463rg/are_we_database_yet/</link><description><![CDATA[I'm giving a talk next month at our Rust Meetup about using Rust in production. I've been reflecting on my last few months using Rust after learning the language about a year ago. One of my most frustrating experiences tends to always be around the futures ecosystem, as that's where I oft-fruitless labour for hours before giving up on what I'm doing.

I do data engineering and software development work professionally, and these 2 areas are where I often find a lot of pain with using the language.

A few weeks ago I wanted to write something that takes csv files and writes them to a database. I used Apache Arrow's Rust library (which I've started contributing to this year) to do that. The idea was simple, Arrow has a CSV reader that can infer schema, so I map the schema's data types to a database's types, and then I sequentially write records in batches to the database.

I found the exercise quite painful, so I'd like to talk about databases and Rust.]]></description><guid isPermaLink="false">ea9c3fbe-c681-4b42-a0ef-3699a1612972</guid><pubDate>Sat, 23 Mar 2019 02:02:56 +1100</pubDate><dc:creator>nevi-me</dc:creator></item><item><title>Rust All Hands 2019: Array iterators, Rayon, and more</title><link>https://developers.redhat.com/blog/2019/03/22/rust-all-hands-2019-array-iterators-rayon-and-more/</link><description><![CDATA[A few weeks ago, I had the pleasure of attending the second annual Rust All Hands meeting, hosted by Mozilla at their Berlin office. The attendees were a mix of volunteers and corporate employees covering the full range of Rust development, including the compiler, language, libraries, docs, tools, operations, and community. Although I‚Äôm sure there will be an official summary of the meeting (like last year‚Äôs), in this article, I‚Äôll cover a few things I was directly involved in. First, I‚Äôll look at a feature many developers have wanted for a long time‚Ä¶]]></description><guid isPermaLink="false">6450a97d-c96a-47df-b999-a865defe34ae</guid><pubDate>Fri, 22 Mar 2019 07:05:51 +0000</pubDate><dc:creator>Josh Stone</dc:creator></item><item><title>Learning Rust With Entirely Too Many Linked Lists</title><link>https://rust-unofficial.github.io/too-many-lists/</link><description><![CDATA[I fairly frequently get asked how to implement a linked list in Rust. The answer honestly depends on what your requirements are, and it's obviously not super easy to answer the question on the spot. As such I've decided to write this book to comprehensively answer the question once and for all. In this series I will teach you basic and advanced Rust programming entirely by having you implement 6 linked lists.]]></description><guid isPermaLink="false">34dfeb70-4900-4ef3-b6d5-674d3caf376d</guid><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>Chaining Functions Without Returning Self</title><link>https://randompoison.github.io/posts/returning-self/</link><description><![CDATA[It‚Äôs a common pattern in the Rust ecosystem to have a function return self at the end in order to enable method chaining. This approach is often used in combination with the builder pattern, though it can also be applied to a wide variety of other situations. The example demonstrates the most straightforward of these cases (i.e. initializing and modifying an object in a single statement), but, as I‚Äôm going to demonstrate, this approach quickly breaks down when applied to a wider variety of use cases.]]></description><guid isPermaLink="false">88233a0c-3917-4ec2-b2c5-bcfd322a9662</guid><pubDate>Thu, 21 Mar 2019 00:00:00 +0000</pubDate><dc:creator>David LeGare</dc:creator></item><item><title>Why Hashbrown Does A Double-Lookup</title><link>https://gankro.github.io/blah/hashbrown-insert/</link><description><![CDATA[I recently finished a detailed review of hashbrown, which will likely become the new implementation for rust's std::collections::HashMap. One of the most surprising things I found was in the implementation of insert. It was doing something that was so offensive to people who care about collection performance that we had designed an entire API to help people avoid it: it did two lookups in the map. However, after some more discussion and review, I concluded that this implementation was reasonable. This post will try to cover why that is.]]></description><guid isPermaLink="false">38a15a60-b3e5-49c5-9036-3af3d6bc43ff</guid><pubDate>Wed, 20 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>Variance in Rust: An intuitive explanation</title><link>https://ehsanmkermani.com/2019/03/16/variance-in-rust-an-intuitive-explanation/</link><description><![CDATA[Recently I made a presentation about subtyping and variance in Rust for our local Vancouver Rust meetup, but I still think intuition was rather lost in the formalism, so here‚Äôs my shot at explaining it as intuitively as I can.]]></description><guid isPermaLink="false">ee2c7f86-323c-49fe-a707-afc505088445</guid><pubDate>Sun, 17 Mar 2019 03:24:05 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Procedural macro in Rust 101</title><link>https://dev.to/naufraghi/procedural-macro-in-rust-101-k3f</link><description><![CDATA[How to pick a function and make it a macro with added superpowers.]]></description><guid isPermaLink="false">d10fac5d-46ac-49b4-a8e0-517cb3cdfcba</guid><pubDate>Sun, 17 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Matteo Bertini</dc:creator></item><item><title>In nightly Rust, &apos;await!&apos; may never return (dropping futures)</title><link>http://www.randomhacks.net/2019/03/09/in-nightly-rust-await-may-never-return/</link><description><![CDATA[I've been using the proposed await! and Future features in nightly Rust, and overall, I really like the design. But I did run into one surprise: await! may never return, and this has consequences I didn't fully understand. Let's take a look.]]></description><guid isPermaLink="false">eed8a936-e3c7-45b5-bc50-3e1b95ffb767</guid><pubDate>Sat,  9 Mar 2019 15:11:20 -0500</pubDate><dc:creator>Eric Kidd</dc:creator></item><item><title>Should Rust channels panic on send if nobody&apos;s listening?</title><link>http://www.randomhacks.net/2019/03/08/should-rust-channels-panic-on-send/</link><description><![CDATA[Lately, I've been working on several real-world systems using Rust's async and tokio. As you can see on the areweasyncyet.rs site, this requires using nightly Rust and the experimental tokio-async-await library. I hope to talk more about these experiences soon! But today, I want to talk about channel APIs in Rust. A question was raised by @matklad on GitHub, "I've migrated rust-analyzer to crossbeam-channel 0.3, and the thing I've noticed is that every .send is followed by .unwrap. Perhaps we should make this unwrapping behavior the default, and introduce a separate checked_send which returns a Result?".]]></description><guid isPermaLink="false">09e6b7ba-69f9-4256-9ce5-c75ea253c3ec</guid><pubDate>Fri,  8 Mar 2019 16:42:27 -0500</pubDate><dc:creator>Eric Kidd</dc:creator></item><item><title>How productive is Rust?</title><link>https://medium.com/@woutergeraedts/how-productive-is-rust-e2260db28f09</link><description><![CDATA[We often get the question how productive working with Rust is. ‚ÄúWe know that it is awesome, but isn‚Äôt it hard to learn? Don‚Äôt you struggle with the borrow checker?‚Äù. Well, we put it to the test in Google‚Äôs Hash Code 2019 programming competition.]]></description><guid isPermaLink="false">23fcf66c-3fff-4894-836d-32a880171b46</guid><pubDate>Fri,  8 Mar 2019 12:59:39 +0000</pubDate><dc:creator>Wouter Geraedts</dc:creator></item><item><title>Enjoy Compile time function evaluation using &apos;const fn&apos; in Rust</title><link>https://blog.knoldus.com/no-more-run-time-enjoy-compile-time-function-evaluation-using-const-fn-in-rust/</link><description><![CDATA[A few days ago, I was exploring Rust‚Äôs Unstable Book and found pretty much same feature in Rust, which is const_fn. I started exploring this feature more after the recent Rust release 1.33.0, in which Rust team has announced major improvements in const fn. The idea of using const fn is to compute result at compile time so that time can be saved when code is run.]]></description><guid isPermaLink="false">48cd5e22-48f6-4711-a1d2-e9ce7338ef0d</guid><pubDate>Mon,  4 Mar 2019 15:26:43 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>Proposal: New channels for Rust‚Äôs standard library</title><link>https://stjepang.github.io/2019/03/02/new-channels.html</link><description><![CDATA[In this blog post, I‚Äôm proposing we also replace the guts of mpsc with crossbeam-channel for some more performance wins. However, unlike with mutexes and hash maps, this change will also enable oft-requested new features that make it tempting to deprecate mpsc altogether and introduce better channels designed from scratch.]]></description><guid isPermaLink="false">4a9fd96a-fd25-48dd-a97e-511e023b35f8</guid><pubDate>Sat,  2 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Stjepan Glavina</dc:creator></item><item><title>Async-await status report</title><link>http://smallcultfollowing.com/babysteps/blog/2019/03/01/async-await-status-report/</link><description><![CDATA[I wanted to post a quick update on the status of the async-await effort. The short version is that we‚Äôre in the home stretch for some kind of stabilization, but there remain some significant questions to overcome.]]></description><guid isPermaLink="false">c838f89e-80f8-4146-b26e-622020ff2653</guid><pubDate>Fri,  1 Mar 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>JavaFX UI in Rust</title><link>https://astonbitecode.github.io/blog/post/rust-javafx/</link><description><![CDATA[In this post, I would like to share the way how we can implement a Rust application that has a User Interface written in JavaFX.]]></description><guid isPermaLink="false">28f6c857-f8f6-4ff3-8a21-12c894a7dbb8</guid><pubDate>Thu, 28 Feb 2019 00:05:58 +0000</pubDate><dc:creator>Aston</dc:creator></item><item><title>Announcing Rust 1.33.0</title><link>https://blog.rust-lang.org/2019/02/28/Rust-1.33.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.33.0. The two largest features in this release are significant improvements to const fns, and the stabilization of a new concept: "pinning."]]></description><guid isPermaLink="false">e6376cd5-713f-4a8e-8792-2329772feee5</guid><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Rust build scripts vs. Meson</title><link>https://people.gnome.org/~federico/blog/rust-build-scripts.html</link><description><![CDATA[One of the pain points in trying to make the Meson build system work with Rust and Cargo is Cargo's use of build scripts, i.e. the build.rs that many Rust programs use for doing things before the main build. This post is about my exploration of what build.rs does.]]></description><guid isPermaLink="false">f93cc38e-4380-4174-8f53-b5c6674772da</guid><pubDate>Wed, 27 Feb 2019 12:14:12 -0600</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Rust Case Study: Community makes Rust an easy choice for npm [pdf]</title><link>https://www.rust-lang.org/static/pdfs/Rust-npm-Whitepaper.pdf</link><description><![CDATA[Learn how npm uses Rust]]></description><guid isPermaLink="false">b149b575-39a9-4136-8749-29e04c5cf0b3</guid><pubDate>Wed, 27 Feb 2019 03:26:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Bid adieu to tarpaulin, HTML reports are here for Rust</title><link>https://blog.knoldus.com/bid-adieu-to-tarpaulin-html-reports-are-here-for-rust/</link><description><![CDATA[Kcov is a code coverage tool for Binaries, Shell scripts as well as Python scripts. It generates an HTML file for most of the languages. But we will focus mainly on Rust language.]]></description><guid isPermaLink="false">a6483426-5600-4cf0-a514-c532946abda3</guid><pubDate>Tue, 26 Feb 2019 06:41:19 +0000</pubDate><dc:creator>Mudit Chhabra</dc:creator></item><item><title>Rust lang team working groups</title><link>http://smallcultfollowing.com/babysteps/blog/2019/02/22/rust-lang-team-working-groups/</link><description><![CDATA[Now that the Rust 2018 edition has shipped, the language design team has been thinking a lot about what to do in 2019 and over the next few years. I think we‚Äôve got a lot of exciting stuff on the horizon, and I wanted to write about it.]]></description><guid isPermaLink="false">0d3ca45d-85aa-40ab-95f0-40ec5abaa75f</guid><pubDate>Fri, 22 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Changes in the core team</title><link>https://blog.rust-lang.org/2019/02/22/Core-team-changes.html</link><description><![CDATA[Just a quick update: You may have noticed that, in the last month or so, a number of Rust core team members have changed their jobs and/or their roles in the project.]]></description><guid isPermaLink="false">2471466d-74a1-4d19-82d7-6909e10178cd</guid><pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>How to document Rust&apos;s macro invocation</title><link>https://amanjeev.com/blog/rust-document-macro-invocations/</link><description><![CDATA[You can easily document your Rust items like functions by putting three slashes ///. However, if you want to document each separate invocation of your amazing! macro, it is not that straightfoward.]]></description><guid isPermaLink="false">6cab1c1c-68f3-4f20-b239-85009d4d563a</guid><pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Amanjeev Sethi</dc:creator></item><item><title>DOS: the final frontier...</title><link>https://www.reddit.com/r/rust/comments/ask2v5/dos_the_final_frontier/</link><description><![CDATA[In our crusade to oxidize platform after platform, I've been working to bring Rust to yet another target: MS-DOS. I don't know if this has been done before, but I couldn't find any information about it on the web, so I had to rely on information about using GCC to compile MS-DOS programs (not all of which carried over), and it took quite a bit of fiddling with the target specification to get things just right. In the end, I've managed to produce COM executables that can call DOS interrupts and interface with hardware such as the PC speaker, and presumably the rest of the hardware, given the right code.]]></description><guid isPermaLink="false">7c13bc47-79a3-408a-bfc0-d67639f4f359</guid><pubDate>Wed, 20 Feb 2019 15:47:21 +1100</pubDate><dc:creator>u/serentty</dc:creator></item><item><title>rustdoc in 2019</title><link>https://quietmisdreavus.net/code/2019/02/19/rustdoc-in-2019/</link><description><![CDATA[A recap of the 2019 Rust All-Hands from a rustdoc perspective; and the 2019 roadmap for the Rustdoc Team.]]></description><guid isPermaLink="false">5afc518c-63b7-4b76-96f2-659de41359d9</guid><pubDate>Tue, 19 Feb 2019 12:00:00 -0600</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Generators II: The Question Mark Problem</title><link>https://boats.gitlab.io/blog/post/generators-ii/</link><description><![CDATA[This is my second post on the design of generators. In the first post, I outlined what an MVP of the feature would look like. In this post, I want to take a look at the first design issue for the feature: how it integrates with the ? operator.]]></description><guid isPermaLink="false">2c43b8ca-4c87-4138-adfc-2e32660061a2</guid><pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>One Hundred Rust PRs later</title><link>https://phansch.net/2019/02/18/onehundred-rust-prs/</link><description><![CDATA[It‚Äôs hard for me to believe but it‚Äôs already been over a year since I seriously committed to learning Rust and I have now reached my initial goal of 100 open source contributions to the Rust ecosystem. You can see the full list here. I want to use this blog post to review the work I‚Äôve done, talk about the challenges I‚Äôve come across and how I‚Äôve tried to deal with them. I‚Äôm afraid I haven‚Äôt blogged in a long time and this is a bit longer than usual.]]></description><guid isPermaLink="false">9cb7faf6-a9cb-4bf5-9549-96ee7e80dd12</guid><pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Philipp Hansch</dc:creator></item><item><title>Visualizing your Rust code using graphviz</title><link>https://jonathansteyfkens.com/posts/visualizing-rust.html</link><description><![CDATA[In a previous post I mentioned that the Rust compiler allows you to output interesting intermediate languages/formats in a number of different ways. hir, mir and even flowgraphs! In this post I will be giving a brief overview of the flowgraph format and also instructions on how to generate images from your code.]]></description><guid isPermaLink="false">295b15d9-04eb-420c-bc3e-8b3c12a81882</guid><pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Steyfkens</dc:creator></item><item><title>Cross compiling Rust from Linux to macOS</title><link>https://wapl.es/rust/2019/02/17/rust-cross-compile-linux-to-macos.html</link><description><![CDATA[I‚Äôve recently been working on a Rust project at work which requires compiling for Linux (GNU), Linux (musl - for Alpine Linux) and macOS. I use Linux Mint nearly all the time, so building for macOS targets has required asking very nicely to borrow a spare Macbook Air. This is naturally a bit crap, so I set out to find a Linux-only solution to cross compile for macOS using osxcross. A weekend of pain later, and I have the following post. Hopefully it spares you a weekend of your own pain.]]></description><guid isPermaLink="false">e412275c-f2ce-4748-bf3d-c53375ff5693</guid><pubDate>Sun, 17 Feb 2019 00:00:00 +0000</pubDate><dc:creator>James Waples</dc:creator></item><item><title>Getting started with Rust FFI</title><link>https://rushsteve1.us/wp/getting-started-with-rust-ffi/</link><description><![CDATA[The memory models of Rust and C can often cause a lot of friction. This guide is born out of my own personal struggles writing transmission-sys a wrapper for the Transmission BitTorrent client. Though in this guide we will go over the much simpler example of writing a wrapper for libevent-sys.]]></description><guid isPermaLink="false">e9d10b77-3f54-4479-b685-26efa74f67ce</guid><pubDate>Fri, 15 Feb 2019 03:00:32 +0000</pubDate><dc:creator>Rushsteve1</dc:creator></item><item><title>Fearless Security: Thread Safety</title><link>https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/</link><description><![CDATA[Multithreading allows programs to do more faster, but adds synchronization bugs and attacks. From a security standpoint, why do we care about thread safety?]]></description><guid isPermaLink="false">5e9e06ae-e22f-4798-b921-d8cb96bf451e</guid><pubDate>Thu, 14 Feb 2019 15:48:10 +0000</pubDate><dc:creator>Diane Hosfelt</dc:creator></item><item><title>Moving from Ruby to Rust</title><link>https://deliveroo.engineering/2019/02/14/moving-from-ruby-to-rust.html</link><description><![CDATA[How we migrated our Tier 1 service from Ruby to Rust and didn‚Äôt break production.]]></description><guid isPermaLink="false">d1d825d3-b864-466c-9909-287ae17591a9</guid><pubDate>Thu, 14 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Andrii Dmytrenko</dc:creator></item><item><title>Gtk-rs: how to have mutable object in a closure?</title><link>http://sireliah.com/niusy/gtk_rust_mutable_object_in_closure/</link><description><![CDATA[I wanted, was to start the Gtk application with already generated image of the prime numbers spiral (contained in gtk::Image widget) and then be able to re-generate the image when user changed something. It could be "Generate" click action for instance to show image in different resolution or color. The problem with the button closure was that when I added the Gtk image to the box_vert container, the next time the button was pressed, the code was supposed to remove existing image and add new one, but it didn't.]]></description><guid isPermaLink="false">56014abd-0fd0-4b8c-91ba-734e4f16ddac</guid><pubDate>Tue, 12 Feb 2019 21:58:00 +0000</pubDate><dc:creator>Piotr Go≈ÇƒÖb</dc:creator></item><item><title>No, the problem isn‚Äôt ‚Äúbad coders‚Äù</title><link>https://medium.com/@sgrif/no-the-problem-isnt-bad-coders-ed4347810270</link><description><![CDATA[A recent blog article discussed the fact that 70% of all security bugs in Microsoft products are due to memory safety vulnerabilities. A lot of the comments I‚Äôve seen on social media boil down to ‚ÄúThe problem isn‚Äôt the use of a memory unsafe language, but that the programmers who wrote this code are bad.‚Äù

In this article, I‚Äôm going to look at a recent bug that was caught by the Rust compiler, which I think shows that not only is this assertion unreasonable but virtually impossible for reasons I haven‚Äôt seen discussed. While the example I‚Äôm going to give is about thread safety rather than memory safety, the arguments I‚Äôm going to present can be applied to both.]]></description><guid isPermaLink="false">1c46694b-ae67-4596-9f46-0e9fd419f585</guid><pubDate>Tue, 12 Feb 2019 16:13:55 +0000</pubDate><dc:creator>Sean Griffin</dc:creator></item><item><title>A Quick Look at Trait Objects in Rust</title><link>https://tratt.net/laurie/blog/entries/a_quick_look_at_trait_objects_in_rust.html</link><description><![CDATA[One of the things that baffled me for quite a long time are Rust‚Äôs ‚Äútrait objects‚Äù: they felt like an odd part of the language and I was never quite sure whether I was using them or not, even when I wanted to be. Since I‚Äôve recently had cause to look into them in more detail, I thought it might be helpful to write a few things down, in case anyone else finds my explanation useful. The first part of this blog post covers the basics and the second part takes a look at the performance implications of the way trait objects are implemented in Rust.]]></description><guid isPermaLink="false">16bded10-81dc-4ef1-bf04-83a8ab584308</guid><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Laurence Tratt</dc:creator></item><item><title>All-Hands 2019 Recap</title><link>https://www.ralfj.de/blog/2019/02/12/all-hands-recap.html</link><description><![CDATA[Last week, I was in Berlin at the Rust All-Hands 2019. It was great! I will miss nerding out in discussions about type theory and having every question answered by just going to the person who‚Äôs the expert in that area, and asking them. In this post, I am summarizing the progress we made in my main areas of interest and the discussions I was involved in‚Äîthis is obviously just a small slice of all the things that happened.]]></description><guid isPermaLink="false">03bb4da4-48ab-4e1a-a092-be737761fd6f</guid><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Are you still using `println` in Rust for debugging?</title><link>https://blog.knoldus.com/are-you-still-using-println-in-rust-for-debugging/</link><description><![CDATA[In this blog, I will explain about new debugging macro dbg, added in Rust 1.32.0. This is a macro for quick and dirty debugging with which you can inspect the value of a given expression.]]></description><guid isPermaLink="false">3c0e89db-b8b3-44bc-a952-4cf406146fae</guid><pubDate>Mon, 11 Feb 2019 04:20:21 +0000</pubDate><dc:creator>Ayush Mishra</dc:creator></item><item><title>Generators I: Toward a minimum viable product</title><link>https://boats.gitlab.io/blog/post/generators-i/</link><description><![CDATA[We‚Äôre still not finished with the design of async/await, but it‚Äôs already become clear that it‚Äôs time to get the next phases of the feature into the pipeline. There are two extensions to the minimal async/await feature we‚Äôve currently got that seem like the clear high priority:
 Async methods: allowing async fn to be used in traits. Generators: allowing imperative control flow to create Iterators and Streams the same way async fn allows imperative control flow to create a Future.]]></description><guid isPermaLink="false">a22c0b8e-ed54-4502-8130-a03913b6ff67</guid><pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Handmade Rust Part 2: Unq, an allocator-aware Box</title><link>http://stevenlr.com/posts/handmade-rust-2-unq/</link><description><![CDATA[In the Rust standard library, Box is a RAII wrapper for an object on the heap. It‚Äôs actually a special type that‚Äôs not implemented purely in the library, but also use special features called lang items. It uses the global allocator to allocate its memory. We want a similar type that also has an allocator associated to it. We‚Äôll call it Unq, which mirror C++‚Äôs unique_ptr.]]></description><guid isPermaLink="false">59ecea36-40a2-4b3a-aaf5-2d156d885d24</guid><pubDate>Sun, 10 Feb 2019 16:30:21 +0100</pubDate><dc:creator>Steven Le Rouzic</dc:creator></item><item><title>Handmade Rust Part 1: Introduction &amp; Allocators</title><link>http://stevenlr.com/posts/handmade-rust-1-allocators/</link><description><![CDATA[Welcome to Handmade Rust, a series (hopefully) where I will be developing a Vulkan rendering engine in Rust the Handmade way. By this, I mean using no external libraries, not even the Rust standard library, only the core lib. I am doing this mainly for my own enjoyment but also because I want to get better at writing Rust, and sometimes the best way to really understand something is to just do it yourself. The project will be available on GitHub at stevenlr/HandmadeRust.

The first step will be to build a foundation library for memory allocation, containers, and other utilities that are not provided by the core lib.]]></description><guid isPermaLink="false">5190b436-eaa3-4067-a6a0-fec861ea8316</guid><pubDate>Sun, 10 Feb 2019 00:50:11 +0100</pubDate><dc:creator>Steven Le Rouzic</dc:creator></item><item><title>MPSC Channel API for painless usage of threads with GTK in Rust</title><link>https://coaxion.net/blog/2019/02/mpsc-channel-api-for-painless-usage-of-threads-with-gtk-in-rust/</link><description><![CDATA[A very common question that comes up on IRC or elsewhere by people trying to use the gtk-rs GTK bindings in Rust is how to modify UI state, or more specifically GTK widgets, from another thread. I‚Äôll take this opportunity to also explain why it‚Äôs not so trivial in Rust first and also explain another solution.]]></description><guid isPermaLink="false">2c0fbe82-0ef4-455a-94f9-886472559fdb</guid><pubDate>Sat,  9 Feb 2019 13:25:55 +0000</pubDate><dc:creator>Sebastian Dr√∂ge</dc:creator></item><item><title>Summary: What are the Allocation Rules?</title><link>https://speice.io/2019/02/summary.html</link><description><![CDATA[While there‚Äôs a lot of interesting detail captured in this series, it‚Äôs often helpful to have a document that answers some ‚Äúyes/no‚Äù questions. You may not care about what an Iterator looks like in assembly, you just need to know whether it allocates an object on the heap or not. And while Rust will prioritize the fastest behavior it can, here are the rules for each memory type]]></description><guid isPermaLink="false">865d719c-3067-49d0-8bfc-361bfe91d257</guid><pubDate>Sat,  9 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Custom Exit Status Codes with ? in main</title><link>https://www.joshmcguigan.com/blog/custom-exit-status-codes-rust/</link><description><![CDATA[Rust 1.26 introduced the ability to return a Result from the main method, which was a great ergonomics improvement especially for small CLI applications. If your application returns an Ok, Rust reports a success exit status code to the operating system. Likewise if your application returns an Err, Rust reports an error exit status code.

But what if you want to return a custom exit status error code for each possible error type in your application, to provide some additional feedback to your user? This leads into an exploration of the Termination and Try traits, and is the topic of this post.]]></description><guid isPermaLink="false">1e324360-c349-474e-b091-7c5250958ffc</guid><pubDate>Sat,  9 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Exploring Rust</title><link>https://jonathansteyfkens.com/posts/explore-rust.html</link><description><![CDATA[Rust provides a lot of language constructs to enable and empower the user to write memory safe and correct code. But what happens behind these constructs? In this post I will outline ways of exploring rust and it‚Äôs compiler.

Last weekend I went to fosdem 2019. This is where I had the chance to attend a talk given by Matthias Endler. In his talk he explained how rust has got a lot of syntactic sugar to help the programmers in writing safe and correct code, part of his talk was explaining cargo-inspect to analyse this syntax and see what‚Äôs happening behind the scenes. This inspired me to dig a bit deeper and try out other tools.]]></description><guid isPermaLink="false">82089039-8f19-4e01-8d91-d0ef468bbab8</guid><pubDate>Sat,  9 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Jonathan Steyfkens</dc:creator></item><item><title>Compiler Optimizations: What It&apos;s Done Lately</title><link>https://speice.io/2019/02/compiler-optimizations.html</link><description><![CDATA[Throughout the series so far, we‚Äôve put a handicap on the code. In the name of consistent and understandable results, we‚Äôve asked the compiler to pretty please leave the training wheels on. Now is the time where we throw out all the rules and take off the kid gloves. As it turns out, both the Rust compiler and the LLVM optimizers are incredibly sophisticated, and we‚Äôll step back and let them do their job.

Similar to ‚ÄúWhat Has My Compiler Done For Me Lately?‚Äù, we‚Äôre focusing on interesting things the Rust language (and LLVM!) can do with memory management.]]></description><guid isPermaLink="false">4984adf8-b660-4433-a888-8bd84d669dc0</guid><pubDate>Fri,  8 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>The Builder Pattern in Rust</title><link>https://oribenshir.github.io/afternoon_rusting/blog/building-rust</link><description><![CDATA[For the very first coding blog, I think it is appropriate to start with building objects. This post is about the Builder Pattern in Rust, and how it taught me I couldn‚Äôt write everything the way I want. Yes, strong typing prevents you from common pitfalls, and C++ can go quite far in this direction (as many JS/Python enthusiastic will gladly testify). It is often easy to forget how it sometimes prevents you from writing a completely legal and safe code, due to rules being too ‚Äúprotective‚Äù. And as Rust takes the code safety to a whole new level, sometimes a trivial code can‚Äôt be written, and without the proper knowledge, it might seem entirely arbitrary. It was a subtle restriction in the builder pattern that took me by surprise first.]]></description><guid isPermaLink="false">52b68916-b65b-4a28-9bac-e8c8038c6194</guid><pubDate>Fri,  8 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>Dynamic Memory: A Heaping Helping</title><link>https://speice.io/2019/02/a-heaping-helping.html</link><description><![CDATA[Managing dynamic memory is hard. Some languages assume users will do it themselves (C, C++), and some languages go to extreme lengths to protect users from themselves (Java, Python). In Rust, how the language uses dynamic memory (also referred to as the heap) is a system called ownership. And as the docs mention, ownership is Rust‚Äôs most unique feature.]]></description><guid isPermaLink="false">e69005a8-5193-4715-b906-f7a1a71db4f0</guid><pubDate>Thu,  7 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Rust: A unique perspective</title><link>https://limpet.net/mbrubeck/2019/02/07/rust-a-unique-perspective.html</link><description><![CDATA[In which I try to explain the reasoning behind Rust‚Äôs memory-safety mechanisms.]]></description><guid isPermaLink="false">d7fe7d63-d2c8-4bfc-834b-a93155c10dcb</guid><pubDate>Thu,  7 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Matt Brubeck</dc:creator></item><item><title>Fixed Memory: Stacking Up</title><link>https://speice.io/2019/02/stacking-up.html</link><description><![CDATA[const and static are perfectly fine, but it‚Äôs relatively rare that we know at compile-time about either values or references that will be the same for the duration of our program. Put another way, it‚Äôs not often the case that either you or your compiler knows how much memory your entire program will ever need.]]></description><guid isPermaLink="false">44856ee1-451a-44b6-8cc1-5afd881bb57d</guid><pubDate>Wed,  6 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Global Memory Usage: The Whole World</title><link>https://speice.io/2019/02/the-whole-world.html</link><description><![CDATA[The first memory type we‚Äôll look at is pretty special: when Rust can prove that a value is fixed for the life of a program (const), and when a reference is unique for the life of a program (static as a declaration, not 'static as a lifetime), we can make use of global memory. This special section of data is embedded directly in the program binary so that variables are ready to go once the program loads; no additional computation is necessary.]]></description><guid isPermaLink="false">108f009d-94b1-43c6-8598-43088175772e</guid><pubDate>Tue,  5 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Allocations in Rust</title><link>https://speice.io/2019/02/understanding-allocations-in-rust.html</link><description><![CDATA[There‚Äôs an alchemy of distilling complex technical topics into articles and videos that change the way programmers see the tools they interact with on a regular basis. I knew what a linker was, but there‚Äôs a staggering amount of complexity in between the OS and main(). Rust programmers use the Box type all the time, but there‚Äôs a rich history of the Rust language itself wrapped up in how special it is.

In a similar vein, this series attempts to look at code and understand how memory is used; the complex choreography of operating system, compiler, and program that frees you to focus on functionality far-flung from frivolous book-keeping. The Rust compiler relieves a great deal of the cognitive burden associated with memory management, but we‚Äôre going to step into its world for a while.

Let‚Äôs learn a bit about memory in Rust.]]></description><guid isPermaLink="false">ba471387-4b93-4e46-8846-c89beddf6916</guid><pubDate>Mon,  4 Feb 2019 00:00:00 -0500</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Rust Governance: Scaling Empathy</title><link>https://manishearth.github.io/blog/2019/02/04/rust-governance-scaling-empathy/</link><description><![CDATA[There‚Äôs been a lot of talk about improving Rust‚Äôs governance model lately. As we decompress from last year‚Äôs hectic edition work, we‚Äôre slowly starting to look at all the bits of debt we accumulated, and organizational debt is high on that list.

I‚Äôve been talking in private with people about a bunch of these things for quite a while now, and I felt it worthwhile to write down as much of my thoughts as I can before the Rust All Hands in Berlin this week.]]></description><guid isPermaLink="false">66563fe6-008a-475e-9337-42ee770d649c</guid><pubDate>Mon,  4 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Manish Goregaokar</dc:creator></item><item><title>How to Debug Rust with Visual Studio Code</title><link>https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/</link><description><![CDATA[A step-by-step guide for debugging Rust with Visual Studio Code.]]></description><guid isPermaLink="false">166e7e9f-de17-4abb-b2f4-08169793f3dd</guid><pubDate>Sun,  3 Feb 2019 20:01:00 +0000</pubDate><dc:creator>Forrest Smith</dc:creator></item><item><title>Rust: regret-less concurrency</title><link>https://medium.com/@polyglot_factotum/rust-regret-less-concurrency-2238b9e53333</link><description><![CDATA[Rust offers the promise of ‚Äúfearless concurrency‚Äù, and delivers on it through memory safety. Yet this safety doesn‚Äôt guarantee code that is easy to maintain. If one is not ‚Äúfearful‚Äù of complexity, concurrency can easily become a story of regrets. Can we get a ‚Äúregret-less‚Äù kind of concurrency?]]></description><guid isPermaLink="false">4a6ed1c0-83d7-4392-9d2a-9b749a5433fe</guid><pubDate>Sat,  2 Feb 2019 12:15:32 +0000</pubDate><dc:creator>Polyglot Factotum</dc:creator></item></channel></rss>