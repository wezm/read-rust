<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>MIR-based borrowck is almost here</title><link>http://smallcultfollowing.com/babysteps/blog/2018/10/31/mir-based-borrowck-is-almost-here/</link><description><![CDATA[Now that the final Rust 2018 Release Candidate has shipped, I thought it would be a good idea to do another update on the state of the MIR-based borrow check (aka NLL). Letâ€™s get the highlights out of the way. Most importantly, Rust 2018 crates will use NLL by default. Once the Rust 2018 release candidate becomes stable, we plan to switch Rust 2015 crates to use NLL as well, but weâ€™re holding off until we have some more experience with people using it in the wild.]]></description><guid isPermaLink="false">3c73e50b-c4cd-43ea-9214-49f711bf3058</guid><pubDate>Wed, 31 Oct 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>From Rust to beyond: The PHP galaxy</title><link>https://mnt.io/2018/10/29/from-rust-to-beyond-the-php-galaxy/</link><description><![CDATA[This blog post is part of a series explaining how to send Rust beyond earth, into many different galaxies. The galaxy we will explore today is the PHP galaxy. This post will explain what PHP is, how to compile any Rust program to C and then to a PHP native extension.]]></description><guid isPermaLink="false">6bf46601-8824-4e8e-b625-f3b6f9d074da</guid><pubDate>Mon, 29 Oct 2018 10:17:12 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Finding and fixing memory leaks in a Hyper application or &apos;How I Learned to Stop Worrying and Love the Allocator&apos;</title><link>https://blog.1aim.com/2018/10/finding-and-fixing-memory-leaks-in-a-hyper-application-or-how-i-learned-to-stop-worrying-and-love-the-allocator/</link><description><![CDATA[I was doing some initial load testing of the next version our application, so that performance regressions can be tracked, when I noticed something. After only a few seconds of throwing wrk at it, our backend was using 1.3GB of memory, growing at around 50MB/s. Yikes.]]></description><guid isPermaLink="false">1f6655e8-89c4-4e30-91e6-776449b88293</guid><pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Ferdia McKeogh</dc:creator></item><item><title>My release checklist for Rust programs</title><link>https://dev.to/sharkdp/my-release-checklist-for-rust-programs-1m33</link><description><![CDATA[After some practice with three of my Rust projects (fd, hyperfine and bat), my workflow has converged to something that works quite well and avoids many pitfalls that I have walked into in the past. My hope in writing this post is that this process can be useful for others as well. The following is my release checklist for fd, but I have very similar lists for other projects.]]></description><guid isPermaLink="false">e5f786a1-6dd9-427f-8202-03b5a38a7ace</guid><pubDate>Sun, 28 Oct 2018 00:00:00 +0000</pubDate><dc:creator>David Peter</dc:creator></item><item><title>Improving ndarray-csv: Goodbye failure, Hello Extension Traits</title><link>https://paulkernfeld.com/2018/10/27/improving-ndarray-csv.html</link><description><![CDATA[Two weeks ago, I wrote a blog post explaining some design decisions that I made for the ndarray-csv crate. Based on some excellent Reddit comments and GitHub issues from dtolnay, I have amended some of these decisions.]]></description><guid isPermaLink="false">427d9cb0-4562-45c7-b6f0-3defc4df172b</guid><pubDate>Sat, 27 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Problems Scaling A Large Multi-Crate Rust Project</title><link>https://robert.ocallahan.org/2018/10/problems-scaling-large-multi-crate-rust.html?m=1</link><description><![CDATA[We have 85K lines of Rust code implementing the backend of our Pernosco debugger. To impose some modularity constraints and to reduce build times, from the beginning we organized our code as a large set of crates in a single Cargo workspace in a single Gitlab repository. Currently we have 48 crates. This has mostly worked pretty well but as the number of our crates keeps increasing, we have hit some serious scalability problems.]]></description><guid isPermaLink="false">e64df9c0-3056-4720-837e-670543317c59</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item><item><title>The Case For Macros</title><link>https://llogiq.github.io/2018/10/25/macros.html</link><description><![CDATA[I know a few Rustaceans who are wary of macros. One privately admitted to hating them with a passion. They are right; macros can make code harder to understand (both for humans and computers, for example many clippy lints have an explicit check to only lint outside of macros), so they should be used with some caution.]]></description><guid isPermaLink="false">451e814b-f0e1-4d88-bdda-9862ab107902</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Announcing Rust 1.30</title><link>https://blog.rust-lang.org/2018/10/25/Rust-1.30.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.30.0. Rust 1.30 is an exciting release with a number of features: Procedural Macros, Module system improvements, Raw Identifiers, and more.]]></description><guid isPermaLink="false">3db4746e-d5ac-46c7-af24-a25e2db1b7d2</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Rust&apos;s Orphan Rule Is Good, Actually</title><link>https://davidlegare.ghost.io/rusts-orphan-rule/</link><description><![CDATA[The orphan trait rule in Rust is interesting and works impressively well for what it intends to do. While I'm often frustrated by the limitations it imposes, it absolutely succeeds at removing ambiguity in whether or not a trait will be implemented for a type.]]></description><guid isPermaLink="false">c2e61957-0d95-43e3-af09-3173307bf95c</guid><pubDate>Sat, 20 Oct 2018 05:42:04 +0000</pubDate><dc:creator>David LeGare</dc:creator></item><item><title>Towards fearless SIMD</title><link>https://raphlinus.github.io/rust/simd/2018/10/19/fearless-simd.html</link><description><![CDATA[SIMD is a powerful performance technique, and is especially valuable in signal and image processing applications. I will be using it very extensively in my synthesizer, and also itâ€™s increasingly used in xi-editor to optimize string comparisons and similar primitives.]]></description><guid isPermaLink="false">4f32d4ec-419f-4025-b508-3c486ffb059e</guid><pubDate>Fri, 19 Oct 2018 17:03:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Is Rust functional?</title><link>https://www.fpcomplete.com/blog/2018/10/is-rust-functional</link><description><![CDATA[Rust is an imperative systems programming language. Why does it have so much attention from functional programming advocates? Is it hiding a functional nature?]]></description><guid isPermaLink="false">b39581e7-2147-4b4a-bfdf-b19141e80d89</guid><pubDate>Thu, 18 Oct 2018 03:02:08 +0000</pubDate><dc:creator>Michael Snoyman</dc:creator></item><item><title>Rust has higher kinded types already... sort of</title><link>https://joshlf.com/post/2018/10/18/rust-higher-kinded-types-already/</link><description><![CDATA[In Rust, a type which takes type parameters (Rc<T>, Vec<T>, HashMap<K, V>, etc) is only a valid type when all type parameters are specified. In other words, Rc, Vec, and HashMap<K> are not types. You canâ€™t have a variable of type Rc. You canâ€™t pass Rc as a parameter to other types. The ability to have such things be actual types is a feature called higher kinded types (HKT).]]></description><guid isPermaLink="false">4c54199d-d367-4525-8202-cba2c82afa3d</guid><pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Joshua Liebow-Feeser</dc:creator></item><item><title>Const-fn compile-time SUBLEQ interpreter</title><link>https://www.reddit.com/r/rust/comments/9o6vzo/constfn_compiletime_subleq_interpreter/</link><description><![CDATA[With the minimal subset of const fn becoming stable soon (in the second next Rust version), I wanted to give const fns a try and test what is possible with them. We implemented a compile-time SUBLEQ interpreter which only uses const-fns, which you can find on the playground. Let's walk through the process of building this abomination :)]]></description><guid isPermaLink="false">e7b5dffe-46bb-42a8-a17c-2ede829080ff</guid><pubDate>Mon, 15 Oct 2018 09:10:49 +1100</pubDate><dc:creator>u/oberien</dc:creator></item><item><title>Rust and features discoverability</title><link>https://phaazon.net/blog/rust-features-documentation</link><description><![CDATA[Whatever the project you work on, you should must document your code. There are several situations â€“ letâ€™s call this the First Hypothesis]]></description><guid isPermaLink="false">476c5ab3-1148-4507-b294-8e4c06a188fd</guid><pubDate>Sat, 13 Oct 2018 23:37:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>Fixing a Clippy crash</title><link>https://phansch.net/2018/10/10/fixing-a-clippy-crash/</link><description><![CDATA[3 weeks ago I set out to fix a crash in Clippy, this is what I learned along the way. I hope this blog post will be useful for other people diving into Clippy and maybe serve as motivation if things get difficult.]]></description><guid isPermaLink="false">08336620-497d-49b2-9e77-eeb36d26f512</guid><pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Hansch</dc:creator></item><item><title>Rust has a static garbage collector</title><link>https://words.steveklabnik.com/borrow-checking-escape-analysis-and-the-generational-hypothesis</link><description><![CDATA[Iâ€™ve often seen people make statements like this one, from the Rust subreddit this morning, "Manual memory management requires more work than garbage collected. Its a trade off of course to be more performant or use lower resources. When and where should Rust be used or not used according to you?". While I donâ€™t completely disagree with this sentiment, itâ€™s also never quite sat right with me. Yes, Rust is a bit harder at the start, but once you get over a hump, I donâ€™t generally find writing Rust to be significantly harder than using a GCâ€™d language. Iâ€™ve been trying to figure out why that is.]]></description><guid isPermaLink="false">a3b6b34c-174b-4738-9c06-c9ab251718c4</guid><pubDate>Wed, 10 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Rust and the Three Laws of Informatics</title><link>https://medium.com/@schemouil/rust-and-the-three-laws-of-informatics-4324062b322b</link><description><![CDATA[What are the most important properties of programs, and how much do existing languages help? How is Rust different?]]></description><guid isPermaLink="false">0f56caac-74c9-414c-89d5-fe1cb9a74424</guid><pubDate>Tue,  9 Oct 2018 07:42:09 +0000</pubDate><dc:creator>Simon Chemouil</dc:creator></item><item><title>Notes on Type Layouts and ABIs in Rust</title><link>https://gankro.github.io/blah/rust-layouts-and-abis/</link><description><![CDATA[Over the years I've found myself with a weird amount of knowledge about how types and ABIs in Rust work, and I wanted to write it all down in one place so that... it's written down in one place. Much of this information can or should be found in the Rust Language Reference and the Rustonomicon.]]></description><guid isPermaLink="false">492f5ab9-f95c-480b-8377-dc2f06e836b8</guid><pubDate>Tue,  9 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>Porting C (minimp3) To Rust</title><link>https://wiki.alopex.li/PortingCToRust</link><description><![CDATA[So because it seemed like a good idea at the time, I decided to port the minimp3 library from C to Rust. I want a pure Rust MP3 decoder crate to exist under a permissive license, I wanted to learn a few things about the MP3 file format, and it seemed small enough to do in a single weekend. (In reality it was largely done in about a week.) Iâ€™m quite good at Rust, and Iâ€™m okay at C (but rusty; hah!), and I know nothing at all about MP3 decoding. So, it was a fun learning experience. It was very interesting seeing how C and Rustâ€™s different feature set changed how the programs were written. minimp3 turned out to be a good choice for this, since it is standalone, pretty well-written C as far as I can tell, does nothing that needs to be unsafe, and small but not trivial. This article is an attempt to organize my thoughts, notes and observations as I went about the project, in the hopes that it will be useful or at least interesting to someone else.]]></description><guid isPermaLink="false">ab2b9642-16a3-4d28-9f8b-5f6938964600</guid><pubDate>Mon,  8 Oct 2018 19:53:10 +0000</pubDate><dc:creator>Simon Heath</dc:creator></item><item><title>Hunting for Bugs in Rust</title><link>https://blog.troutwine.us/2018/10/08/hunting-for-bugs-in-rust/</link><description><![CDATA[Way back in August I announced that I was starting in on "a project to QuickCheck Rustâ€™s standard library data structures", here. And I did! The project is called bughunt-rust and I've been poking at it on weekends since, adjusting my approach based on papers I've been reading, experience gained writing test code and the kind of results I've been getting. This post goes through what I've been up to, where I see the project heading in the near term.]]></description><guid isPermaLink="false">a8939774-cb65-4cca-b7c4-47f8f0249f96</guid><pubDate>Mon,  8 Oct 2018 17:27:54 +0000</pubDate><dc:creator>Brian L. Troutwine</dc:creator></item><item><title>Declarative Rust static analysis</title><link>http://blog.lambdaverse.org/comacro/</link><description><![CDATA[Rust's Macros 2.0 are intuitive: demonstrate a pattern, and the compiler can insert the pattern into your program wherever you want it. Inspired by this syntax, I wondered: Could you â€œrun a macro backwardsâ€â€”use the same by-example language to describe patterns to search for?]]></description><guid isPermaLink="false">fd7f3d68-5d82-41ba-b841-d11a37e4b98d</guid><pubDate>Sun,  7 Oct 2018 19:23:17 +0000</pubDate><dc:creator>Kaz Wesley</dc:creator></item><item><title>Testing reqwest-based clients</title><link>https://write.as/balrogboogie/testing-reqwest-based-clients</link><description><![CDATA[In this article we will make a small Rust library that uses the reqwest http client library, and see what we can do to adequately test the business logic. We assume you have the Rust toolchain installed, and are at least passingly familiar with programming in Rust.]]></description><guid isPermaLink="false">e34760d5-658d-475a-91eb-c489a649ee86</guid><pubDate>Fri,  5 Oct 2018 20:57:27 +0000</pubDate><dc:creator>balrogboogie</dc:creator></item><item><title>Default valuesÂ ..copy that</title><link>https://medium.com/@softprops/default-values-copy-that-ae43831781f3</link><description><![CDATA[When I talk to folks foreign to Rust, I often get asked the question: â€œWhy doesnâ€™t Rust have support for default argumentsâ€. When I first started learning Rust I pondered the same question. Eventually I came to realize that it does, kind of. Rust just takes different approach based on itâ€™s unique design choices, one which I now wish other languages supported.]]></description><guid isPermaLink="false">d7c70ce9-96bc-4518-8e3e-429503883006</guid><pubDate>Thu,  4 Oct 2018 17:06:48 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Who authors the most popular crates on crates.io?</title><link>https://words.steveklabnik.com/who-authors-the-most-popular-crates-on-crates-io</link><description><![CDATA[I had a question this morning: who authors the most popular crates on crates.io? First, we have to figure out what we mean by â€œmost popular.â€ My first guess was â€œtop 100 by recent downloadsâ€, so I looked at crates.io. Once I got to 100, I found... | Steve Klabnik | â€œThe most violent element in society is ignorance.â€ - Emma Goldman]]></description><guid isPermaLink="false">5c9a36df-c260-4d16-87b1-9b7e3107f7b8</guid><pubDate>Thu,  4 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Announcing the Tokio Doc Push (we need you!)</title><link>https://tokio.rs/blog/2018-10-doc-blitz/</link><description><![CDATA[In the past, there has been reoccurring feedback that Tokio is hard to understand. I believe a lack of good documentation plays a significant part. Itâ€™s time to fix this problem.

And because Tokio is open source, it is on us (the community) to make this happen! ðŸ‘]]></description><guid isPermaLink="false">cbc812fb-b5ff-44cc-ae96-f4a5ae44e7dd</guid><pubDate>Thu,  4 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>An EFI App a bit rusty</title><link>https://medium.com/@gil0mendes/an-efi-app-a-bit-rusty-82c36b745f49</link><description><![CDATA[After two tweets that I made last week, playing around with UEFI and Rust, some people asked to publish a blog post explaining how to create a UEFI application fully written in Rust and demonstrate all the testing environment.]]></description><guid isPermaLink="false">9128e298-33fe-4f13-a9c7-7ff2361ee2da</guid><pubDate>Sun, 30 Sep 2018 21:56:12 +0000</pubDate><dc:creator>Gil Mendes</dc:creator></item><item><title>Writing Rust NIFs for your Elixir code with the Rustler package</title><link>https://medium.com/@jacob.lerche/writing-rust-nifs-for-your-elixir-code-with-the-rustler-package-d884a7c0dbe3</link><description><![CDATA[There will be times where code will run slow and Erlang/Elixir optimizations will only go so far. BEAM has several ways to interface with foreign code, the fastest way being with a Native Implemented Function (NIF) whose API expects them to be written in C. But speaking frankly, the last time I worked with C involved a lengthy debugging session that boiled down to the lack of type safety, so Iâ€™d rather not have to repeat that experience. Itâ€™s for this reason that Rust is such a compelling language.]]></description><guid isPermaLink="false">11786513-db52-4fdb-ac03-e4a854b36f2b</guid><pubDate>Fri, 28 Sep 2018 01:54:27 +0000</pubDate><dc:creator>Jacob Lerche</dc:creator></item><item><title>Announcing Rust 1.29.1</title><link>https://blog.rust-lang.org/2018/09/25/Rust-1.29.1.html</link><description><![CDATA[A security vulnerability was found in the standard library where if a large number was passed to str::repeat it could cause a buffer overflow after an integer overflow. If you do not call the str::repeat function you are not affected. This has been addressed by unconditionally panicking in str::repeat on integer overflow.]]></description><guid isPermaLink="false">adea520f-a6b7-43f5-b705-62aefc4c00e6</guid><pubDate>Tue, 25 Sep 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>rust-on-mobile: Example of creating and running a basic &quot;Hello World&quot; application on iOS</title><link>https://github.com/mtak-/rust-on-mobile/blob/master/examples/ios/example01.md</link><description><![CDATA[This repo is a place where examples can be added of iOS/android projects written entirely/mostly in rust.]]></description><guid isPermaLink="false">0b2520e8-b69d-4edb-91b1-3558494fd0cd</guid><pubDate>Mon, 24 Sep 2018 06:09:32 +0000</pubDate><dc:creator>mtak-</dc:creator></item><item><title>Office Hours #1: Cyclic services</title><link>http://smallcultfollowing.com/babysteps/blog/2018/09/24/office-hours-1-cyclic-services/</link><description><![CDATA[This is a report on the second â€œoffice hoursâ€, in which we discussed how to setup a series of services or actors that communicate with one another. This is a classic kind of problem in Rust: how to deal with cyclic data. Usually, the answer is that the cycle is not necessary (as in this case).]]></description><guid isPermaLink="false">0ec2fec4-ed74-4377-b1f5-1e6a5eec6025</guid><pubDate>Mon, 24 Sep 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Office Hours #0: Debugging with GDB</title><link>http://smallcultfollowing.com/babysteps/blog/2018/09/21/office-hours-0-debugging-with-gdb/</link><description><![CDATA[This blog post is just going to be a quick summary of the basic workflow of using Rust with gdb on the command line. Iâ€™m assuming you are using Linux here, since I think otherwise you would prefer a different debugger. There are probably also nifty graphical tools you can use and maybe even IDE integrations, Iâ€™m not sure.]]></description><guid isPermaLink="false">564060f8-e187-4947-80ca-867ed3762d1b</guid><pubDate>Fri, 21 Sep 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>A Rust FFI adventure in unsafety</title><link>https://travisf.net/capstone-rs-unsafety-adventure</link><description><![CDATA[This blog post covers my adventure in fixing a bug in the Rust bindings for the Capstone C library, a disassembly library that supports several CPU architectures. The capstone-rs crate attempts to provide a Rusty, object-oriented interface. You do not necessarily need previous experience in C code or foreign function (FFI) bindings to understand this blog post. I will cover some of the steps I used to debug this problem. Hopefully, readers can learn from my mistakes.]]></description><guid isPermaLink="false">a2d3880c-1803-4f4d-8345-b46f2d056985</guid><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Travis Finkenauer</dc:creator></item><item><title>Trying to tackle the orphans problem</title><link>https://phaazon.net/blog/orphans-problem</link><description><![CDATA[In this blog entry, I want to explore a specific problem of orphans and how I decided to solve it in a crate of mine. The problem is the following: Given a crate that has a given responsibility, how can someone add an implementation of a given trait without having to use a type wrapper or augment the crateâ€™s scope?]]></description><guid isPermaLink="false">0e8e1d2a-729c-41b0-953f-e14de11b8c59</guid><pubDate>Thu, 20 Sep 2018 12:30:00 +0000</pubDate><dc:creator>Dimitri Sabadie</dc:creator></item><item><title>How we integrate Rust with C#</title><link>https://blog.getseq.net/rust-at-datalust-how-we-integrate-rust-with-csharp/</link><description><![CDATA[Seq is a log server that's built using a few programming languages; we have a storage engine called Flare written in Rust, and a server application written in C#. Our language stack is something I've talked about previously.

Between Rust and C# we have a foreign function interface (FFI) that lets us call out to Rust code from within the .NET runtime. In this post I'd like to explore our approach to FFI between Seq and its storage engine using the API for reading log events as a reference.]]></description><guid isPermaLink="false">63b188d7-d82f-425d-9d07-a17d7fdc43f8</guid><pubDate>Tue, 18 Sep 2018 23:15:06 +0000</pubDate><dc:creator>Ashley Mannix</dc:creator></item><item><title>Falling in love with Rust</title><link>http://dtrace.org/blogs/bmc/2018/09/18/falling-in-love-with-rust/</link><description><![CDATA[We are living in a Golden Age of software, one that will produce artifacts that will endure for generations. Of course, it can be hard to hold such heady thoughts when we seem to be up to our armpits in vendored flotsam, flooded by sloppy abstractions hastily implemented. Among current languages, only Rust seems to share this aspiration for permanence, with a perspective that is decidedly larger than itself.]]></description><guid isPermaLink="false">7f5b5694-9cda-4692-8cbe-42458122faff</guid><pubDate>Tue, 18 Sep 2018 22:31:51 +0000</pubDate><dc:creator>Bryan Cantrill</dc:creator></item><item><title>Lockout, Part 2: And nary a function to be found</title><link>https://exphp.github.io/2018/09/18/lockout-part-2.html</link><description><![CDATA[This is part of a blog series on working towards an intuitive mental model for lifetimes in Rust. When I tried to sit myself down and really, really write down an in-depth exampleâ€¦ I realized that there was no two ways about it. Before you can learn to appreciate why lifetimes exist, you must learn what life would be like without them. And in order to do that, wellâ€¦]]></description><guid isPermaLink="false">b78327e0-5dc5-4187-be6b-9e06204b4631</guid><pubDate>Tue, 18 Sep 2018 19:00:00 +0000</pubDate><dc:creator>Michael Lamparski</dc:creator></item><item><title>Lockout, Part 1: Everything you know about lifetimes is wrong</title><link>https://exphp.github.io/2018/09/17/lockout-part-1.html</link><description><![CDATA[This is part of a blog series on a new way to look at lifetimes in Rust's type system. I hope to cover some advanced aspects of lifetimes that are seldom discussed in the open, and my goal is ultimately to help convey new intuitions about how to use them correctly.]]></description><guid isPermaLink="false">6c1f472d-337d-48c0-96d3-807afe8e58e3</guid><pubDate>Mon, 17 Sep 2018 01:00:00 +0000</pubDate><dc:creator>Michael Lamparski</dc:creator></item><item><title>Ownership Explained with Python</title><link>https://paulkernfeld.com/2018/09/16/ownership-explained-with-python.html</link><description><![CDATA[Itâ€™s not immediately obvious that calling min(squares) modifies squares. If squares were a list or even a range, we would be able to call min and max on it with no problem. It would be nice if the language prevented us from trying to use something twice that can only be used once. Almost all modern languages, both statically and dynamically typed, will fail at runtime in these situations.]]></description><guid isPermaLink="false">0f587c1a-da0e-46d2-bee3-3a3cc6fc5352</guid><pubDate>Sun, 16 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Paul Kernfeld</dc:creator></item><item><title>Function composition in Rust using a custom smart pointer</title><link>https://bsoptei.github.io/</link><description><![CDATA[Still drunk with the power of function composition, I started to play around with the technique in Rust, a language I've been experimenting with. Rust is a low-level language with a strict compiler that saves you from doing dangerous things. Furthermore, Rust is a functional language. It has several concepts and features inspired by Haskell (read more) and Scala for example. The design of Rust makes it highly expressive and attractive.]]></description><guid isPermaLink="false">b5f32e7e-843c-40cf-8c6c-126bc74e6c4e</guid><pubDate>Sat, 15 Sep 2018 00:00:00 +0000</pubDate><dc:creator>BalÃ¡zs SÃ¶ptei</dc:creator></item><item><title>You can&apos;t &quot;turn off the borrow checker&quot; in Rust</title><link>https://words.steveklabnik.com/you-can-t-turn-off-the-borrow-checker-in-rust</link><description><![CDATA[Every once in a while, someone will talk about unsafe in Rust, and how it â€œturns off the borrow checker.â€ I think this framing leads to misconceptions about unsafe and how it interacts with safe code. Hereâ€™s some code that causes a borrow checker... | Steve Klabnik | â€œThe most violent element in society is ignorance.â€ - Emma Goldman]]></description><guid isPermaLink="false">a64aef93-521d-414e-ae6e-853f147b1180</guid><pubDate>Fri, 14 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Steve Klabnik</dc:creator></item><item><title>Rust Associated Type</title><link>https://medium.com/codechain/rust-associated-type-2281dbf98229</link><description><![CDATA[Associated Types in Rust are similar to Generic Types; however, Associated Types limit the types of things a user can do, which consequently facilitates code management. Among the Generic Types of traits, types that depend on the type of trait implementation can be expressed by using the Associated Type syntax. By comparing the Associated and Generic Types, you can get a better understanding of Associated Types.]]></description><guid isPermaLink="false">001f1e0d-3927-4e39-800e-68324a02887a</guid><pubDate>Thu, 13 Sep 2018 06:50:57 +0000</pubDate><dc:creator>Seung Woo Kim</dc:creator></item><item><title>Announcing Rust 1.29</title><link>https://blog.rust-lang.org/2018/09/13/Rust-1.29.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.29.0. The two most significant things in this release arenâ€™t even language features: theyâ€™re new abilities that Cargo has grown, and theyâ€™re both about lints: cargo fix can automatically fix your code that has warnings. cargo clippy is a bunch of lints to catch common mistakes and improve your Rust code.]]></description><guid isPermaLink="false">dc9c068f-0a7f-4a31-aec2-f30b51066b89</guid><pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Parallelizing PNG, part 8: Rust macros for constant specialization</title><link>https://brionv.com/log/2018/09/12/parallelizing-png-part-8-rust-macros-for-constant-specialization/</link><description><![CDATA[In my last posts I covered profiling and some tips for optimizing inner loops in Rust code while working on a multithreaded PNG encoder. Rustâ€™s macro system is another powerful tool for simplifying your code, and sometimes awesomeizing your performanceâ€¦]]></description><guid isPermaLink="false">bec949a2-4c38-4646-ae0b-1d8638c506a6</guid><pubDate>Wed, 12 Sep 2018 15:26:54 +0000</pubDate><dc:creator>Brion Vibber</dc:creator></item><item><title>How we organize a complex Rust codebase</title><link>https://blog.getseq.net/rust-at-datalust-how-we-organize-a-complex-rust-codebase/</link><description><![CDATA[At Datalust weâ€™ve been busy building Flare: a storage engine for our log server, Seq, written in the Rust programming language. This post is a point-in-time look at how we've approached building this fairly complex piece of software in Rust in 2018. Iâ€™d like to share a few]]></description><guid isPermaLink="false">6313ebb2-076c-449b-8fb1-372c9b025168</guid><pubDate>Tue, 11 Sep 2018 22:26:05 +0000</pubDate><dc:creator>Ashley Mannix</dc:creator></item><item><title>From Rust to beyond: The C galaxy</title><link>https://mnt.io/2018/09/11/from-rust-to-beyond-the-c-galaxy/</link><description><![CDATA[This blog post is part of a series explaining how to send Rust beyond earth, into many different galaxies. The galaxy we will explore today is the C galaxy. This post will explain what C is (shortly), how to compile any Rust program in C in theory, and how to do that practically with our Rust parser from the Rust side and the C side. We will also see how to test such a binding.]]></description><guid isPermaLink="false">35458bae-bc62-40d7-ac3d-2dcd8ab1f469</guid><pubDate>Tue, 11 Sep 2018 07:49:07 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Unit Type Params</title><link>https://leshow.github.io/post/unit_type_pattern/</link><description><![CDATA[I always enjoy reading blogs about patterns or tricks people have picked up writing Rust. Iâ€™ve seen this a few times but not read about it anywhere.

Iâ€™ve been doing class assignments from Operating Systems cs140e. I highly recommend this class if you know a bit of Rust and would like to try writing some lower level code. The class involves building bits of an OS for the raspberry pi.]]></description><guid isPermaLink="false">f712f29b-efed-4c75-a4a0-8523fa0b6d52</guid><pubDate>Mon, 10 Sep 2018 12:28:03 -0400</pubDate><dc:creator>Evan Cameron</dc:creator></item><item><title>The Common Rust Traits</title><link>https://stevedonovan.github.io/rustifications/2018/09/08/common-rust-traits.html</link><description><![CDATA[In Rust, data types - primitives, structs, enums and any other â€˜aggregateâ€™ types like tuples and arrays - are dumb. They may have methods but that is just a convenience (they are just functions). Types have no relationship with each other.

Traits are the abstract mechanism for adding functionality to types and establishing relationships between them.]]></description><guid isPermaLink="false">83d6c5ed-e847-4807-8c6c-40e97f66b9d5</guid><pubDate>Sat,  8 Sep 2018 00:00:00 +0200</pubDate><dc:creator>Steve Donovan</dc:creator></item><item><title>Rust pattern: Iterating an over a Rc&lt;Vec&lt;T&gt;&gt;</title><link>http://smallcultfollowing.com/babysteps/blog/2018/09/02/rust-pattern-iterating-an-over-a-rc-vec-t/</link><description><![CDATA[This post examines a particular, seemingly simple problem: given ownership of a Rc<Vec<u32>>, can we write a function that returns an impl Iterator<Item = u32>? It turns out that this is a bit harder than it might at first appear â€“ and, as weâ€™ll see, for good reason. Iâ€™ll dig into whatâ€™s going on, how you can fix it, and how we might extend the language in the future to try and get past this challenge.]]></description><guid isPermaLink="false">7610bbc1-58a1-413b-a4a3-dad7877ca1bd</guid><pubDate>Sun,  2 Sep 2018 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Rust Factory Without Box (Trait Object)</title><link>https://singpolyma.net/2018/09/rust-factory-without-box-trait-object/</link><description><![CDATA[Iâ€™ve been playing around a lot with Rust recently and itâ€™s quickly becoming my second-favourite programming language. One of the things Iâ€™ve been playing with is some Object Oriented design concepts as they might apply.]]></description><guid isPermaLink="false">c3d8acef-fe90-4a0c-9fc5-9061f0694581</guid><pubDate>Sat,  1 Sep 2018 17:52:00 +0000</pubDate><dc:creator>Stephen Paul Weber</dc:creator></item><item><title>Using RwLock and CondVars in Rust</title><link>https://tutorialedge.net/rust/using-rwlocks-and-condvars-rust/</link><description><![CDATA[Read many, write exclusive locks â€“ RwLock Consider a situation where you have a resource that must be manipulated only a single thread at a time, but is safe to be queried by manyâ€”that is, you have many readers and only one writer.

While you could protect this resource with a mutex, the trouble is that the mutex makes no distinction between its lockers; every thread will be forced to wait, no matter what their intentions.]]></description><guid isPermaLink="false">44aebda5-9403-432d-b94e-d81449a1edbf</guid><pubDate>Sat,  1 Sep 2018 15:09:49 +0100</pubDate><dc:creator>Brian L. Troutwine</dc:creator></item><item><title>Primitives in Rust are Weird (and Cool)</title><link>https://speice.io/2018/09/primitives-in-rust-are-weird.html</link><description><![CDATA[I wrote a really small Rust program a while back because I was curious. I was 100% convinced itcouldnâ€™t possibly run. And to my complete befuddlement, it compiled, ran, and produced a completely sensible output.]]></description><guid isPermaLink="false">deb45294-d269-481c-a767-f4fd7c00cf0f</guid><pubDate>Sat,  1 Sep 2018 00:00:00 -0400</pubDate><dc:creator>Bradlee Speice</dc:creator></item><item><title>Rust: Fail Fast and Loudly</title><link>https://blog.shivoa.net/2018/08/rust-fail-fast-and-loudly.html</link><description><![CDATA[To panic or to return a Result: why libraries in Rust must weigh their options rather than accepting a never-panic mandate.]]></description><guid isPermaLink="false">271f4485-7452-487c-a1ee-4043dac3c60e</guid><pubDate>Fri, 31 Aug 2018 02:58:00 +0100</pubDate><dc:creator>Shivoa Birch</dc:creator></item><item><title>Introduction to asynchronous programming in Rust</title><link>https://github.com/nrc/apr-intro</link><description><![CDATA[An alternate introdcution to the APR book. This book aims to be a comprehensive, up-to-date guide on the async story in Rust, appropriate for beginners and old hands alike. We assume you already know Rust fairly well, including having done some multi-threaded programming. If any Rust terms in this guide are unfamiliar, you should check out the Rust book.]]></description><guid isPermaLink="false">09fcee2d-1825-46a0-952f-7035c41b2b32</guid><pubDate>Thu, 30 Aug 2018 10:12:00 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Debugging an Rc&lt;T&gt; reference leak in Rust</title><link>https://people.gnome.org/~federico/blog/debugging-reference-leak-in-rust.html</link><description><![CDATA[The bug that caused two brown-paper-bag releases in librsvg â€” because it was leaking all the SVG nodes â€” has been interesting. Memory leaks in Rust? Isn't it supposed to prevent that? Well, yeah, but the leaks were caused by the C side of things, and by unsafe code in Rust, which does not prevent leaks.]]></description><guid isPermaLink="false">09bd9199-be43-439f-ad36-d22904a73fb1</guid><pubDate>Wed, 29 Aug 2018 16:47:13 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Feasible functors in Rust</title><link>https://varkor.github.io/blog/2018/08/28/feasible-functors-in-rust.html</link><description><![CDATA[withoutboats, one of the Rust language design team, recently posted a thread on the infeasibility of monads as a useful abstraction technique in Rust, as a response to the persistence of some (usually from outside the Rust community) in claiming that â€œRust is doing things incorrectlyâ€ by developing specific solutions to problems, rather than using a general category theoretic framework for everything. The points demonstrate real difficulties with attempting to use a general framework for these problems and to me serves perfectly as a â€œthe ballâ€™s in your court nowâ€ to anyone claiming Rust is ignoring theory and coming up with unnecessary solutions to solved problems: if you think Rust could use monadic abstractions, you have to be able to address these counterarguments.]]></description><guid isPermaLink="false">5d84ad61-702d-400b-ac40-6325904e031d</guid><pubDate>Tue, 28 Aug 2018 12:20:10 +0000</pubDate><dc:creator>varkor</dc:creator></item><item><title>Serde Deserialize This or That into u64</title><link>https://noyez.gitlab.io/post/2018-08-28-serilize-this-or-that-into-u64/</link><description><![CDATA[Recently I ran into a bug in my code; hey, it happens. The bug was that I had a struct which could serialize into json, but could not deserialize from its own json. The struct holds a value for a mac address, which is 48-bit integer (that i store in a u64), but it is serialized using the network interface name. For example on my mac, i have a network interface named en1 with the mac address of 20:c9:d0:b0:a4:71.]]></description><guid isPermaLink="false">a2e99609-1298-4f79-b2f3-0cce908a701f</guid><pubDate>Tue, 28 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Noyez</dc:creator></item><item><title>Thoughts on Rust from a PHP developer!</title><link>https://www.smashing-bugs.tk/software-development/rust/2018/08/27/on-rust-from-a-php-developer.html</link><description><![CDATA[I first starting learning Rust about 6 months ago, I was looking for a new language to learn when I came across it. At first I thought Rust was only meant to be a low level, systems programming language, but the more I learned, the more I realised the potential it has for high level programming and web applications. Also, along the way I learned many ways in which Rust prevents many of the typical bugs often found in applications written in other programming languages.]]></description><guid isPermaLink="false">90241d58-f6a1-4df5-9c3f-15c94998c6df</guid><pubDate>Mon, 27 Aug 2018 14:41:11 +0000</pubDate><dc:creator>Diego Cabrejas</dc:creator></item><item><title>Experimental async / await support for Tokio</title><link>https://tokio.rs/blog/2018-08-async-await/</link><description><![CDATA[In case you havenâ€™t heard, async / await is a big new feature that is being worked on for Rust. It aims to make asynchronous programming easy (well, at least a little bit easier than it is today). The work has been on going for a while and is already usable today on the Rust nightly channel.

Iâ€™m happy to announce that Tokio now has experimental async / await support! Letâ€™s dig in a bit.]]></description><guid isPermaLink="false">7a251e22-3430-4226-85e0-a94e73b3e785</guid><pubDate>Mon, 27 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>Programming Servo: The Debug Way</title><link>https://medium.com/coding-neutrino-blog/programming-servo-the-debug-way-5db01f09b7f4</link><description><![CDATA[Servo is a huge project. I have counted the lines of code for you. There are almost a hundred thousand lines of code in the Servo project. To develop such a big project, knowing how to debug in a right way is very important, since you would like to find the bottleneck in a fast and efficient way.

In this article, I will teach you some tips to use GDB developing and debugging your Rust code in the Servo project.]]></description><guid isPermaLink="false">fcadb47a-753e-44c9-830e-0e2cda34b365</guid><pubDate>Sun, 26 Aug 2018 14:55:42 +0000</pubDate><dc:creator>Liu An Chi</dc:creator></item><item><title>Easy proc_macro_derive&apos;s with synstructure</title><link>https://llogiq.github.io/2018/08/25/synstruct.html</link><description><![CDATA[Recently, I found myself in the market for some quickcheck. However, there were custom types, which had no Arbitrary implementation. Wondering if someone had already written a procedural macro to derive it, I found panicbitâ€™s quickcheck_derive crate. However, to my dismay, it was severely limited in that it could only derive Arbitrary for structs.]]></description><guid isPermaLink="false">13973f76-d793-4df8-9529-bca5f5f84428</guid><pubDate>Sat, 25 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Calling C# natively from Rust</title><link>https://medium.com/@chyyran/calling-c-natively-from-rust-1f92c506289d</link><description><![CDATA[A couple of months ago, I created my first Rust program; a music manager called seiri. seiri is actually a rewrite of a previous, much buggier program that I used to organize my music that was written in C#. The tag library of choice was of course, taglib-sharp, a port of the C++ library TagLib to the .NET ecosystem. Since Rust unfortunately doesnâ€™t have its own native port of TagLib, and any C bindings available didnâ€™t expose the picture API, the most obvious thing to do was to use the C# library with Rust somehow, right?]]></description><guid isPermaLink="false">4a0db6c9-2c0d-4455-b353-474e4f59c87a</guid><pubDate>Fri, 24 Aug 2018 01:07:46 +0000</pubDate><dc:creator>Ronny Chan</dc:creator></item><item><title>Why an Interior Mutable abstraction is needed in the Rust core library</title><link>http://blog.kjeka.com/rust/programming/tmcl/2018/08/24/interior-mut/</link><description><![CDATA[Interior mutabiliby is a concept known to anyone who have programmed in Rust for a while. And even though Rust's stdlib have several wrapper-types allowing interior mutability there is no trait unifying these types. Motivated by writing libraries suitable for no_std development that are fully safe to use with threads, this blog post will attempt to fill in one gap in the Rust stdlib.]]></description><guid isPermaLink="false">b0c75f8a-24c3-449e-bc2d-97638d193d3e</guid><pubDate>Fri, 24 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Kjetil Kjeka</dc:creator></item><item><title>Oxidizing sourmash: Python and FFI</title><link>https://blog.luizirber.org/2018/08/23/sourmash-rust/</link><description><![CDATA[Last December I decided to give Rust a run: I spent some time porting the C++ bits of sourmash to Rust. The main advantage here is that it's a problem I know well, so I know what the code is supposed to do and can focus on figuring out syntax and the mental model for the language. I started digging into the symbolic codebase and understanding what they did, and tried to mirror or improve it for my use cases.]]></description><guid isPermaLink="false">4857abad-3757-40b8-a899-93442e4982e9</guid><pubDate>Thu, 23 Aug 2018 17:00:00 -0300</pubDate><dc:creator>Luiz Irber</dc:creator></item><item><title>More on the RLS and a 1.0 release</title><link>https://www.ncameron.org/blog/more-on-the-rls-and-a-1-0-release/</link><description><![CDATA[In my last post, I announced a release candidate for the RLS 1.0. There has been a lot of feedback (and quite a lot of that was negative on the general idea), so I wanted to expand on what 1.0 means for the RLS, and why I think it is ready. I also want to share some of my vision for the future of the RLS, in particular changes that might warrant a major version release.]]></description><guid isPermaLink="false">49ccf817-c69f-4467-9391-9fccc619e928</guid><pubDate>Thu, 23 Aug 2018 09:10:11 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>To Make or Not to Make â€“ Using cargo make for Rookeries v0.12.0</title><link>https://dorianpula.ca/2018/08/22/to-make-or-not-to-make-using-cargo-make-for-rookeries-v0-12-0/</link><description><![CDATA[I recently continued with my exploration of Rust through Rookeries (my attempt at a static site generator/backing API server). This time I worked on switching over from using invoke and GNU make to using a nice build system called cargo-make. Overall I am quite happy with the result.]]></description><guid isPermaLink="false">0c187e7b-4693-4f2c-b330-ce51a314c6eb</guid><pubDate>Wed, 22 Aug 2018 23:00:27 +0000</pubDate><dc:creator>Dorian Pula</dc:creator></item><item><title>Live Refreshing Cargo Docs</title><link>https://benjamincongdon.me/blog/2018/08/22/Live-Refreshing-Cargo-Docs/</link><description><![CDATA[rustdoc is a great tool, but as of now there isnâ€™t an official way to have its generated docs refresh as you make edits. Running cargo doc with the --open argument will open the generated docs in browser window. If you make changes to your source code, youâ€™ll need to re-run cargo doc to have the changes reflected in your browser. By chaining together a few other Rust tools, we can pretty easily get the functionality of live-reloading docs.]]></description><guid isPermaLink="false">1332a957-6689-4053-884b-ec31ca39f505</guid><pubDate>Wed, 22 Aug 2018 21:03:28 +0000</pubDate><dc:creator>Benjamin Congdon</dc:creator></item><item><title>Two Kinds of Invariants: Safety and Validity</title><link>https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html</link><description><![CDATA[When talking about the Rust type system in the context of unsafe code, the discussion often revolves around invariants: Properties that must always hold, because the language generally assumes that they do. In fact, an important part of the mission of the Unsafe Code Guidelines strike force is to deepen our understanding of what these invariants are.

However, in my view, there is also more than one invariant, matching the fact that there are (at least) two distinct parties relying on these invariants: The compiler, and (authors of) safely usable code. This came up often enough in recent discussions that I think it is worth writing it down properly once, so I can just link here in the future.]]></description><guid isPermaLink="false">7c167657-c185-479c-afc3-93b0187b8359</guid><pubDate>Wed, 22 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Another look at the pinning API</title><link>https://boats.gitlab.io/blog/post/rethinking-pin/</link><description><![CDATA[One thing has always nagged about the API we have right now though: the proliferation of different reference types that it implies. Today, the pin feature adds the PinMut and PinBox types, but in theory there ought to be a â€œpinnedâ€ version of every pointer in the standard library: PinRc and PinArc and so on. This is a very unfortunate consequence, but so far we have not found a good way to make pinning work compositionally - to have a single adapter that could be combined with any pointer.

Last night, a bit of inspiration struck me, and I realized that it is possible to make a compositional Pin type. This isnâ€™t a fundamental change to the pinning model, just an API refactoring, but Iâ€™ve put a blocking concern on the proposal to stabilize Pin so that we can consider this possibility.]]></description><guid isPermaLink="false">edfe7063-b893-42db-aa08-61adcaddf56b</guid><pubDate>Wed, 22 Aug 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>[blog series] From Rust to beyond: Prelude</title><link>https://mnt.io/2018/08/21/from-rust-to-beyond-prelude/</link><description><![CDATA[This series of posts is about those bindings, and explains how to send Rust beyond earth, into many different galaxies. Rust will land in: The WebAssembly galaxy, The ASM.js galaxy, The C galaxy, The PHP galaxy, and The NodeJS galaxy. The ship is currently flying into the Java galaxy, this series may continue if the ship does not crash or has enough resources to survive!]]></description><guid isPermaLink="false">e3b3767b-4228-4432-a525-15d8cbc99f77</guid><pubDate>Tue, 21 Aug 2018 08:46:20 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Safe Partial Initialization In Rust</title><link>https://scottjmaddox.github.io/Safe-partial-initialization-in-Rust/</link><description><![CDATA[Say we have a struct, Foo, with multiple fields that we would like to partially initialize without resorting to using unsafe. We could write a procedural macro called PartialInit, for example, which would be invoked using derive.]]></description><guid isPermaLink="false">29c7c773-0be7-4694-a11d-41717eac218c</guid><pubDate>Sun, 19 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Scott J Maddox</dc:creator></item><item><title>A Beginnerâ€™s Guide to Rust Macros âœ¨</title><link>https://medium.com/@phoomparin/a-beginners-guide-to-rust-macros-5c75594498f1</link><description><![CDATA[Demystifying one of Rustâ€™s most powerful feature.]]></description><guid isPermaLink="false">9f3fb115-f832-421a-bf28-18148cc3bde0</guid><pubDate>Sat, 18 Aug 2018 18:35:50 +0000</pubDate><dc:creator>Phoomparin Mano</dc:creator></item><item><title>Why Rust Closures are (Somewhat) Hard</title><link>http://stevedonovan.github.io/rustifications/2018/08/18/rust-closures-are-hard.html</link><description><![CDATA[Rust closures are harder for three main reasons: The first is that it is both statically and strongly typed, so weâ€™ll need to explicitly annotate these function types. Second, Lua functions are dynamically allocated (â€˜boxedâ€™.) Rust does not allocate silently because it prefers to be explicit and is a system language designed for maximally efficient code. Third, closures share references with their environment. In the case of Lua, the garbage collector ensures that these references will live long enough. With Rust, the borrow checker needs to be able to track the lifetimes of these references.]]></description><guid isPermaLink="false">e3bf830e-e1ed-462b-9a6a-edac9ba2d699</guid><pubDate>Sat, 18 Aug 2018 00:00:00 +0200</pubDate><dc:creator>Steve Donovan</dc:creator></item><item><title>Writing Integration Tests in Rust</title><link>https://dorianpula.ca/2018/08/15/writing-integration-tests-in-rust-releasing-rookeries-v0-11-0/</link><description><![CDATA[As part of my overall change over in Rookeries, from Python to Rust, I rewrote a suite of integration tests for the server API. To celebrate my successful transition, I released version 0.11.0 of Rookeries, whose tests use pure Rust now!]]></description><guid isPermaLink="false">26f81256-2d48-4d6e-b305-7ed0d88c216b</guid><pubDate>Wed, 15 Aug 2018 23:00:26 +0000</pubDate><dc:creator>Dorian Pula</dc:creator></item><item><title>Diagnosing A Weak Memory Ordering Bug</title><link>https://robert.ocallahan.org/2018/08/for-first-time-in-my-life-i-tracked.html</link><description><![CDATA[For the first time in my life I tracked a real bug's root cause to incorrect usage of weak memory orderings. Until now weak memory bugs were something I knew about but had subconciously felt were only relevant to wizards coding on big iron, partly because until recently I've spent most of my career using desktop x86 machines.]]></description><guid isPermaLink="false">4b9c619b-6d09-43a9-82bb-86887dbd3a53</guid><pubDate>Tue, 14 Aug 2018 15:18:00 +1200</pubDate><dc:creator>Robert O&apos;Callahan</dc:creator></item><item><title>A Short Serde Deserialize example</title><link>https://noyez.gitlab.io/post/2018-08-14-short-serde-deserialize-exapmle/</link><description><![CDATA[In my previous post, I described taking a simple enum and creating a custom type in diesel. This post will take that same enum and implement deserialize. I often get tripped up by the mechanics of deserializing so this simple enum makes for a good example. Again, this is to benefit anyone looking for more examples of Serdeâ€™s Deserialize as well as for myself, so I can remember next time I need to do this.]]></description><guid isPermaLink="false">45c51d1f-97ea-41ad-a1fe-3aab3c51d9ee</guid><pubDate>Tue, 14 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Noyez</dc:creator></item><item><title>Rust: _(underscore) Does Not Bind</title><link>https://medium.com/codechain/rust-underscore-does-not-bind-fec6a18115a8</link><description><![CDATA[Rust is a language that utilizes the RAII idiom, resulting in different code depending on when the object is destroyed.]]></description><guid isPermaLink="false">523b014f-5ec9-4569-b31f-44720fb3bbc4</guid><pubDate>Mon, 13 Aug 2018 07:13:58 +0000</pubDate><dc:creator>Seung Woo Kim</dc:creator></item><item><title>Never patterns, exhaustive matching, and uninhabited types (oh my!)</title><link>http://smallcultfollowing.com/babysteps/blog/2018/08/13/never-patterns-exhaustive-matching-and-uninhabited-types-oh-my/</link><description><![CDATA[One of the long-standing issues that weâ€™ve been wrestling with in Rust is how to integrate the concept of an â€œuninhabited typeâ€ â€“ that is, a type which has no values at all. Uninhabited types are useful to represent the â€œresultâ€ of some computation you know will never execute â€“ for example, if you have to define an error type for some computation, but this particular computation can never fail, you might use an uninhabited type.]]></description><guid isPermaLink="false">8a47c51e-2de1-47c2-8c3d-3f2d84ae13cb</guid><pubDate>Mon, 13 Aug 2018 00:00:00 -0700</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>I learnt Rust: less than a memoir</title><link>http://blog.kekoariggin.com/coding/i-learnt-rust-less-than-a-memoir/</link><description><![CDATA[Over the past two months, I worked on a feature for Project Fluent. My feature was needed in the Rust implementation of Fluent and was published as a Rust crate, making my code available to the entire Rust community. Completing this project brought me a great sense of satisfaction, and having contributed a fundamental internationalization crate to the Rust ecosystem is possibly the biggest milestone in my career as a developer.]]></description><guid isPermaLink="false">91714b35-a84b-4ac0-a0ed-57e2bdedc9dc</guid><pubDate>Mon, 13 Aug 2018 04:23:32 +0000</pubDate><dc:creator>Kekoa Riggin</dc:creator></item><item><title>A FizzBuzzy Tour of Traits in Rust</title><link>https://www.joshmcguigan.com/blog/fizzbuzz-tour-of-traits-rust/</link><description><![CDATA[Traits are a core part of the Rust programming language, and understanding traits, particularly those which are part of the standard library, is necessary in order to write idiomatic Rust. In this post Iâ€™ll write several FizzBuzz implementations, each demonstrating the use of a different trait from the Rust standard library.]]></description><guid isPermaLink="false">a47db977-bb96-4ecf-9203-8c64b438062d</guid><pubDate>Mon, 13 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Refactoring with Rust macros</title><link>https://philbooth.me/blog/refactoring-with-rust-macros</link><description><![CDATA[Refactoring boilerplate code is always easy in dynamically-typed languages, but sometimes takes a bit more effort when constrained by strong typing. This is something I was puzzling over recently, when the penny dropped for me about how Rust's macros can be used to bridge the gap.]]></description><guid isPermaLink="false">ff118dd1-1fe8-4cde-a359-a00325002ebd</guid><pubDate>Sun, 12 Aug 2018 12:54:12 +0000</pubDate><dc:creator>Phil Booth</dc:creator></item><item><title>Object Models And Identities</title><link>https://vorner.github.io/2018/08/12/Object-models-and-identities.html</link><description><![CDATA[In many things, Rust is very much like C++. Itâ€™s memory management strategy is mostly the same, threading models are copied vanilla, both compile to native code and do about the same optimisations at that time, and traits and templates have a lot in common too. Both tend to be rather feature-rich languages with quite a lot to learn. While Rust is definitely better teacher (Iâ€™m looking at you, C++ error message!) and has many more â€žsafety coversâ€œ over the dangerous moving parts inside the engine, the design of the engine is more of an evolution from C++ than a completely new thing.

But Iâ€™ve noticed one rather subtle difference in the philosophy of the languages Iâ€™d like to describe here. To make it somewhat more complete, Iâ€™ll also throw what some other languages do in this area in.]]></description><guid isPermaLink="false">e19ac48b-7995-4b64-82d8-64d149067b54</guid><pubDate>Sun, 12 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>How to alleviate the pain of Rust compile times</title><link>https://vfoley.xyz/rust-compile-speed-tips/</link><description><![CDATA[A few days ago, I wrote about two Rust pain points when using Rust at work. One of these points were the long compile times. In this post, I want to share a few tips that can help alleviate that pain.]]></description><guid isPermaLink="false">6f49ae97-11d3-4e1f-ab95-0307bf406aa5</guid><pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Vincent Foley</dc:creator></item><item><title>GSoC wrap-up - Splitting Servo&apos;s script crate</title><link>https://blog.servo.org/2018/08/09/gsoc-generic-servo/</link><description><![CDATA[I am Peter Hrvola (retep007) Twitter Github. During my Google Summer of Code (GSoC) project, I have been working on investigating the monolithic nature of Servoâ€™s script crate and prototyping separation to smaller crates. My goal was to improve the use of resources during compilation. Current debug build consumes over 5GB of memory and takes 347s.]]></description><guid isPermaLink="false">e141f480-7f0d-4b15-82b6-44d0f807f09c</guid><pubDate>Thu,  9 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Peter Hrvola</dc:creator></item><item><title>Literate Programming in Rust</title><link>https://damien.codes/posts/literate-rust/</link><description><![CDATA[In which we explore how cargo and rustdoc make it possible to write documentation and unit tests at once, resulting in code that is explained and tested from the POV of a public API.]]></description><guid isPermaLink="false">9a82c540-b8ab-4635-a68b-82754b5fe8a1</guid><pubDate>Thu,  9 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Damien</dc:creator></item><item><title>Proposal: Rust Custom Test Frameworks</title><link>https://blog.jrenner.net/rust/testing/2018/08/06/custom-test-framework-prop.html</link><description><![CDATA[The Rust community recently approved a Custom Test Frameworks eRFC which lays out a series of goals and possible directions of exploration for implementing custom test frameworks. In this post, I present my own proposed fulfillment of the RFC with rationale.]]></description><guid isPermaLink="false">8c27c640-fb7d-42f9-a31f-09e9f5b35c2d</guid><pubDate>Wed,  8 Aug 2018 08:12:00 +0000</pubDate><dc:creator>John Renner</dc:creator></item><item><title>Launching the 2018 State of Rust Survey</title><link>https://blog.rust-lang.org/2018/08/08/survey.html</link><description><![CDATA[Itâ€™s that time again! Time for us to take a look at how the Rust project is doing, and what we should plan for the future. The Rust Community Team is pleased to announce our 2018 State of Rust Survey! Whether or not you use Rust today, we want to know your opinions. Your responses will help the project understand its strengths and weaknesses and establish development priorities for the future.

This year, volunteers have also translated the survey into 14 languages!]]></description><guid isPermaLink="false">f0133b81-60d3-416a-b58a-6d6c9c7afe6a</guid><pubDate>Wed,  8 Aug 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Community Team</dc:creator></item><item><title>Rust concurrency patterns: No context, no cancel, no leaks</title><link>https://medium.com/@polyglot_factotum/rust-concurrency-patterns-no-context-no-cancel-no-leak-b6c1ec2dafa5</link><description><![CDATA[Letâ€™s put ourselves to the challenge of having an â€˜infiniteâ€™ generator, which will have to be told to stop generating by the consumerâ€¦]]></description><guid isPermaLink="false">bbb6ed5a-a451-4abf-bbff-2e0b33f6660a</guid><pubDate>Tue,  7 Aug 2018 10:54:56 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Stacked Borrows: An Aliasing Model For Rust</title><link>https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html</link><description><![CDATA[In this post, I am proposing â€œStacked Borrowsâ€: A set of rules defining which kinds of aliasing are allowed in Rust. This is intended to answer the question which pointer may be used when to perform which kinds of memory accesses.]]></description><guid isPermaLink="false">b5f6a958-c0bd-4ea9-a1ae-d8e4f5549719</guid><pubDate>Tue,  7 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>Clippy&apos;s &quot;cast_lossless&quot; Lint Warning</title><link>https://benjamincongdon.me/blog/2018/08/06/Clippys-cast_lossless-Lint-Warning/</link><description><![CDATA[Recently, I was trying out clippy  â€” a linting and static analysis tool for Rust, when I ran into a lint warning that wasnâ€™t immediately clear to me: warning: casting u8 to u16 may become silently lossy if types change.]]></description><guid isPermaLink="false">64be78c2-0f4e-413f-ac54-1e6b21215413</guid><pubDate>Mon,  6 Aug 2018 20:28:01 +0000</pubDate><dc:creator>Benjamin Congdon</dc:creator></item><item><title>Rust Modules In Less Than 5 Minutes</title><link>https://medium.com/@erik.tate/rust-modules-in-less-than-5-minutes-9bff7f617798</link><description><![CDATA[When I started learning Rust, the module system did not at first seem to be a shining beacon of intuitive design. The Rust documentation is phenomenal, but there are definitely some areas that I found difficult to follow; this being one such topic. So I thought I might take a stab at writing up a guide that I think would have helped me through the awkward growing pains a bit quicker.]]></description><guid isPermaLink="false">7d6c2d9c-16c8-42be-93d5-d61cc9dac117</guid><pubDate>Sun,  5 Aug 2018 23:49:43 +0000</pubDate><dc:creator>Erik Tate</dc:creator></item><item><title>Logging from Rust in librsvg</title><link>https://people.gnome.org/~federico/blog/logging-in-librsvg.html</link><description><![CDATA[Over in this issue we are discussing how to add debug logging for librsvg.  A popular way to add logging to Rust code is to use the log crate. However, the log create is just a facade, and by default the messages do not get emitted anywhere. The calling code has to set up a logger. Crates like env_logger let one set up a logger, during program initialization, that gets configured through an environment variable. This is a problem for librsvg: we are not the program's initialization! Librsvg is a library; it doesn't have a main() function. And since most of the calling code is not Rust, we can't assume that they can call code that can initialize the logging framework.]]></description><guid isPermaLink="false">d711d36a-fa00-4b26-a367-26b70589af2e</guid><pubDate>Fri,  3 Aug 2018 19:29:43 -0500</pubDate><dc:creator>Federico Mena Quintero</dc:creator></item><item><title>Rust and the Case of the Redundant Comparison</title><link>https://blog.dend.ro/rust-and-the-case-of-the-redundant-comparison/</link><description><![CDATA[A couple of days ago I landed my second pull request in the Rust Programming Language repository. This is the story of how that went. This post is inspired by other posts about improving the Rust compiler.]]></description><guid isPermaLink="false">58e93b1c-f7b4-440f-88fb-fa5ab900f1c6</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>dend</dc:creator></item><item><title>Some Slight Improvements</title><link>https://llogiq.github.io/2018/08/04/improve.html</link><description><![CDATA[Today I want to talk about two Rust PRs I recently wrote. The PRs in question are #52942 and #52997. Both are relatively small changes to Rustâ€™s internally used data structures that improve performance and readability. Both have some basic benchmarks (the first one already had them and I wrote them for the second one), although itâ€™s rather hard to gauge whether they really impacted compile times (as perf.rust-lang.org puts all changes of the specific day together). But thatâ€™s not the point I want to make right now.]]></description><guid isPermaLink="false">02647906-fc14-42ea-87ec-19fc717cb3d7</guid><pubDate>Sat,  4 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Solving the Generalized Streaming Iterator Problem without GATs</title><link>http://lukaskalbertodt.github.io/2018/08/03/solving-the-generalized-streaming-iterator-problem-without-gats.html</link><description><![CDATA[Generic Associated Types (GATs for short) are a long awaited extension to Rustâ€™s type system. They offer a way to work with higher kinded types â€“ a necessity in a couple of situations. A common example is the streaming iterator: an iterator able to return items borrowing from self (the iterator itself). Unfortunately, GATs havenâ€™t even landed in nightly yet. So while are waiting, we can try tackling the streaming iterator problem without GATs. In this post we explore three possible workarounds for situations where an associated type depends on the lifetime of a &self receiver.]]></description><guid isPermaLink="false">2cc12b2e-22fb-461a-be01-ffeab54caa9f</guid><pubDate>Fri,  3 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Lukas Kalbertodt</dc:creator></item><item><title>Announcing Rust 1.28</title><link>https://blog.rust-lang.org/2018/08/02/Rust-1.28.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust. This release includes the global_allocator attribute to customise the allocator, improved error messages for format strings, and a number of number related stabilisations.]]></description><guid isPermaLink="false">44372b96-a1e4-44ee-af79-4496c4f629e6</guid><pubDate>Thu,  2 Aug 2018 00:00:00 +0000</pubDate><dc:creator>The Rust Core Team</dc:creator></item><item><title>Streaming UTF-8 in Haskell and Rust</title><link>https://www.fpcomplete.com/blog/2018/07/streaming-utf8-haskell-rust</link><description><![CDATA[An investigation into getting Haskell-like error handling ergonomics into a Rust application dealing with streaming UTF-8 encoding and decoding.]]></description><guid isPermaLink="false">8f26eb1d-8d0c-4785-a7fb-85c8cf5c6f27</guid><pubDate>Mon, 30 Jul 2018 09:00:00 +0000</pubDate><dc:creator>Michael Snoyman</dc:creator></item><item><title>That weekend I wasted on newtyped indices</title><link>https://exphp.github.io/2018/07/30/that-weekend-i-wasted-on-newtyped-indices.html</link><description><![CDATA[Today, ajyne posted a thread on users.rust-lang.org asking: What have been the drawbacks of static typing for you? Kornel was quick to reply with a variety of points, but this one in particular stands out to me, "With powerful type systems thereâ€™s no end to how far you can go to guarantee things about your program, but you might create a complex monster". As I see it, there is no truer answer. The type system can be a seductive beast, often promising correctness and performance at the low-low, one-time cost of your soul. I personally can name a number of examples from my own code base where I tried to abstract over something too big and failed. I call these my wasted weekends.]]></description><guid isPermaLink="false">4f9e9645-78dc-4c18-a504-653e96a0c960</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Michael Lamparski</dc:creator></item><item><title>Rust: controlling side effects from the test</title><link>https://blog.cyplo.net/posts/2018/07/rust-injection.html</link><description><![CDATA[Imagine you want to write a timestamping repository of some sorts, that will associate the timestamp of when the storage operation was invoked with the stored value. How to write it in Rust ? And more importantly - how to test it ? I would like to share a solution I found and talk a bit about how it works.]]></description><guid isPermaLink="false">3b874195-0df6-40ca-8667-067d3440061b</guid><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Cyryl PÅ‚otnicki</dc:creator></item><item><title>Rust concurrency patterns: Natural Born Pipelines</title><link>https://medium.com/@polyglot_factotum/rust-concurrency-patterns-natural-born-pipelines-4d599e7612fc</link><description><![CDATA[There seems to be demand for a â€œRust concurrent pipelineâ€ guide Ã  la https://blog.golang.org/pipelines, so letâ€™s give it a try.]]></description><guid isPermaLink="false">f7eba5d3-ef85-47cb-88ec-345cf3c46ade</guid><pubDate>Sat, 28 Jul 2018 09:12:33 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>A Snapshot of Rust&apos;s Popularity in July 2018</title><link>http://www.jonathanturner.org/2018/07/snapshot-of-rust-popularity.html</link><description><![CDATA[Talking about a languageâ€™s popularity is traditionally a tricky topic. How do you measure popularity? How do you compare one language to another when theyâ€™re focused on different styles and different audiences? So, rather than having one or two charts, Iâ€™m going to look at a number of â€œslicesâ€ into Rustâ€™s growth to see it front different angles.]]></description><guid isPermaLink="false">2dba28aa-a443-4887-9806-aba84cf787ef</guid><pubDate>Sat, 28 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Jonathan Turner</dc:creator></item></channel></rss>