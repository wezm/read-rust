<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Language</title><link>https://readrust.net/</link><description>Language posts on Read Rust</description><item><title>Implementing ArrayVec Using Const Generics</title><link>http://adventures.michaelfbryan.com/posts/const-arrayvec/</link><description><![CDATA[If you‚Äôve ever done much embedded programming in Rust, you‚Äôve most probably run across the arrayvec crate before. It‚Äôs awesome. The main purpose of the crate is to provide the ArrayVec type, which is essentially like Vec<T> from the standard library, but backed by an array instead of some memory on the heap.

One of the problems I ran into while writing the Motion Planning chapter of my Adventures in Motion Control was deciding how far ahead my motion planner should plan.]]></description><guid isPermaLink="false">ad358e1b-53e5-4665-b1e6-21a3b40d19e8</guid><pubDate>Fri, 15 Nov 2019 00:57:00 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Types Are for People, not Computers</title><link>https://ethankent.dev/posts/types_are_for_people/</link><description><![CDATA[Types‚Äîin the static-typing sense‚Äîare useful because they help people, not computers. Oh sure, we use them, in part, to subdue the compiler or meet some need peculiarly arising from our computer. But types are valuable because they are a way of communicating.

Type systems are a way of communicating. Type systems are a way of announcing what you understand, expect, or intend. Good type systems let you do so at the level of abstraction you choose.]]></description><guid isPermaLink="false">4a3e4de8-26ad-499f-8d9f-3cc0938adea0</guid><pubDate>Thu, 14 Nov 2019 09:00:00 -0600</pubDate><dc:creator>Ethan Kent</dc:creator></item><item><title>Thoughts on Error Handling in Rust</title><link>https://lukaskalbertodt.github.io/2019/11/14/thoughts-on-error-handling-in-rust.html</link><description><![CDATA[A programming language‚Äôs solution to error handling significantly influences the robustness, brevity, readability and ‚Äì to an extent ‚Äì the runtime performance of your code. Consequently, the error handling story is an important part of PL design. So it should not come as a surprise that the Rust community constantly discusses this topic. Given some recent discussions and the emergence of more and more error handling crates, this article shares some of my thoughts (not solutions!) on this.]]></description><guid isPermaLink="false">ee1d5ff4-a7ff-4676-9713-5421d4601c5a</guid><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Lukas Kalbertodt</dc:creator></item><item><title>Global Executors</title><link>https://boats.gitlab.io/blog/post/global-executors/</link><description><![CDATA[One of the big sources of difficulty on the async ecosystem is spawning tasks. Because there is no API in std for spawning tasks, library authors who want their library to spawn tasks have to depend on one of the multiple executors in the ecosystem to spawn a task, coupling the library to that executor in undesirable ways.
Ideally, many of these library authors would not need to spawn tasks at all.]]></description><guid isPermaLink="false">f4e093f3-7ebd-4513-9fa2-d50fee10872f</guid><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Find Usages implemented</title><link>https://rust-analyzer.github.io/2019/11/13/find-usages.html</link><description><![CDATA[Last month, rust-analyzer gained an exciting new feature: find usages. It was implemented by @viorina in #1892.]]></description><guid isPermaLink="false">41aebf2a-5466-4cc7-8456-4750ceb3052a</guid><pubDate>Wed, 13 Nov 2019 09:00:00 +0000</pubDate><dc:creator>rust-analyzer</dc:creator></item><item><title>Generalizing Coroutines in Rust</title><link>https://samsartor.com/coroutines-1/</link><description><![CDATA[Now that async/await has been released, attention has drifted back to refining stackless coroutines (the unstable language feature that makes async/await possible). Alas, the latest RFC has shown that there is still a lot of disagreement on what exactly coroutines in Rust should look like beyond async/await. I felt like it will be useful to flesh out what coroutines could be so we can better discuss what they should be.]]></description><guid isPermaLink="false">453d4192-89ee-43ad-b2c9-2d462c94f009</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Sam Sartor</dc:creator></item><item><title>The Demystifying Asynchronous Rust Book</title><link>https://teh-cmc.github.io/rust-async/html/</link><description><![CDATA[This book is targeted towards experienced programmers that already feel somewhat comfortable with vanilla Rust (you definitely do not need to be an "expert" though, I certainly am not) and would like to dip their toes into its async ecosystem.

As the title indicates, this is not so much a book about how to use async Rust as much as it is about trying to build a solid understanding of how it all works under the hood. From there, efficient usage should come naturally.]]></description><guid isPermaLink="false">b6cc68e0-c563-4eb0-a374-7c11dad01824</guid><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Clement Rey</dc:creator></item><item><title>How Swift Achieved Dynamic Linking Where Rust Couldn&apos;t</title><link>https://gankra.github.io/blah/swift-abi/</link><description><![CDATA[For those who don't follow Swift's development, ABI stability has been one of its most ambitious projects and possibly it's defining feature, and it finally shipped in Swift 5. The result is something I find endlessly fascinating, because I think Swift has pushed the notion of ABI stability farther than any language without much compromise.

So I decided to write up a bunch of the interesting high-level details of Swift's ABI. This is not a complete reference for Swift's ABI, but rather an abstract look at its implementation strategy. If you really want to know exactly how it allocates registers or mangles names, look somewhere else.

Also for context on why I'm writing this, I'm just naturally inclined to compare the design of Swift to Rust, because those are the two languages I have helped develop. Also some folks like to complain that Rust doesn't bother with ABI stability, and I think looking at how Swift does helps elucidate why that is.]]></description><guid isPermaLink="false">225f7f8a-4d16-4eee-9022-bbb1d35e26a9</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Alexis Beingessner</dc:creator></item><item><title>Simple data stitching</title><link>http://segfaultsourcery.s3-website.eu-central-1.amazonaws.com/snippets/rust/stitching/landing.html#simple-data-stitching</link><description><![CDATA[I found myself in a situation where I had a number of CSV files that all shared some key data, and all had to be put together to a larger dataset. I figured that the easiest way to do this would be to deserialize the files, then stitch them together using a portion of their data as a key.

I decided to try my hand at writing a macro to solve the issue, and I ended up with two of them; one for one-to-one relations, and one for one-to-many.]]></description><guid isPermaLink="false">a09f683f-9aec-46cc-83e8-0aa1acf20f31</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Kim H√•</dc:creator></item><item><title>Async-await on stable Rust!</title><link>https://blog.rust-lang.org/2019/11/07/Async-await-stable.html</link><description><![CDATA[On Thursday, November 7, async-await syntax hit stable Rust, as part of the 1.39.0 release. This work has been a long time in development -- the key ideas for zero-cost futures, for example, were first proposed by Aaron Turon and Alex Crichton in 2016! -- and we are very proud of the end result. We believe that Async I/O is going to be an increasingly important part of Rust's story.]]></description><guid isPermaLink="false">35e06989-4cc4-4d3b-ab76-5830da233ebd</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Announcing Rust 1.39.0</title><link>https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html</link><description><![CDATA[The Rust team is happy to announce a new version of Rust, 1.39.0. The highlights of Rust 1.39.0 include async/.await, shared references to by-move bindings in match guards, and attributes on function parameters.]]></description><guid isPermaLink="false">dfcf2420-e465-4c62-8b31-f7e2792c2e94</guid><pubDate>Thu,  7 Nov 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Rust concurrency patterns: condvars and locks</title><link>https://medium.com/@polyglot_factotum/rust-concurrency-patterns-condvars-and-locks-e278f18db74f</link><description><![CDATA[I‚Äôve spent quite a lot of time extolling the virtues of message-passing in concurrent Rust. However, there are times when shared-state is the right approach, sometimes just because it‚Äôs the historical approach chosen in a module and you want to add something to it without refactoring the whole thing. So today we‚Äôre going to talk about using shared-state, with the help of condvars and locks.]]></description><guid isPermaLink="false">155c1b1a-4660-4feb-8ab9-3dc8c211afb2</guid><pubDate>Mon,  4 Nov 2019 14:52:14 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Runtime Diagnostics</title><link>https://blog.yoshuawuyts.com/runtime-diagnostics/</link><description><![CDATA[Rust is well-known for its helpful error messages, good tooling, and generally empathic compiler interface. If something goes wrong, Rust tries hard to help you get back on track. In this post I'd like to talk about the runtime aspect of debugging errors.]]></description><guid isPermaLink="false">02e9c871-0bac-4650-8fc3-1c8c64e95c7e</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>mrustc 0.9 - Now with rust 1.29.0 support</title><link>https://www.reddit.com/r/rust/comments/dqi1u1/mrustc_09_now_with_rust_1290_support/</link><description><![CDATA[I'm finally happy to announce that I've "finished" the 1.29 branch of mrustc (for those who don't know, mrustc is my attempt at making a rust compiler, primarily for breaking the bootstrap chain).

This version is capable of compiling both rustc 1.29 (and packaged cargo) AND rustc 1.19, both of which can compile their successors (1.20 and 1.30 - and 1.30 results in a binary equal output).]]></description><guid isPermaLink="false">3e6e0860-0ced-48d0-9f44-a2cfe3355a63</guid><pubDate>Sat,  2 Nov 2019 00:00:00 +0000</pubDate><dc:creator>John Hodge (Mutabah)</dc:creator></item><item><title>Completing the transition to the new borrow checker</title><link>https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html</link><description><![CDATA[For most of 2018, we've been issuing warnings about various bugs in the borrow checker that we plan to fix -- about two months ago, in the current Rust nightly, those warnings became hard errors. In about two weeks, when the nightly branches to become beta, those hard errors will be in the beta build, and they will eventually hit stable on December 19th, as part of Rust 1.40.0. If you're testing with Nightly, you should be all set -- but otherwise, you may want to go and check to make sure your code still builds. If not, we have advice for fixing common problems below.]]></description><guid isPermaLink="false">290147b3-4275-4b38-86d1-48ead00c7e9f</guid><pubDate>Fri,  1 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Implementing a job queue in Rust</title><link>https://www.poor.dev/posts/what-job-queue/</link><description><![CDATA[I recently finished my first rust project - a command line utility called ‚Äúwhat‚Äù that displays network utilization information. As a newcomer to rust, this project offered quite some challenges for me. This post is a write up of one of them, going into detail on the parts that I personally found most difficult to understand.

In this first post, I‚Äôd like to talk about implementing a job queue to resolve IPs into their hostnames by querying a remote DNS server.]]></description><guid isPermaLink="false">5fd6f3d5-2732-4d86-9824-78928983ebdf</guid><pubDate>Wed, 30 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Aram Drevekenin</dc:creator></item><item><title>Quantum computing in Rust, part 1</title><link>https://walther.guru/blog/impl-quantum-part-1/</link><description><![CDATA[What is a ket? How do traits work? Implementing a quantum computer simulator in Rust.]]></description><guid isPermaLink="false">bf08077b-89c9-4880-9b0b-5b869fd21252</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Veeti Haapsamo</dc:creator></item><item><title>The Rustc Learning Working Group - An Introduction</title><link>https://blog.rust-lang.org/inside-rust/2019/10/28/rustc-learning-working-group-introduction.html</link><description><![CDATA[The Learning Working Group, formed in April 2019, is focused on making the compiler easier to learn by ensuring that rustc-guide and API docs are "complete". It is one of the many efforts by the Rust Compiler team to decrease the barrier of contributing to the compiler.]]></description><guid isPermaLink="false">884f2a1b-a04c-44b4-ae44-c7f1b489cbc6</guid><pubDate>Mon, 28 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Amanjeev Sethi</dc:creator></item><item><title>Rust error handling with Result and Option (WebAssembly ABI)</title><link>https://brionv.com/log/2019/10/27/rust-error-handling-with-result-and-option-webassembly-abi/</link><description><![CDATA[In our last adventure we looked at C++ exceptions in WebAssembly with the emscripten compiler. Now we‚Äôre taking a look at the main error handling system for another language targeting WebAssembly, Rust. Rust has a ‚Äúpanic‚Äù/‚Äùunwind‚Äù system similar to C++ exceptions, but it‚Äôs generally recommended against catching panics.]]></description><guid isPermaLink="false">cef4b4b5-5c64-4da9-a91a-89155efd377f</guid><pubDate>Sun, 27 Oct 2019 19:59:33 +0000</pubDate><dc:creator>Brion Vibber</dc:creator></item><item><title>Programming Servo: the incredibly shrinking timer</title><link>https://medium.com/programming-servo/programming-servo-the-incredibly-shrinking-timer-7283ae2a2669</link><description><![CDATA[How to build a timer in Rust in five easy evolutionary steps.]]></description><guid isPermaLink="false">49a2176c-55b0-4603-8f20-d0d15ab56ca4</guid><pubDate>Sun, 27 Oct 2019 15:40:54 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Audio Processing for Dummies</title><link>http://adventures.michaelfbryan.com/posts/audio-processing-for-dummies/</link><description><![CDATA[In my spare time I‚Äôm an emergency services volunteer, and one of the tasks our unit has is to run the radio network and keep track of what‚Äôs happening. This can be a pretty stressful job, especially when there‚Äôs lots of radio traffic, and it‚Äôs not unusual to miss words or entire transmissions.

To help with a personal project that could make the job easier I‚Äôd like to implement a basic component of audio processing, the Noise Gate.]]></description><guid isPermaLink="false">6d1c1c33-6e97-4911-af35-4b6e621da968</guid><pubDate>Sun, 27 Oct 2019 23:34:00 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Rust once and share it with Android, iOS and Flutter</title><link>https://robertohuertas.com/2019/10/27/rust-for-android-ios-flutter/</link><description><![CDATA[What if I told you that you could use the same very performant code in Android, iOS or even in Flutter. In this article, we‚Äôll see how to achieve this with Rust.]]></description><guid isPermaLink="false">9d326b39-4675-4c5f-9509-d388a4e41486</guid><pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Roberto Huertas</dc:creator></item><item><title>Why async fn in traits are hard</title><link>http://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/</link><description><![CDATA[After reading boat‚Äôs excellent post on asynchronous destructors, I thought it might be a good idea to write some about async fn in traits. Support for async fn in traits is probably the single most common feature request that I hear about. It‚Äôs also one of the more complex topics. So I thought it‚Äôd be nice to do a blog post kind of giving the ‚Äúlay of the land‚Äù on that feature ‚Äì what makes it complicated? What questions remain open?]]></description><guid isPermaLink="false">da517b10-2b8a-4b94-97c3-34b0c049de42</guid><pubDate>Sat, 26 Oct 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Autoref-based stable specialization</title><link>https://github.com/dtolnay/case-studies/blob/master/autoref-specialization/README.md</link><description><![CDATA["Specialization" refers to permitting overlapping impls in Rust's trait system so long as for every possible type, one of the applicable impls is "more specific" than the others for some intuitive but precisely defined notion of specific. Discussions about a specialization language feature have been ongoing for 4.5 years (RFC 1210, rust-lang/rust#31844). Today the feature is partially implemented in rustc but is not yet sound when mixed with lifetimes (rust-lang/rust#40582) and requires more language design work and compiler work before it could be stabilized.

This page covers a stable, safe, generalizable technique for solving some of the use cases that would otherwise be blocked on specialization. The technique was originally developed for use by macros in the Anyhow crate.]]></description><guid isPermaLink="false">edce4809-119e-4572-892f-7d7978cc6c08</guid><pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>Scratching NASDAQ&apos;s ITCH</title><link>http://petr-tik.github.io/posts/itch_parser_debugging/</link><description><![CDATA[I am building yet another order book tool in Rust, which requires me to parse L3 (full) market data feed from NASDAQ. In the words of one experienced trading systems developer writing a feed handler is boooooring, but does not build an order book, so I searched if someone else has implemented it already. Thankfully, adwhit has implemented a library to parse ITCH 5.0 feeds from files, which is one line away from importing to my Cargo.toml.]]></description><guid isPermaLink="false">1bfa39d0-d652-4587-b229-7e40041f0764</guid><pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate><dc:creator>petr-tik</dc:creator></item><item><title>Announcing the LLVM ICE-breaker group</title><link>https://blog.rust-lang.org/inside-rust/2019/10/22/LLVM-ICE-breakers.html</link><description><![CDATA[Today I'm announcing a new experiment in the compiler team, the LLVM ICE-breaker group. If you're familiar with LLVM and would like to contribute to rustc -- but without taking on a large commitment -- then the LLVM ICE-breaker group might well be for you!]]></description><guid isPermaLink="false">5a7311d2-3cf3-47fa-bce5-10b0747b30e8</guid><pubDate>Tue, 22 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>How to not rewrite it in Rust</title><link>http://adventures.michaelfbryan.com/posts/how-not-to-riir/</link><description><![CDATA[Once you get past the growing pains of the Borrow Checker and realise Rust gives you the power to do things which would be unheard of (or just plain dangerous) in other languages, the temptation to Rewrite it in Rust can be quite strong. However at best, the temptation to RiiR is unproductive (unnecessary duplication of effort), and at worst it can promote the creation of buggy software (why would you be better equipped to write a library for some domain-specific purpose than the original author?]]></description><guid isPermaLink="false">e8d05615-a728-4bea-8f43-400827903e1a</guid><pubDate>Sun, 20 Oct 2019 19:45:00 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Cost of rust-analyzer</title><link>https://rust-analyzer.github.io/2019/10/16/finance.html</link><description><![CDATA[In this post, we‚Äôll talk about financial side of the rust-analyzer project. The goal is to find out how much rust-analyzer costs now, formulate financial goals for speeding up the development and document the Open Collective expenses policy.]]></description><guid isPermaLink="false">6e9b1816-3105-4847-b96e-d3af713b9ebc</guid><pubDate>Wed, 16 Oct 2019 09:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Asynchronous Destructors</title><link>https://boats.gitlab.io/blog/post/poll-drop/</link><description><![CDATA[The first version of async/await syntax is in the beta release, set to be shipped to stable in 1.39 on November 7, next month. There are a wide variety of additional features we could add to async/await in Rust beyond what we‚Äôre shipping in that release, but speaking for myself I know that I‚Äôd like to pump the breaks on pushing forward big ticket items in this space. Let‚Äôs let the ecosystem develop around what we have now before we start sprinting toward more big additions to the language.]]></description><guid isPermaLink="false">9b853968-186e-414b-af4a-f4a6cf9e7392</guid><pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Announcing Rustup 1.20.0</title><link>https://blog.rust-lang.org/2019/10/15/Rustup-1.20.0.html</link><description><![CDATA[The highlights of this release are profiles support, the ability to get the latest available nightly with all the components you need, and improvements to the rustup doc command. You can also check out the changelog for a list of all the changes included in this release.]]></description><guid isPermaLink="false">8629a67f-d7a6-41e9-80b1-e568f491c325</guid><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><dc:creator>The Rustup Working Group</dc:creator></item><item><title>Detecting Application Uniqueness and interprocess communication in Rust</title><link>https://gitlab.com/snippets/1903637</link><description><![CDATA[The aim of this article is to demonstrate one of many ways to detect application uniqueness and establish unilateral interprocess communication in Rust in the Linux platform. Note that the APIs used in this article is not portable to Windows and other *nix systems. Also note that methods used in this article may not be best suitable for all use cases.]]></description><guid isPermaLink="false">8b2ade3b-1476-4770-a7e2-838c3623a381</guid><pubDate>Mon, 14 Oct 2019 00:00:00 +0000</pubDate><dc:creator>9898287</dc:creator></item><item><title>My favorite rust function</title><link>https://blog.jabid.in/2019/10/11/drop.html</link><description><![CDATA[My favorite rust function is std::mem::drop which is used to free ordeallocate a value, similar to free() in C.]]></description><guid isPermaLink="false">97a5bf30-4c89-489d-a27e-6d3f32e90b6e</guid><pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Jaseem Abid</dc:creator></item><item><title>We couldn&apos;t get Bitcode and Rust to play nice, until we did</title><link>https://www.ditto.live/blog/rust-bitcode-with-xcode</link><description><![CDATA[The Rust compiler has problems creating Bitcode that's compatible with recent versions of Xcode. Ditto uses a custom toolchain that stays in sync with Apple‚Äîand you can too.]]></description><guid isPermaLink="false">dabffd4d-73ef-4700-8711-b648230659b9</guid><pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Tom Karpiniec</dc:creator></item><item><title>The Node Experiment - Exploring Async Basics with Rust</title><link>https://cfsamson.github.io/book-exploring-async-basics/</link><description><![CDATA[After originally researching the history and discussions about Rusts Async story, I realized I needed a better understanding of async basics and the result is this book. It's published it as a gitbook to make this journey easier for the next person (hopefully).]]></description><guid isPermaLink="false">e131911e-9ccb-4b6f-9c05-f95611cb66d2</guid><pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Carl Fredrik Samson</dc:creator></item><item><title>How I handle errors in Rust</title><link>https://blog.kiani.io/blog/how-i-handle-errors-in-rust/</link><description><![CDATA[derive_more is a crate which has many proc macros, amongst which is a macro for deriving From for structs, enums, and newtypes. From is the basic mechanism for using ? ergonomically in a function which returns Result<T, Error>. Almost everything I write has the derive_more crate as a dependency, and the following pattern for handling errors.]]></description><guid isPermaLink="false">79f41426-ad58-4eac-9adb-88b27c2a63ba</guid><pubDate>Wed,  9 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Ashkan Kiani</dc:creator></item><item><title>Designing a COM library for Rust</title><link>https://msrc-blog.microsoft.com/2019/10/08/designing-a-com-library-for-rust/</link><description><![CDATA[I interned with Microsoft as a Software Engineering Intern in the MSRC UK team in Cheltenham this past summer. I worked in the Safe Systems Programming Language (SSPL) group, which explores safe programming languages as a proactive measure against memory-safety related vulnerabilities.

This blog post describes the project that I have been working on under the mentorship of the SSPL team. Hopefully, this provides additional insight into the work Microsoft interns do! My goal was to build an open-sourced Rust library that will allow developers to both consume and produce in-process Component Object Model (COM) components in an idiomatic manner.]]></description><guid isPermaLink="false">409c73c3-8c32-4c3a-97a9-30f700237fe8</guid><pubDate>Tue,  8 Oct 2019 17:00:03 +0000</pubDate><dc:creator>Hadrian Wei Heng Lim</dc:creator></item><item><title>Why we‚Äôre bringing Astropad cross-platform with Rust</title><link>https://blog.astropad.com/why-rust/</link><description><![CDATA[Over the past few years, we‚Äôve heard over and over again about an exodus from Mac to Windows in the creative community. Here at Astropad, we‚Äôve kept a close eye on this shift, knowing that Windows would be a big part of our company‚Äôs future. Our flagship products ‚Äî Astropad Studio and Luna Display ‚Äî primarily serve the creative pro market. Both products run on our low-latency, high-fidelity video streaming technology called Liquid that was designed to meet the demands of professional illustrators, animators, and photographers.

When we were first building our products, we used the tools we were most comfortable with, like Objective-C and the Cocoa APIs. This allowed us to move quickly, launch Astropad 1.0, and establish product-market fit in a relatively short period of time. But as we grew, we made the mistake of doubling down on Objective-C, and we pushed off the Windows effort because it created a catch-22 situation of engineering hurdles. Our Liquid engine was tightly wrapped around the Apple ecosystem, and the thought of unraveling ourselves was hard to imagine. ]]></description><guid isPermaLink="false">6907953b-62d5-475e-8695-0e89fec37b5e</guid><pubDate>Mon,  7 Oct 2019 19:23:43 +0000</pubDate><dc:creator>Matt Ronge</dc:creator></item><item><title>Ownership and impl Trait</title><link>https://tech.fpcomplete.com/rust/ownership-and-impl-trait</link><description><![CDATA[There's a common pattern in Rust APIs: returning a relatively complex data type which provide a trait implementation we want to work with. One of the first places many Rust newcomers encounter this is with iterators.]]></description><guid isPermaLink="false">90d063a7-b14b-4a7d-be58-a33e6e1dcb5f</guid><pubDate>Mon,  7 Oct 2019 03:48:44 +0000</pubDate><dc:creator>FP Complete</dc:creator></item><item><title>Async Foundations Update: Time for polish!</title><link>https://blog.rust-lang.org/inside-rust/2019/10/07/AsyncAwait-WG-Focus-Issues.html</link><description><![CDATA[As you've perhaps heard, recently the async-await feature landed on the Rust beta branch. This marks a big turning point in the usability story for Async Rust. But there's still a lot of work to do. As we mentioned in the main post, the focus for the Async Foundations WG in the immediate term is going to be polish, polish and (ahem) more polish.

In particular, we want to take aim at a backlog of strange diagnostics, suboptimal performance, and the occasional inexplicable type-check failure. This is a shift: whereas before, we could have laser focus on things that truly blocked stabilization, we've now got a large set of bugs, often without a clear prioritization between them. This requires us to mix up how the Async Foundations WG is operating.]]></description><guid isPermaLink="false">15c5520b-d7f9-4acc-939f-371cb8fbab95</guid><pubDate>Mon,  7 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>The &quot;Inside Rust&quot; Blog</title><link>https://blog.rust-lang.org/inside-rust/</link><description><![CDATA[This is the "Inside Rust" blog. This blog is aimed at those who wish to follow along with Rust development. The various Rust teams and working groups use this blog to post status updates, calls for help, and other similar announcements.]]></description><guid isPermaLink="false">55e7a635-29bd-4a2d-aaac-b0d599006ff7</guid><pubDate>Fri,  4 Oct 2019 01:18:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Tarpaulin And The Futures</title><link>https://xd009642.github.io/2019/10/02/Tarpaulin-and-the-futures.html</link><description><![CDATA[Tarpaulin (or cargo-tarpaulin) is a code coverage tool for Rust, and anyone who‚Äôs used it might know that until recently it had an issue with code that used futures.]]></description><guid isPermaLink="false">cd24e5cb-982d-424e-85b2-0b7284cadee4</guid><pubDate>Wed,  2 Oct 2019 00:00:00 +0000</pubDate><dc:creator>xd009642</dc:creator></item><item><title>Building the Azure IoT Edge Security Daemon in Rust</title><link>https://msrc-blog.microsoft.com/2019/09/30/building-the-azure-iot-edge-security-daemon-in-rust/</link><description><![CDATA[Azure IoT Edge is an open source, cross platform software project from the Azure IoT team at Microsoft that seeks to solve the problem of managing distribution of compute to the edge of your on-premise network from the cloud. This post explains some of the rationale behind our choice of Rust as the implementation programming language for the Security Daemon component in the product.]]></description><guid isPermaLink="false">f7d6bffe-ea86-4fbc-9aa6-4ba15b3929a5</guid><pubDate>Mon, 30 Sep 2019 16:45:48 +0000</pubDate><dc:creator>Raj Vengalil</dc:creator></item><item><title>Plugins in Rust</title><link>http://adventures.michaelfbryan.com/posts/plugins-in-rust/</link><description><![CDATA[Imagine you are implementing a calculator application and want users to be able to extend the application with their own functionality. For example, imagine a user wants to provide a random() function that generates true random numbers using random.org instead of the pseudo-random numbers that a crate like rand would provide.

The Rust language gives you a lot of really powerful tools for adding flexibility and extensibility to your applications (e.g. traits, enums, macros), but all of these happen at compile time. Unfortunately, to get the flexibility that we‚Äôre looking we‚Äôll need to be able to add new functionalty at runtime. This can be achieved using a technique called Dynamic Loading.]]></description><guid isPermaLink="false">7a86a452-ec34-4489-b209-f91aecdd6d98</guid><pubDate>Mon, 30 Sep 2019 22:04:58 +0800</pubDate><dc:creator>Michael-F-Bryan</dc:creator></item><item><title>Async-await hits beta!</title><link>https://blog.rust-lang.org/2019/09/30/Async-await-hits-beta.html</link><description><![CDATA[Big news! As of this writing, syntactic support for async-await is available in the Rust beta channel! It will be available in the 1.39 release, which is expected to be released on November 7th, 2019. Once async-await hits stable, that will mark the culmination of a multi-year effort to enable efficient and ergonomic asynchronous I/O in Rust. It will not, however, mark the end of the road: there is still more work to do, both in terms of polish (some of the error messages we get today are, um, not great) and in terms of feature set (async fn in traits, anyone?).]]></description><guid isPermaLink="false">fbf09d15-52c8-4ab6-a6bf-22c0b238aedb</guid><pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Figthting The Async Fragmentation</title><link>https://vorner.github.io/2019/09/29/figthting-the-async-fragmentation.html</link><description><![CDATA[Sometimes, I get this nudging feeling that something is not exactly right and that I have to go out and save the world and fix it (even though it‚Äôs usually something minor or doesn‚Äôt need fixing at all). I guess everyone has days like these. It‚Äôs part what drives me to invest my free time to writing software.

This is about some dead ends when trying to fix the problem of Rust‚Äôs async networking fragmentation. I haven‚Äôt been successful, but I can at least share what I tried and discovered, maybe someone else is having the same bugging feeling so they don‚Äôt have to repeat them. Or just maybe some of the approaches would work for some other problems. And because we have a bunch of success stories out there, having some failure stories to balance it doesn‚Äôt hurt.]]></description><guid isPermaLink="false">51a1a155-fccb-426f-b0e5-f4670be28e9d</guid><pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Announcing Rust 1.38.0</title><link>https://blog.rust-lang.org/2019/09/26/Rust-1.38.0.html</link><description><![CDATA[The highlight of this release is pipelined compilation. The release also includes linting of some incorrect uses of mem::{uninitialized, zeroed}, #[deprecated] macros, std::any::type_name, and more.]]></description><guid isPermaLink="false">d9b796b1-aacb-4a2f-ad7b-05ce22cc3ec1</guid><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Generic Newtypes: A way to work around the orphan rule</title><link>https://blog.eizinger.io/8593/generic-newtypes-a-way-to-work-around-the-orphan-rule</link><description><![CDATA[Rust's orphan rule prevents us from implementing a foreign trait on a foreign type. While this may appear limiting at first, it is actually a good thing and one of the ways how the Rust compiler can prove at compile time that our code works the way we intended.

 This blog post is a follow-up on one that I already wrote some time ago. In this one, we will go more in-depth into the "local wrapper type" idea and rebrand it as "generic newtypes".]]></description><guid isPermaLink="false">388629ea-87a4-4119-a7d5-24c13c2e470b</guid><pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Eizinger</dc:creator></item><item><title>Async Builders</title><link>https://blog.yoshuawuyts.com/async-finalizers/</link><description><![CDATA[Last month we introduced Surf, an async cross-platform streaming HTTP client for Rust. It was met with a great reception, and people generally seem to be really enjoying it. A common piece of feedback we've gotten is how much people enjoy the interface, in particular how little code it requires to create HTTP requests. In this post we'll cover a pattern at the heart of Surf's ergonomics stjepang came up with: the "async finalizer".]]></description><guid isPermaLink="false">258e95ec-03a2-47b2-b577-cf45ad96924e</guid><pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>Declarative memory management</title><link>https://fasterthanli.me/blog/2019/declarative-memory-management/</link><description><![CDATA[It feels like an eternity since I‚Äôve started using Rust, and yet I remember vividly what it felt like to bang my head against the borrow checker for the first few times.

I‚Äôm definitely not alone in that, and there‚Äôs been quite a few articles on the subject! But I want to take some time to present the borrow checker from the perspective of its benefits, rather than as an opponent to fend with.]]></description><guid isPermaLink="false">feee8a1a-6c6b-45dc-a800-6d93d18e7b9a</guid><pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Amos</dc:creator></item><item><title>Improved C Variadics in Rust and C2Rust</title><link>https://immunant.com/blog/2019/09/variadics/</link><description><![CDATA[Our goal in the C2Rust project is to translate any valid C99 program into equivalent Rust code. Naturally, this means we need to properly support translating C variadic functions into Rust. For a long time, the Rust-C FFI only allowed one-way calls to C variadic functions: Rust code could call C variadic functions, but not the other way around. Rust RFC 2137 proposed an interface for Rust code to provide C-compatible variadic functions, which was later implemented as a series of patches by Dan Robertson that have been merged into nightly Rust from November 2018 to February 2019.]]></description><guid isPermaLink="false">fc07abd0-fc94-40d6-b4f8-b29ce54fb934</guid><pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Immunant, Inc.</dc:creator></item><item><title>It‚Äôs not wrong that &quot;ü§¶üèº‚Äç‚ôÇÔ∏è&quot;.length == 7</title><link>https://hsivonen.fi/string-length/</link><description><![CDATA[But It‚Äôs Better that "ü§¶üèº‚Äç‚ôÇÔ∏è".len() == 17 and Rather Useless that len("ü§¶üèº‚Äç‚ôÇÔ∏è") == 5

From time to time, someone shows that in JavaScript the .length of a string containing an emoji results in a number greater than 1 (typically 2) and then proceeds to the conclusion that haha JavaScript is so broken‚Äîand is rewarded with many likes. In this post, I will try to convince you that ridiculing JavaScript for this is less insightful than it first appears and that Swift‚Äôs approach to string length isn‚Äôt unambiguously the best one. Python 3‚Äôs approach is unambiguously the worst one, though.]]></description><guid isPermaLink="false">f6721f14-deaa-4603-949e-f62b5130e6d7</guid><pubDate>Sun,  8 Sep 2019 23:17:00 +0000</pubDate><dc:creator>Henri Sivonen</dc:creator></item><item><title>Parsing with crate LALRPOP</title><link>https://tensor.sh/parsing-with-crate-lalrpop</link><description><![CDATA[How to write a parser using rust and lalrpop crate? In this article, we are going to walk through the implementation of parsing a string like this:

This is a {dog, cat}.

And we want to expand this string into the following two strings:

 This is a dog.
This is a cat.]]></description><guid isPermaLink="false">0878c302-d2e1-43c2-9ab4-1338d657fe69</guid><pubDate>Mon,  2 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Will</dc:creator></item><item><title>Futures Concurrency</title><link>https://blog.yoshuawuyts.com/futures-concurrency/</link><description><![CDATA[In a previous post we've looked at Rust streams. In this post we're going to discuss another problem in the async space: futures concurrency combinators. We're going to cover the different forms of concurrency that can be expressed with Futures, and cover both fallible and infallible variants.]]></description><guid isPermaLink="false">d821223f-0e0c-4bbf-a248-7191d0c0c1da</guid><pubDate>Mon,  2 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Yoshua Wuyts</dc:creator></item><item><title>How Rust optimizes async/await II: Program analysis</title><link>https://tmandry.gitlab.io/blog/posts/optimizing-await-2/</link><description><![CDATA[In Part 1, we covered how async fns in Rust are compiled to state machines. We saw that the internal compiler implementation uses generators and the yield statement to facilitate this transformation. In this post, we'll go over some subtleties that the compiler implementation must consider when optimizing generators. We'll look at two different kinds of analysis, liveness analysis and storage conflict detection.]]></description><guid isPermaLink="false">7304ebe7-ee28-48a9-b88c-dd03e2605a10</guid><pubDate>Mon,  2 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Tyler Mandry</dc:creator></item><item><title>Monadic parser combinators in Rust</title><link>https://sergey-melnychuk.github.io/2019/08/31/rust-parser-combinators/</link><description><![CDATA[Why don‚Äôt I implement a nice monadic parser combinator library in Rust? That‚Äôs what my thought was when after implementing low-level mock-HTTP server in MIO and actually needed to parse the bytes received by server. What I wanted is a declative way to define sequence of strings to be matched and/or extracted. ]]></description><guid isPermaLink="false">490a94d9-b859-4011-9511-532a8a209fd6</guid><pubDate>Sat, 31 Aug 2019 16:24:42 +0000</pubDate><dc:creator>Sergey Melnychuk</dc:creator></item><item><title>Async Stack Traces in Rust</title><link>http://fitzgeraldnick.com/2019/08/27/async-stacks-in-rust.html</link><description><![CDATA[One neat result of Rust‚Äôs futures and async/await design is that all of the async callers are on the stack below the async callees. In most other languages, only the youngest async callee is on the stack, and none of the async callers. Because the youngest frame is most often not where a bug‚Äôs root cause lies, this extra context makes debugging async code easier in Rust.]]></description><guid isPermaLink="false">518da2d7-644e-4028-95a2-388b2cb5fc0f</guid><pubDate>Tue, 27 Aug 2019 00:00:00 -0700</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Using ramdisks with Cargo</title><link>https://fy.blackhats.net.au/blog/html/2019/08/26/using_ramdisks_with_cargo.html</link><description><![CDATA[I have a bit of a history of killing SSDs - probably because I do a bit too much compiling and management of thousands of tiny files. Plenty of developers have this problem! So while thinking one evening, I was curious if I could setup a ramdisk on my mac for my cargo work to output to.]]></description><guid isPermaLink="false">0127a4ce-f036-4969-bab1-d55679ac36ce</guid><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Firstyear</dc:creator></item><item><title>Advent of Code in Rust: lessons learned</title><link>https://gendignoux.com/blog/2019/08/25/rust-advent-of-code.html</link><description><![CDATA[Last December, I decided to solve the Advent of Code (AoC) programming puzzles in Rust. This website is an advent calendar proposing a new algorithmic problem of varying difficulty every day throughout December, so it‚Äôs a great way to learn and practice a programming language. There is also a leaderboard for the fastest people to solve them, but the past problems remain available forever, so don‚Äôt worry if you‚Äôre too slow or busy in December, you can try them any time of the year - as this overdue blog post shows!

I already have some experience in Rust programming, but I felt that I could learn more about idiomatic Rust. Given the short time to solve each problem, it was a perfect opportunity to avoid reinventing the wheel but use the standard library as much as possible.

Here are the most useful Rust features that I learned and used during this challenge.]]></description><guid isPermaLink="false">c7f41ce0-3664-4696-90a6-16b5b025820e</guid><pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Guillaume Endignoux</dc:creator></item><item><title>Wrapping Unsafe C Libraries in Rust</title><link>https://medium.com/dwelo-r-d/wrapping-unsafe-c-libraries-in-rust-d75aeb283c65</link><description><![CDATA[In this article, we will explore how to wrap those functions and make them safe for normal use. We‚Äôll go over how to define a wrapper struct that handles initialization and cleanup, and describe some traits that describe how application developers can safely use your library with threads. We‚Äôll also talk a bit about how to turn a function‚Äôs random integer return into an ergonomic, type-checked Result, how to translate strings and arrays to and from the world of C, and how to turn raw pointers returned from C into scoped objects with inherited lifetimes.

The overall goal of this step is to dig into the C library‚Äôs documentation and make each function‚Äôs internal assumptions explicit.]]></description><guid isPermaLink="false">eb9194f2-85b1-412c-aa0b-0218529bf163</guid><pubDate>Sat, 24 Aug 2019 07:09:28 +0000</pubDate><dc:creator>Jeff Hiner</dc:creator></item><item><title>Is This Magic!? Ferris Explores Rustc!</title><link>https://quietmisdreavus.net/code/2019/08/23/is-this-magic-ferris-explores-rustc/</link><description><![CDATA[A companion to the RustConf 2019 talk with the same name; an introduction to making your first contribution to the Rust compiler.]]></description><guid isPermaLink="false">63fb93a7-e179-491f-83b9-84a7e284fe48</guid><pubDate>Fri, 23 Aug 2019 11:00:00 -0500</pubDate><dc:creator>QuietMisdreavus</dc:creator></item><item><title>Join Your Threads</title><link>https://matklad.github.io/2019/08/23/join-your-threads.html</link><description><![CDATA[This is a note on how to make multithreaded programs more robust. It‚Äôs not really specific to Rust, but I get to advertise my new jod-thread micro-crate :)]]></description><guid isPermaLink="false">c50ebb87-7e8f-4d08-bc8c-ebe51377faf4</guid><pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Thoughts on Rust bloat</title><link>https://raphlinus.github.io/rust/2019/08/21/rust-bloat.html</link><description><![CDATA[I‚Äôm about to accept a PR that will increase druid‚Äôs compile time about 3x and its executable size almost 2x. In this case, I think the tradeoff is worth it (without localization, a GUI toolkit is strictly a toy), but the bloat makes me unhappy and I think there is room for improvement in the Rust ecosystem.]]></description><guid isPermaLink="false">5b9044be-428f-48ff-b1f3-b9f0e6b63732</guid><pubDate>Wed, 21 Aug 2019 17:17:42 +0000</pubDate><dc:creator>Raph Levien</dc:creator></item><item><title>Scala Developer Journey into Rust - Part 7 : Type Classes</title><link>http://blog.madhukaraphatak.com/rust-scala-part-7/</link><description><![CDATA[Rust is one of the major programming languages that‚Äôs been getting popular in recent years. It has many advanced high level language features like Scala.This made me interested to learn Rust. So in this next series of blogs I will share my experience with Rust from a Scala developer point of view. I would like to explore how these two language approach things. I would like to explore the similarities and their differences. This is seventh post in the series. In this post, I will be talking about type classes. You can find all the other posts in the series here.]]></description><guid isPermaLink="false">3a482b07-e688-4b92-94e7-5bd2d87e9f66</guid><pubDate>Tue, 20 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Madhukara Phatak</dc:creator></item><item><title>Coverage Reports as a Code Reading Tool</title><link>https://www.joshmcguigan.com/blog/coverage-reports-code-reading-tool/</link><description><![CDATA[Coverage reports are widely used to visualize the lines of code which are covered by test cases. Often this is used in CI to block merge requests which lower test coverage by some metric. But coverage reports don‚Äôt have to be test coverage reports. In general, the idea of ‚Äúrun some code and see which lines are executed‚Äù can be applied to anything, not just the test cases.]]></description><guid isPermaLink="false">f4b11aa2-a9ac-4511-aa4d-d8d81f51ab79</guid><pubDate>Tue, 20 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Josh Mcguigan</dc:creator></item><item><title>Introduction</title><link>https://rust-lang.github.io/compiler-team/</link><description><![CDATA[A home for compiler team planning documents, meeting minutes, and other such things. If you‚Äôre interested in learning about how rustc works ‚Äì as well as advice on building the compiler, preparing a PR, and other similar topics ‚Äì check out the rustc-guide.]]></description><guid isPermaLink="false">6f824da5-4033-40da-994f-581a7909e50e</guid><pubDate>Sun, 18 Aug 2019 04:30:25 +0000</pubDate><dc:creator>Rust Lang Compiler Team</dc:creator></item><item><title>Using C Libraries in Rust</title><link>https://medium.com/dwelo-r-d/using-c-libraries-in-rust-13961948c72a</link><description><![CDATA[Today I want to dig into one of the difficulties we ran into while trying to rewrite our IoT Python code in Rust: specifically FFI, or the ‚ÄúForeign Function Interface‚Äù ‚Äî the bit that allows Rust to interact with other languages. When I tried to write Rust code to integrate with C libraries a year ago, the existing documents and guides often gave conflicting advice, and I had to stumble through the process on my own. This guide is intended to help future Rustaceans work through the process of porting C libraries to Rust, and familiarize the reader with the most common problems we encountered while doing the same.]]></description><guid isPermaLink="false">86fe455b-cfd7-472b-860b-2d969a8cd5ba</guid><pubDate>Sat, 17 Aug 2019 00:22:36 +0000</pubDate><dc:creator>Jeff Hiner</dc:creator></item><item><title>Rust std study series: Pin</title><link>https://ehsanmkermani.com/2019/08/16/rust-std-study-series-pin/</link><description><![CDATA[This time we dive into std::pin which has a dense documentation.]]></description><guid isPermaLink="false">db66d2c2-313a-4810-9a18-c802f98f5752</guid><pubDate>Fri, 16 Aug 2019 17:27:37 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Understanding Futures in Rust -- Part 2</title><link>https://www.viget.com/articles/understanding-futures-is-rust-part-2/</link><description><![CDATA[If you're familiar with promises in JavaScript and followed the last blog post you may have been confused about where the familiar combinators (then, catch, and finally) were in the previous post. You will find their equivalents in this post, and, by the end, the following code will compile. You will also gain an understanding of the types, traits, and underling concepts that make futures work.]]></description><guid isPermaLink="false">4bf39b49-7652-4132-8a42-c12c7d922ab9</guid><pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Joe Jackson</dc:creator></item><item><title>Announcing Rust 1.37.0</title><link>https://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html</link><description><![CDATA[The highlights of Rust 1.37.0 include referring to enum variants through type aliases, built-in cargo vendor, unnamed const items, profile-guided optimization, a default-run key in Cargo, and #[repr(align(N))] on enums. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">76cefd5b-2344-4629-84fb-5bf5c45c0ce0</guid><pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Updating to Async/Await</title><link>https://leshow.github.io/post/async_await/</link><description><![CDATA[We‚Äôre pleased to announce the release of the first Tokio alpha with async & await support. This includes updating all of the Tokio crates to use std::future instead of futures 0.1. It also includes adding async fn versions of the APIs.]]></description><guid isPermaLink="false">dac15914-213c-4397-8485-eb2156b0e88b</guid><pubDate>Mon, 12 Aug 2019 09:30:08 -0400</pubDate><dc:creator>Evan Cameron</dc:creator></item><item><title>Runtime Configuration Reloading</title><link>https://vorner.github.io/2019/08/11/runtime-configuration-reloading.html</link><description><![CDATA[A lot of programs need to read some kind of configuration at startup. But the challenge doesn‚Äôt end here. Some programs ‚Äí certainly not all, but some ‚Äí are long running. For these, restarting them to change configuration isn‚Äôt something you‚Äôd want to do. The unix daemon convention is to send a SIGHUP signal to the process.]]></description><guid isPermaLink="false">2938c850-88bc-4bec-b0fb-f2561f4a0b17</guid><pubDate>Sun, 11 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Parsing Rust Strings into Slices</title><link>https://wduquette.github.io/parsing-strings-into-slices/</link><description><![CDATA[A Rust String is a vector of bytes containing a UTF-8 string, which is an uneasy combination. You can‚Äôt simply index into a String: the compiler forbids it, because you‚Äôre far too likely to get one byte of a multi-byte UTF-8 char. Instead you need to use a Chars iterator to parse out the string character by character.]]></description><guid isPermaLink="false">318ffc1c-1f3c-4d9a-b5ea-edaa476d3438</guid><pubDate>Sat, 10 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Will Duquette</dc:creator></item><item><title>Follow-up to Method on Emulating Higher-Kinded Types (HKTs) in Rust</title><link>https://gist.github.com/edmundsmith/e09d5f473172066c0023ef84ee830cad</link><description><![CDATA[First off, thanks for all the comments and kind words on the original writeup; I've been meaning to follow up on some of the suggestions and write about the different ways to represent monads (and functors, HKTs, etc) that now exist, but a month of being busy has kind of gotten in the way (mainly with three new kittens!).

And for sure, I do not expect (nor do I want) this to become the norm for production-level Rust: rather, I hope that this can contribute to the foundations of programming with higher-level abstractions in Rust, somewhat like how early template metaprogramming in C++ and typeclass-constraint-unification metaprogramming in Haskell have contributed, perhaps indirectly, to later innovations in their respective languages and ecosystems that were much more reasoned, sound and usable.]]></description><guid isPermaLink="false">2a87f758-3eaf-4971-a00f-02f3175d0db5</guid><pubDate>Thu,  8 Aug 2019 11:44:35 +0000</pubDate><dc:creator>Edmund Smith</dc:creator></item><item><title>Await a minute, why bother?</title><link>https://docs.rs/dtolnay/0.0.5/dtolnay/macro._01__await_a_minute.html</link><description><![CDATA[Recently I have been retooling some core Rust libraries at $work to play nicely with native async/await syntax. This note covers my thoughts on why this feature is so important to our async codebase if it's "just" syntax sugar for a job that could just be done using raw Futures instead.]]></description><guid isPermaLink="false">902d33e4-a66a-479e-8758-f543083da639</guid><pubDate>Thu,  8 Aug 2019 00:00:00 +0000</pubDate><dc:creator>David Tolnay</dc:creator></item><item><title>My First Three Months With Rust</title><link>https://blog.aclysma.com/my-first-three-months-with-rust/</link><description><![CDATA[I‚Äôve used C++ professionally in games and simulations for over 10 years, and in the past few years I‚Äôve also used C# to build distributed backend systems. Lately, I‚Äôve been exploring Rust.]]></description><guid isPermaLink="false">27ce3b2b-a0fc-4cf2-ade4-1d4bcd1dabf7</guid><pubDate>Wed,  7 Aug 2019 19:13:41 +0000</pubDate><dc:creator>Philip Degarmo</dc:creator></item><item><title>My Thoughts on Rust&apos;s Future: A Positive Outlook</title><link>https://cprimozic.net/blog/my-thoughts-on-rusts-future/</link><description><![CDATA[I'm feeling really positive about Rust's prospects of popularity and wide-spread adoption in the future. I've been a part of the Rust community for three years now, and it feels like the stars are starting to align in order to let Rust jump into a position of dominance in the programming language world. There are several different, wide-spread, and mostly unrelated trends that I've noticed are all coming together with positive implications for Rust.]]></description><guid isPermaLink="false">ac36b146-f880-46e7-9f3f-819ab9daefa8</guid><pubDate>Sat,  3 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Casey Primozic</dc:creator></item><item><title>Minimum Safe Abstractions</title><link>https://llogiq.github.io/2019/08/01/unsafe.html</link><description><![CDATA[Recently, there‚Äôs been a lot of talk about unsafe in the Rust world, and how to deal with it. Let‚Äôs recap: Rust has a subset called ‚Äúsafe Rust‚Äù, with a few very neat guarantees, such as memory safety and freedom from data races. The superset that completes the language is called ‚Äúunsafe Rust‚Äù, and it still has a number of cool safeguards, but it also has an escape hatch to allow bending a few of them in order to let us write safe abstractions on top in much the same language.]]></description><guid isPermaLink="false">134835d4-c3ca-4ae7-bed7-eef5b69dcf44</guid><pubDate>Thu,  1 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Llogiq</dc:creator></item><item><title>Rust: safe and unsafe as theorems and axioms</title><link>https://iandouglasscott.com/2019/07/26/rust-safe-and-unsafe-as-theorems-and-axioms/</link><description><![CDATA[There is a fair amount of confusion about what unsafe means in Rust, as well as debate about how one should think about it. Recently I‚Äôve seen several blog posts like What is Rust‚Äôs unsafe?, The Temptation of Unsafe and Unsafe as a Human-Assisted Type System. I‚Äôm not really attempting to explain what is considered unsafe in Rust, which is explained by the reference. Nor am I going to try to answer the question of precisely when unsafe should be used and how often. My basic suggestion: we can think of unsafe in terms of mathematical axioms and theorems. This understanding is somewhere in between actual mathematical rigour and an analogy.]]></description><guid isPermaLink="false">398562a1-3ec5-4277-8a7c-5c3388fed5ba</guid><pubDate>Fri, 26 Jul 2019 15:37:00 -0700</pubDate><dc:creator>Ian Douglas Scott</dc:creator></item><item><title>Python vs Rust for Neural Networks</title><link>https://ngoldbaum.github.io/posts/python-vs-rust-nn/</link><description><![CDATA[In a previous post I introduced the MNIST dataset and the problem of classifying handwritten digits. In this post I‚Äôll be using the code I wrote in that post to port a simple neural network implementation to rust. My goal is to explore performance and ergonomics for data science workflows in Rust.]]></description><guid isPermaLink="false">d6e69577-47b1-4490-a336-a01b166fff6e</guid><pubDate>Fri, 26 Jul 2019 14:17:19 -0400</pubDate><dc:creator>Nathan Goldbaum</dc:creator></item><item><title>Unsafe as a Human-Assisted Type System</title><link>https://matklad.github.io/2019/07/25/unsafe-as-a-type-system.html</link><description><![CDATA[This is a short note about yet another way to look at Rust‚Äôs unsafe. Today, an interesting bug was found in rustc, which made me aware just how useful unsafe is for making code maintainable. The story begins a couple of months ago, when I was casually browsing through recent pull requests for rust-lang/rust. I was probably waiting for my code to compile at that moment :] Anyway, a pull request caught my attention, and, while I was reading the diff, I noticed a usage of unsafe.]]></description><guid isPermaLink="false">98583b20-bd88-4cad-8a18-5e375c6c369f</guid><pubDate>Thu, 25 Jul 2019 00:00:00 +0300</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>HOWTO: Replace mem::uninitialized with mem::MaybeUninit</title><link>https://www.reddit.com/r/rust/comments/cefgec/howto_replace_memuninitialized_with_memmaybeuninit/</link><description><![CDATA[The recent 1.36.0 release of Rust has brought a mem::MaybeUninit union that allows safer handling of possibly uninitialized data. MaybeUninit is a replacement of mem::uninitialized. Why? Because using mem::uninitialized it is damn easy to shoot yourself in the foot.]]></description><guid isPermaLink="false">ab2b1d95-83c2-4541-9f2d-bb5224d0b713</guid><pubDate>Fri, 19 Jul 2019 10:59:18 +0000</pubDate><dc:creator>Roman Proskuryakov</dc:creator></item><item><title>Rust for OOP - Closures</title><link>https://oribenshir.github.io/afternoon_rusting/blog/closures</link><description><![CDATA[Turning functions into first-class citizens in our programming languages is one of the major changes of the decade. Well, kind of. The concept, also known as lambda, is far from new. Functional programming languages had it from the very start, during the late ‚Äô50s. Even some of the object-oriented languages like Python had it quite early, back in 1994. However it became an official part of C++ only in 2011, and Java brought it even later in 2014. And with those two languages and many others, it became the norm, even for non-functional programming. As first-class citizens, functions can be saved as variables or transfer as arguments to functions easily.]]></description><guid isPermaLink="false">fd4779eb-f9f4-4c63-98c9-d7fe21fb6bac</guid><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Ori Ben-Shir</dc:creator></item><item><title>The Temptation of Unsafe</title><link>https://inejge.github.io/blog/2019/07/18/The-Temptation-of-Unsafe.html</link><description><![CDATA[Recently, another round of discussion concerning the use of Rust‚Äôs unsafe features in the Actix web framework happened, or rather erupted, on Reddit, even more heated and acrimonious than the first time around. (I am not linking to any of the threads, as I believe that they don‚Äôt need any more exposure. Use your favorite search engine.) This proves, if more proof is needed, that people hold passionate beliefs about the matter.]]></description><guid isPermaLink="false">a0f3d2bb-e52e-440b-809f-169497494769</guid><pubDate>Thu, 18 Jul 2019 00:00:00 +0000</pubDate><dc:creator>inejge</dc:creator></item><item><title>Perils of Constructors</title><link>https://matklad.github.io/2019/07/16/perils-of-constructors.html</link><description><![CDATA[One of my favorite blog posts about Rust is Things Rust Shipped Without by Graydon Hoare. To me, footguns that don‚Äôt exist in a language are usually more important than expressiveness. In this slightly philosophical essay, I want to tell about a missing Rust feature I especially like: constructors.]]></description><guid isPermaLink="false">85b61a6b-91ab-4194-a236-43a690cc3f2f</guid><pubDate>Tue, 16 Jul 2019 00:00:00 +0300</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>&quot;What The Hardware Does&quot; is not What Your Program Does: Uninitialized Memory</title><link>https://www.ralfj.de/blog/2019/07/14/uninit.html</link><description><![CDATA[This post is about uninitialized memory, but also about the semantics of highly optimized ‚Äúlow-level‚Äù languages in general. I will try to convince you that reasoning by ‚Äúwhat the hardware does‚Äù is inherently flawed when talking about languages such as Rust, C or C++. These are not low-level languages. I have made this point before in the context of pointers; this time it is going to be about uninitialized memory.]]></description><guid isPermaLink="false">3161bc30-9df4-4273-8ff7-301ea0426d9f</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Ralf Jung</dc:creator></item><item><title>What Is Rust&apos;s unsafe?</title><link>https://nora.codes/post/what-is-rusts-unsafe/</link><description><![CDATA[I‚Äôve seen a lot of misconceptions around what the unsafe keyword means for the utility and validity of Rust and its marketing as a ‚Äúsafe systems language‚Äù. The truth is a lot more complicated than a single pithy tweet can possibly sum up, unfortunately; here it is as I see it.

Basically, the unsafe keyword does not turn off the advanced type system that keeps Rust code honest. It only allows a few select ‚Äúsuperpowers‚Äù, like dereferencing raw pointers. It is used to implement safe abstractions over a fundamentally unsafe world so that the majority of Rust code can use those abstractions and avoid memory unsafety.]]></description><guid isPermaLink="false">a05e51b1-ea5d-4365-949c-80c0c3e48d54</guid><pubDate>Fri, 12 Jul 2019 10:00:00 -0700</pubDate><dc:creator>Leonora Tindall</dc:creator></item><item><title>Testable Component Design in Rust</title><link>http://iextendable.com/2019/07/12/testable-component-design-in-rust/</link><description><![CDATA[I consider myself an advanced beginner in Rust. There is still much I‚Äôm wrapping my head around‚Äìand I still get caught off guard by the ‚Äúmove‚Äù and ‚Äúmutability‚Äù rules Rust enforces. However, in keeping with my personal emphasis, I‚Äôve devoted my efforts to learning how to create automated tests in Rust. The below guidelines are not exhaustive, but represent my learning so far. Feedback is welcome!]]></description><guid isPermaLink="false">20553a37-476d-45bb-8180-3de54aa932cd</guid><pubDate>Fri, 12 Jul 2019 13:57:01 +0000</pubDate><dc:creator>Chris McKenzie</dc:creator></item><item><title>AiC: Unbounded queues and lang design</title><link>http://smallcultfollowing.com/babysteps/blog/2019/07/10/aic-unbounded-queues-and-lang-design/</link><description><![CDATA[I have been thinking about how language feature development works in Rust1. I wanted to write a post about what I see as one of the key problems: too much concurrency in our design process, without any kind of ‚Äúback-pressure‚Äù to help keep the number of ‚Äúopen efforts‚Äù under control. This setup does enable us to get a lot of things done sometimes, but I believe it also leads to a number of problems.

Although I don‚Äôt make any proposals in this post, I am basically advocating for changes to our process that can help us to stay focused on a few active things at a time. Basically, incorporating a notion of capacity such that, if we want to start something new, we either have to finish up with something or else find a way to grow our capacity.]]></description><guid isPermaLink="false">6d02baa8-8fcd-45fa-9f96-d36a635a2379</guid><pubDate>Wed, 10 Jul 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Async-await status report #2</title><link>http://smallcultfollowing.com/babysteps/blog/2019/07/08/async-await-status-report-2/</link><description><![CDATA[I wanted to give an update on the status of the ‚Äúasync-await foundations‚Äù working group. This post aims to cover three things: the ‚Äúasync await MVP‚Äù that we are currently targeting; how that fits into the bigger picture; and how you can help, if you‚Äôre so inclined;]]></description><guid isPermaLink="false">815aa1ce-d98e-484c-8dbf-a91fce9a4167</guid><pubDate>Mon,  8 Jul 2019 00:00:00 -0400</pubDate><dc:creator>Niko Matsakis</dc:creator></item><item><title>Method for Emulating Higher-Kinded Types in Rust</title><link>https://gist.github.com/edmundsmith/855fcf0cb35dd467c29a9350481f0ecf</link><description><![CDATA[I've been fiddling about with an idea lately, looking at how higher-kinded types can be represented in such a way that we can reason with them in Rust here and now, without having to wait a couple years for what would be a significant change to the language and compiler.

There have been multiple discussions on introducing higher-ranked polymorphism into Rust, using Haskell-style Higher-Kinded Types (HKTs) or Scala-looking Generalised Associated Types (GATs). The benefit of higher-ranked polymorphism is to allow higher-level, richer abstractions and pattern expression than just the rank-1 polymorphism we have today.]]></description><guid isPermaLink="false">55481592-1914-40bc-a2be-f7be9702c5c7</guid><pubDate>Sun,  7 Jul 2019 20:47:09 +0000</pubDate><dc:creator>Edmund Smith</dc:creator></item><item><title>Rust vs C++ - Implementing a Neural Network</title><link>http://nicktasios.nl/posts/rust-vs-c%2B%2B-implementing-a-neural-network.html</link><description><![CDATA[I first learned Rust back in 2014, before it was stable. Rust is definitely a very interesting language so I have decided to revisit it by programming a simple neural network. For comparison, I also implemented the network in C++, the language I'm looking to replace.]]></description><guid isPermaLink="false">649aefcc-0d0c-4e1c-b2d2-337d3110c606</guid><pubDate>Sat,  6 Jul 2019 19:18:48 +0200</pubDate><dc:creator>Nick Tasios</dc:creator></item><item><title>Functional Programming Jargon in Rust</title><link>https://functional.works-hub.com/learn/functional-programming-jargon-in-rust-1b555</link><description><![CDATA[Github Repository: https://github.com/JasonShin/functional-programming-jargon.rsFunctional programming (FP) provides many advantages, and its popula...]]></description><guid isPermaLink="false">3d786e81-3097-48f1-aea9-9a86473f6957</guid><pubDate>Fri,  5 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Jason Shin</dc:creator></item><item><title>Cargo --offline ‚úàÔ∏è</title><link>https://www.ncameron.org/blog/cargo-offline/</link><description><![CDATA[Rust 1.36 is released on the 4th July and includes a bunch of new stuff. This blog post is about one newly stable feature in Cargo: --offline.]]></description><guid isPermaLink="false">4ab235dc-fc27-4dfe-aefc-1bcc16a23199</guid><pubDate>Thu,  4 Jul 2019 08:13:57 +0000</pubDate><dc:creator>Nick Cameron</dc:creator></item><item><title>Rust std study series: alloc</title><link>https://ehsanmkermani.com/2019/07/03/rust-std-study-series-alloc/</link><description><![CDATA[Let‚Äôs get deep into std::alloc! The very basic need for any program to compile and execute is having access to either physical memory or virtual memory. An allocator is responsible for providing such an access. You can think of an allocator as a service, taking some sort of requests and either giving back a (pointer) to block of memory or some errors. In Rust, a request is a Layout i.e. some meta-data about how the memory we want is supposed to take up the space.]]></description><guid isPermaLink="false">a11e4440-7ad1-4e28-95d7-db6cc8a4544b</guid><pubDate>Thu,  4 Jul 2019 00:20:38 +0000</pubDate><dc:creator>Ehsan M. Kermani</dc:creator></item><item><title>Announcing Rust 1.36.0</title><link>https://blog.rust-lang.org/2019/07/04/Rust-1.36.0.html</link><description><![CDATA[This release brings many changes, including the stabilization of the Future trait, the alloc crate, the MaybeUninit<T> type, NLL for Rust 2015, a new HashMap<K, V> implementation, and --offline support in Cargo. Read on for a few highlights, or see the detailed release notes for additional information.]]></description><guid isPermaLink="false">75040309-d3a6-4941-a8d1-28c6f8bdfc19</guid><pubDate>Thu,  4 Jul 2019 00:00:00 +0000</pubDate><dc:creator>The Rust Release Team</dc:creator></item><item><title>Status of rust-analyzer: Achievements and Open Collective</title><link>https://ferrous-systems.com/blog/rust-analyzer-status-opencollective/</link><description><![CDATA[rust-analyzer is an experimental compiler frontend for the Rust programming language. The ultimate goal for this project is to provide the perfect IDE experience for Rust, with all IDE features working flawlessly while editing code. This post talks about what happened to rust-analyzer in between the all-hands and today, discusses future plans, and also announces the rust-analyzer Open Collective.]]></description><guid isPermaLink="false">09564ee8-19af-4b03-95c4-b231ffd7f24f</guid><pubDate>Mon,  1 Jul 2019 22:00:00 +0000</pubDate><dc:creator>Aleksey Kladov</dc:creator></item><item><title>Rust modules vs files</title><link>https://amos.me/blog/2019/rust-modules-vs-files/</link><description><![CDATA[A while back, I asked on Twitter what people found confusing in Rust, and one of the top topics was ‚Äúhow the module system maps to files‚Äù. I remember struggling with that a lot when I first started Rust, so I‚Äôll try to explain it in a way that makes sense to me.]]></description><guid isPermaLink="false">ec53084d-522d-4916-90b2-c8adda4b75f2</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>amos</dc:creator></item><item><title>One Program Written in Python, Go, and Rust</title><link>http://www.nicolas-hahn.com/python/go/rust/programming/2019/07/01/program-in-python-go-rust/</link><description><![CDATA[This is a subjective, primarily developer-ergonomics-based comparison of the three languages from the perspective of a Python developer, but you can skip the prose and go to the code samples, the performance comparison if you want some hard numbers, the takeaway for the tl;dr, or the Python, Go, and Rust diffimg implementations.]]></description><guid isPermaLink="false">a7b2c09d-06ca-4ae2-89c2-70bf78282396</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Nicolas Hahn</dc:creator></item><item><title>Sharing references between Python and Rust</title><link>https://raphaelgomes.dev/blog/articles/2019-07-01-sharing-references-between-python-and-rust.html</link><description><![CDATA[In 2018, the Mercurial project decided to use Rust to improve performance and maintainability of previous high-performance code. We have faced some interesting challenges when bridging the Python implementation with the new Rust code, and this is one that I have not found any literature about.]]></description><guid isPermaLink="false">38abc54a-6b27-48ec-8789-363ead337d8a</guid><pubDate>Mon,  1 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Rapha√´l Gom√®s</dc:creator></item><item><title>Writing a small ray tracer in Rust and Zig</title><link>https://nelari.us/post/raytracer_with_rust_and_zig/</link><description><![CDATA[The two languages that I spent most of my time daydreaming about writing code in are Rust and Zig. Would the lack of features in Zig make me more or less productive than with Rust‚Äôs feature overload? Which language is more enjoyable to use for writing a small, self-contained computer graphics project?  To find out, I decided to implement the same simple project in both languages: a small ray tracer, following the book Ray Tracing in One Weekend.]]></description><guid isPermaLink="false">6e2a2811-942b-4e62-b173-6d2b0d3e0acd</guid><pubDate>Thu, 27 Jun 2019 20:00:00 +0200</pubDate><dc:creator>Johann Muszynski</dc:creator></item></channel></rss>