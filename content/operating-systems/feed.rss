<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Operating Systems</title><link>https://readrust.net/</link><description>Operating Systems posts on Read Rust</description><item><title>Neotron - The Embedded Rust Home Computer Platform</title><link>https://neotron-compute.github.io/Neotron-Book/</link><description><![CDATA[Neotron is an attempt to make computers simple again, whilst also taking advantage of the very latest in programming language development. It is based around four simple concepts: The ARM Thumb-v7M instruction set, A standardised OS interface, A standardised BIOS interface, and Use of the Rust Programming Language.]]></description><guid isPermaLink="false">f178fe2d-82b8-4e04-ad1e-6e90bc4299c3</guid><pubDate>Mon, 11 Nov 2019 05:07:11 +0000</pubDate><dc:creator>Jonathan Pallant</dc:creator></item><item><title>iou: Rust bindings for liburing</title><link>https://boats.gitlab.io/blog/post/iou/</link><description><![CDATA[Today Iâ€™m releasing a library called iou. This library provides idiomatic Rust bindings to the C library called liburing, which itself is a higher interface for interacting with the io_uring Linux kernel interface. Here are the answers to some questions I expect that may provoke.

What is io_uring? io_uring is an interface added to the Linux kernel in version 5.1. Concurrent with that, the primary maintainer of that interface has also been publishing a library for interacting with it called liburing.]]></description><guid isPermaLink="false">eab14a89-9177-44ce-8259-07c6ae33bdfa</guid><pubDate>Fri,  8 Nov 2019 00:00:00 +0000</pubDate><dc:creator>boats</dc:creator></item><item><title>Using Rust in Windows</title><link>https://msrc-blog.microsoft.com/2019/11/07/using-rust-in-windows/</link><description><![CDATA[This blog describes part of the story of Rust adoption at Microsoft. Recently, Iâ€™ve been tasked with an experimental rewrite of a low-level system component of the Windows codebase (sorry, we canâ€™t say which one yet). Instead of rewriting the code in C++, I was asked to use Rust, a memory-safe alternative. Though the project is not yet finished, I can say that my experience with Rust has been generally positive. Itâ€™s a good choice for those looking to avoid common mistakes that often lead to security vulnerabilities in C++ code bases. ]]></description><guid isPermaLink="false">fe4ddd77-07fd-4693-a8e4-684b4b0d825c</guid><pubDate>Thu,  7 Nov 2019 16:11:27 +0000</pubDate><dc:creator>Adam Burch</dc:creator></item><item><title>Putting Rust in the kernel with eBPF</title><link>https://blog.redsift.com/labs/putting-rust-in-the-kernel-with-ebpf/</link><description><![CDATA[During the product development process monitoring our pipelines proved challenging, and we wanted more visibility into our containers. After a short period of exploration, we found that eBPF would address most of the pain points and dark spots we were encountering.

There was one catch: no eBPF tooling would help us deploy and maintain new probes within our small, but focused ops team. BCC, while great for tinkering, requires significant effort to roll out to production. It also makes it difficult to integrate our toolkit into our usual CI/CD deployment models.

Faced with this dilemma, we decided the only option was for us to write our own Rust-based agent that integrated well with our testing and deployment strategies.]]></description><guid isPermaLink="false">f735529c-9db9-454e-802d-82e7367e6b92</guid><pubDate>Thu,  7 Nov 2019 11:34:52 +0000</pubDate><dc:creator>Peter Parkanyi</dc:creator></item><item><title>My Rust adventure begins: building the WinRT language projection for Rust</title><link>https://kennykerr.ca/2019/11/05/rust/</link><description><![CDATA[I have come to the point with C++/WinRT where I am largely satisfied with how it works and leverages C++ to the best of its ability. There is always room for improvement and I will continue to evolve and optimize C++/WinRT as the C++ language itself advances. But as a technology, the Windows Runtime has always been about more than just one language and we have started working on a few different projects to add support for various languages. None of these efforts could however draw me away from C++â€¦ that is until Rust showed up on my radar.

Rust is an intriguing language for me. It closely resembles C++ in many ways, hitting all the right notes when it comes to compilation and runtime model, type system and deterministic finalization, that I could not help but get a little excited about this fresh new take on language design. And so it is that I have started building the WinRT language projection for Rust.]]></description><guid isPermaLink="false">94453690-596e-423d-afa4-6fbcb91594a1</guid><pubDate>Tue,  5 Nov 2019 15:05:41 +0000</pubDate><dc:creator>Kenny Kerr</dc:creator></item><item><title>Mental experiments with io_uring</title><link>https://vorner.github.io/2019/11/03/io-uring-mental-experiments.html</link><description><![CDATA[Recently, a new Linux kernel interface, called io_uring, appeared. I have been looking into it a little bit and I canâ€™t help but wondering about it. Unfortunately, Iâ€™ve had only enough time to keep thinking and reading about it. Nevertheless, Iâ€™ve decided to share what Iâ€™ve been thinking about so far in case someone wants to write some actual code and experiment. Basically, I have an idea for a crate and Iâ€™d love someone else to write it ðŸ˜‡.]]></description><guid isPermaLink="false">2fa36367-ad2e-4773-a3c8-9eea6f166a01</guid><pubDate>Sun,  3 Nov 2019 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Using Type-Level Programming in Rust to Make Safer Hardware Abstractions</title><link>https://blog.auxon.io/2019/10/25/type-level-registers/</link><description><![CDATA[In the world of systems programming where one may find themselves writing hardware drivers or interacting directly with memory-mapped devices, that interaction is almost always through memory-mapped registers provided by the hardware. We typically interact with these things through bitwise operations on some fixed-width numeric type.]]></description><guid isPermaLink="false">1f8ce13c-5661-4d07-aad2-11ea948a5a16</guid><pubDate>Fri, 25 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Dan Pittman</dc:creator></item><item><title>All you need to know about KVM userspace</title><link>https://www.redhat.com/en/blog/all-you-need-know-about-kvm-userspace</link><description><![CDATA[QEMU and libvirt form the backend of the Red Hat userspace virtualization stack: they are used by our KVM-based products and by several applications included in Red Hat Enterprise Linux, such as virt-manager, libguestfs and GNOME Boxes.]]></description><guid isPermaLink="false">207946d6-53c9-4c01-a305-d0cc041d9988</guid><pubDate>Thu, 24 Oct 2019 00:00:00 +0000</pubDate><dc:creator>Paolo Bonzini</dc:creator></item><item><title>Dealing with process termination in Linux (with Rust examples)</title><link>https://iximiuz.com/en/posts/dealing-with-processes-termination-in-Linux/</link><description><![CDATA[Play with Linux process termination exploring such interesting features as PR_SET_CHILD_SUBREAPER and PR_SET_PDEATHSIG.]]></description><guid isPermaLink="false">a0e97cd5-91b6-445b-aa09-05bd4fbcdb75</guid><pubDate>Sun, 20 Oct 2019 13:00:00 +0000</pubDate><dc:creator>Ivan Velichko</dc:creator></item><item><title>Making a RISC-V Operating System using Rust</title><link>http://osblog.stephenmarz.com/index.html</link><description><![CDATA[ RISC-V ("risk five") and the Rust programming language both start with an R, so naturally they fit together. In this blog, we will write an operating system targeting the RISC-V architecture in Rust (mostly). If you have a sane development environment for RISC-V, you can skip the setup parts right to bootloading. Otherwise, it'll be fairly difficult to get started.

This tutorial will progressively build an operating system from start to something that you can show your friends or parents -- if they're significantly young enough. Since I'm rather new at this I decided to make it a "feature" that each blog post will mature as time goes on. More details will be added and some will be clarified.]]></description><guid isPermaLink="false">6712ac58-9b5c-43de-bcf5-79548cb8c59d</guid><pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate><dc:creator>Stephen Marz</dc:creator></item><item><title>Writing Linux Kernel Module in Rust</title><link>https://github.com/lizhuohua/linux-kernel-module-rust</link><description><![CDATA[We designed a framework to help developers to quickly build device drivers in Rust. We also utilized Rustâ€™s security features to provide several useful infrastructures for developers so that they can easily handle kernel memory allocation and concurrency management, at the same time, some common bugs (e.g. use-after-free) can be alleviated.

We demonstrate the generality of our framework by implementing a real-world device driver on Raspberry Pi 3, and our evaluation shows that device drivers generated by our framework have acceptable binary size for canonical embedded systems and the runtime overhead is negligible.]]></description><guid isPermaLink="false">8ae2d3d4-bbd0-4e9b-8bb8-f1ff4703b0cf</guid><pubDate>Mon,  9 Sep 2019 06:31:16 +0000</pubDate><dc:creator>Li Zhuohua</dc:creator></item><item><title>Rsoc: Improving Ion&apos;s UX, week 5 and 6</title><link>https://www.redox-os.org/news/rsoc-ion-ux-4-5/</link><description><![CDATA[The Redox official website]]></description><guid isPermaLink="false">a14dd34c-7e7d-4040-9b8f-e8708df5447d</guid><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><dc:creator>AdminXVII</dc:creator></item><item><title>The New Firmware Manager: Updating firmware across Linux distributions</title><link>https://blog.system76.com/post/187072707563/the-new-firmware-manager-updating-firmware-across</link><description><![CDATA[Over the past few months, System76 has been developing a simple, easy-to-use tool for updating firmware on Pop!_OS and System76 hardware. Today, weâ€™re excited to announce that you can now check and update firmware through Settings on Pop!_OS, and through the firmware manager GTK application on System76 hardware running other Debian-based distributions.]]></description><guid isPermaLink="false">9e2dbb14-ceba-4562-a577-a218c1e652f8</guid><pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate><dc:creator>System76</dc:creator></item><item><title>The Firmware Manager</title><link>https://mmstick.keybase.pub/firmware-manager/</link><description><![CDATA[In the last few weeks, I've been working on a new solution to firmware management on the Linux desktop. A generic framework which combines fwupd and system76-firmware; with a GTK frontend library and application; that is written in Rust.]]></description><guid isPermaLink="false">50da2cb2-9123-4128-bf10-db666256d699</guid><pubDate>Fri,  2 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Michael Aaron Murphy</dc:creator></item><item><title>RSoC: Improving Ion&apos;s UX, week 4 - Autocompleting under 1ms</title><link>https://www.redox-os.org/news/rsoc-ion-ux-3/</link><description><![CDATA[The Redox official website]]></description><guid isPermaLink="false">0045c68b-1c6b-4aee-9704-5471d5dd9758</guid><pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate><dc:creator>AdminXVII</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 5</title><link>https://www.redox-os.org/news/rsoc-ptrace-5/</link><description><![CDATA[This week Iâ€™ve decided to skip trying to get GDB working for now (there are so many issues itâ€™ll take forever to solve them), and instead decided to finally give focus to the final concerns I had about ptrace. Most changes this week was related to getting decent behavior of child processes, although the design feelsâ€¦ suboptimal, somehow (not sure why), so I feel I must be able to improve it better later.

Another change was security: Tracers running as a non-root user can now in addition to only tracing processes running as the same user, only trace processes that are directly or indirectly children of the tracer. In the future this can easily be allowed with some kind of capability, but currently in Redox there isnâ€™t a capability-like system other than the simple (but really powerful) namespacing system which sadly I donâ€™t think can be used for this.]]></description><guid isPermaLink="false">94badc73-4b58-487c-88de-ce68562f9f19</guid><pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 4</title><link>https://www.redox-os.org/news/rsoc-ptrace-4/</link><description><![CDATA[Once again, last weeks action was merged, which means the full ptrace feature was merged, and itâ€™s time to start tackling the final issues which I have delayed for so long. But, before that, I decided to try to get some basic ptrace compatibility in relibc, so we could see just how far away software like gdb is from being ported, and what concerns I havenâ€™t thought about yet. redox-nix update: That said, I took a little break from the madness, to instead lay my focus on another interesting problem: Newer redoxer couldnâ€™t be compiled using carnix, because of some dependency that used a cargo feature carnix didnâ€™t support. Let me first explain what carnix is, and why this is a problem.]]></description><guid isPermaLink="false">c7551d1c-be90-4dd7-be38-5fcb78c51ef0</guid><pubDate>Sat, 13 Jul 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 3</title><link>https://www.redox-os.org/news/rsoc-ptrace-3/</link><description><![CDATA[Before I dive in to this weekâ€™s actions, I am pleased to announce that all the last weeksâ€™ work is merged! This merge means you can now experiment with basic ptrace functionality using only basic registers and PTRACE_SYSCALL/PTRACE_SINGLESTEP. I have already opened the second PR in the batch: Ptrace memory reading and floating point registers support which will supply the â€œfinal bitsâ€ of the initial implementation, before all the nitpicking of final concerns can start (not to underestimate the importance and difficulty of these nitpicks - there are some areas of ptrace that arenâ€™t even thought about yet and those will need tending to)! I will comment on these changes in this blog post, as there are some interesting things going on!]]></description><guid isPermaLink="false">dc58ea4c-1cea-4142-b9e7-00e066527e35</guid><pubDate>Sun,  7 Jul 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>RSoC: Ion as a Library, week 5</title><link>https://www.redox-os.org/news/rsoc-ion-lib-4/</link><description><![CDATA[Wrapping up the Ion as a library project. It is now possible to embed Ion in any Rust application. Ion takes any Read instance and can execute it (so yes, it is possible to run Ion without ever collecting the scriptâ€™s binary stream). It takes care of expanding the input and managing the running applications in an efficient manner, with a comprehensive set of errors. Ion is now the rust-based, pipe-oriented liblua alternative.]]></description><guid isPermaLink="false">6b3f54a7-e579-456f-8ee8-7753db3f7ee4</guid><pubDate>Sun,  7 Jul 2019 00:00:00 +0000</pubDate><dc:creator>AdminXVII</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 2</title><link>https://www.redox-os.org/news/rsoc-ptrace-2/</link><description><![CDATA[The next step in the journey of ptrace was to bite the bullet (or at least I thought) and implement system-call tracing. Since the kernel must be able to handle system-calls of processes, itâ€™s quite obvious that the way to set a breakpoint should involve the kernel, running in the context of the tracee, should notify the tracer and wait. So the biggest challenge would be to figure out how kernel synchronization worked.]]></description><guid isPermaLink="false">a3749f41-8d22-4fa8-9f5d-bb1e699f333c</guid><pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>Writing an OS in Rust: Heap Allocation</title><link>https://os.phil-opp.com/heap-allocation/</link><description><![CDATA[This post adds support for heap allocation to our kernel. First, it gives an introduction to dynamic memory and shows how the borrow checker prevents common allocation errors. It then implements the basic allocation interface of Rust, creates a heap memory region, and sets up an allocator crate. At the end of this post all the allocation and collection types of the built-in alloc crate will be available to our kernel.]]></description><guid isPermaLink="false">cd714c38-04f4-4e7c-a98e-4af4eb7d7464</guid><pubDate>Wed, 26 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>RSoC: Implementing ptrace for Redox OS - part 1</title><link>https://www.redox-os.org/news/rsoc-ptrace-1/</link><description><![CDATA[After having a pretty clear goal to meet specified by the RFC, time to get things moving. I started with what I thought would be low hanging fruit: Reading the registers of another process. It ended up being more difficult than I thought, but it ended up being really interesting and I want to share it with you :)]]></description><guid isPermaLink="false">25660960-3e2c-44ba-a511-2dd73afc6a32</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>Poking the macOS IO Kit with Rust</title><link>https://svartalf.info/posts/2019-05-31-poking-the-macos-io-kit-with-rust/</link><description><![CDATA[How to fetch batteries information from the macOS APIs with Rust]]></description><guid isPermaLink="false">da8a8064-82b9-4b6f-a37e-d8560a353283</guid><pubDate>Fri, 31 May 2019 00:00:00 +0000</pubDate><dc:creator>Nikita Kuznetsov</dc:creator></item><item><title>Rust&apos;s Bindgen + Fuse in 2019</title><link>https://dev.to/kdrakon/rust-s-bindgen-fuse-in-2019-2e8l</link><description><![CDATA[I will quickly show how I got bindgen (https://rust-lang.github.io/rust-bindgen) to generate the bindings to Fuse (libfuse) with the current stable1 release of Rust. By doing so, this should demonstrate how to bootstrap writing your own Fuse file system in Rust.

I do realise that there are some crates that already exist that aid in making Fuse drivers in Rust, but this was more or less an excuse to also try out bindgen, which I don't believe those existing libraries utilise.]]></description><guid isPermaLink="false">6abeffb3-1d06-4642-9a7d-9c089fd1a030</guid><pubDate>Thu, 23 May 2019 03:56:28 +0000</pubDate><dc:creator>Sean Policarpio</dc:creator></item><item><title>Manticore Operating System</title><link>https://github.com/manticoreos/manticore</link><description><![CDATA[Manticore is a research operating system, written in Rust, with the aim of exploring the parakernel OS architecture.

The OS is increasingly a bottleneck for server applications that want to take maximum advantage of the hardware. Many traditional kernel interfaces (such as in POSIX) were designed when I/O was significantly slower than the CPU. However, today I/O is getting faster, but single-threaded CPU performance has stagnated. For example, a 40 GbE NIC can receive a cache-line sized packet faster than the CPU can access its last-level cache (LLC), which makes it tricky for an OS to keep up with packets arriving from the network. Similarly, non-volatile memory (NVM) access speed is getting closer to DRAM speeds, which challenges OS abstractions for storage.

To address this OS bottleneck, server applications are increasingly adopting kernel-bypass techniques. For example, the Seastar framework is an OS implemented in userspace, which implements its own CPU and I/O scheduler, and bypasses the Linux kernel as much as it can. Parakernel is an OS architecture that eliminates many OS abstractions (similar to exokernels) and partitions hardware resources (similar to multikernels) to facilitate high-performance server application with increased application-level parallelism and predictable tail latency.]]></description><guid isPermaLink="false">0650fe18-12a0-40f4-916f-1a5c2464b9d5</guid><pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate><dc:creator>Pekka Enberg</dc:creator></item><item><title>rust-hypervisor-firmware</title><link>https://github.com/intel/rust-hypervisor-firmware/blob/master/README.md</link><description><![CDATA[This repository contains a simple KVM firmware that is designed to be launched from anything that supports loading ELF binaries and running them with the Linux kernel loading standard. The ultimate goal is to be able to use this "firmware" to be able to load a bootloader from within a disk image.]]></description><guid isPermaLink="false">03308e2f-7a8e-4162-8c4e-4bffd1138c51</guid><pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate><dc:creator>Intel</dc:creator></item><item><title>Writing an OS in Rust: Testing</title><link>https://os.phil-opp.com/testing/</link><description><![CDATA[This post explores unit and integration testing in no_std executables. We will use Rust's support for custom test frameworks to execute test functions inside our kernel. To report the results out of QEMU, we will use different features of QEMU and the bootimage tool.]]></description><guid isPermaLink="false">2766c75e-b1e0-4ae9-9cc2-8c3a8476bb57</guid><pubDate>Sat, 27 Apr 2019 23:03:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Writing UEFI application in Rust from scratch</title><link>https://medium.com/garasubo/writing-uefi-application-in-rust-from-scratch-882bf35a4d63</link><description><![CDATA[Recently, x86_64-unknown-uefi target was added into Rust mainline (https://github.com/rust-lang/rust/pull/56769). So, I tried to write UEFI application with this update. There exists an awesome crate, uefi-rs, which provides Rust interface for UEFI application. However, this is my first time to write UEFI application, so to understand what happens in it, I didnâ€™t use any existing crate.]]></description><guid isPermaLink="false">99bfc2e1-cc1f-4047-941f-627f7e222d75</guid><pubDate>Sun, 31 Mar 2019 08:31:22 +0000</pubDate><dc:creator>garasubo (ã‚¬ãƒ©ã‚¹ãƒœãƒ¼)</dc:creator></item><item><title>Redox OS 0.5.0</title><link>https://www.redox-os.org/news/release-0.5.0/</link><description><![CDATA[It has been one year and four days since the last release of Redox OS! In this time, we have been hard at work improving the Redox ecosystem. Much of this work was related to relibc, a new C library written in Rust and maintained by the Redox OS project, and adding new packages to the cookbook. We are proud to report that we have now far exceeded the capabilities of newlib, which we were using as our system C library before. We have added many important libraries and programs, which you can see listed below.]]></description><guid isPermaLink="false">c3e2f0b2-713e-4ab5-9126-103233acb271</guid><pubDate>Sun, 24 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Jeremy Soller</dc:creator></item><item><title>Writing an OS in Rust - Paging Implementation</title><link>https://os.phil-opp.com/paging-implementation/</link><description><![CDATA[This post shows how to implement paging support in our kernel. It first explores different techniques to make the physical page table frames accessible to the kernel and discusses their respective advantages and drawbacks. It then implements an address translation function and a function to create a new mapping.]]></description><guid isPermaLink="false">8d10af6d-6142-4201-87d6-32148ac9079c</guid><pubDate>Thu, 14 Mar 2019 21:03:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>This Week in Pop!_OS 1</title><link>https://pop-planet.info/2019/02/this-week-in-pop/</link><description><![CDATA[This will be the first in a series of weekly updates on progress made in the development of Pop!_OS. Thus, this will only contain content pertaining specifically to Pop!_OS, though at times there may be some overlap with the hardware side of System76.]]></description><guid isPermaLink="false">c8769017-9667-4bad-82c6-e43ec7391182</guid><pubDate>Thu, 28 Feb 2019 00:20:54 +0000</pubDate><dc:creator>Michael Murphy</dc:creator></item><item><title>Cross-compiling Rust code to Minix</title><link>https://iandouglasscott.com/2019/02/18/cross-compiling-rust-code-to-minix/</link><description><![CDATA[Iâ€™ve decided to take a look at Minix, which is an interesting microkernel OS. Naturally after building Minix from git, the first thing I decided to try was porting Rustâ€™s std to Minix so I could cross-compile Rust programs from Linux to run under Minix. Okay, I suppose I could have started with something else, but porting Rust software and modifying the platform-depending part of std is something I have experience with from working on Redox OS. And Rust really isnâ€™t that hard to port.]]></description><guid isPermaLink="false">2c73855c-6079-427a-b075-4c07ed3cec23</guid><pubDate>Mon, 18 Feb 2019 13:00:00 -0800</pubDate><dc:creator>Ian Douglas Scott</dc:creator></item><item><title>Creating ðŸŒŠ web-server .deb binary with Rust</title><link>https://gill.net.in/posts/creating-web-server-deb-binary-with-rust/</link><description><![CDATA[We are going to make a demo linux web-server with systemd, config file and installable .deb binary in Rust.]]></description><guid isPermaLink="false">2b4a2862-e8ba-427b-aa27-c206356f5700</guid><pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Harry Gill</dc:creator></item><item><title>Writing an OS in Rust - Introduction to Paging</title><link>https://os.phil-opp.com/paging-introduction/</link><description><![CDATA[This post introduces paging, a very common memory management scheme that we will also use for our operating system. It explains why memory isolation is needed, how segmentation works, what virtual memory is, and how paging solves memory fragmentation issues. It also explores the layout of multilevel page tables on the x86_64 architecture.]]></description><guid isPermaLink="false">b88f26ba-23c6-4d9b-9559-7ccc6477c7af</guid><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Bootstrapping Rust</title><link>https://www.gnu.org/software/guix/blog/2018/bootstrapping-rust/</link><description><![CDATA[It has been a long-standing tradition to develop a language far enough to be able to write the language's compiler in the same language, and Rust does the same. Rust is nowadays written in Rust. We've tracked down the earlier Rust versions, which were written in OCaml, and were planning to use these to bootstrap Rust. But in parallel, John Hudge (Mutabah) developed a Rust compiler, called "mrustc", written in C++. mrustc is now good enough to compile Rust 1.19.0. Using mrustc, we were able to build Rust entirely from source with a bootstrap chain]]></description><guid isPermaLink="false">6bf8dccd-51b6-4dcb-a9eb-e38923d28a2c</guid><pubDate>Tue, 11 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Danny Milosavljevic</dc:creator></item><item><title>Hardware Interrupts | Writing an OS in Rust</title><link>https://os.phil-opp.com/hardware-interrupts/</link><description><![CDATA[In this post we set up the programmable interrupt controller to correctly forward hardware interrupts to the CPU. To handle these interrupts we add new entries to our interrupt descriptor table, just like we did for our exception handlers. We will learn how to get periodic timer interrupts and how to get input from the keyboard.]]></description><guid isPermaLink="false">97757259-e11d-4a4f-88cb-2653ca3cb977</guid><pubDate>Tue, 23 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Red Hat&apos;s Stratis Storage Project Reaches Its 1.0 Stable Milestone</title><link>https://www.phoronix.com/scan.php?page=news_item&amp;px=Stratis-1.0-Released</link><description><![CDATA[Stratis 1.0 was quietly released last week with the 1.0 version marking its initial stable release and where also the on-disk meta-data format has been stabilized. Red Hat engineers believe Stratis is now ready for more widespread testing.]]></description><guid isPermaLink="false">4ae0bbf7-720b-48d3-8c5d-d5b3c8e061dd</guid><pubDate>Tue,  2 Oct 2018 04:48:34 -0400</pubDate><dc:creator>Michael Larabel</dc:creator></item><item><title>RSoC: Relibc - Wrap up</title><link>https://www.redox-os.org/news/rsoc-relibc-final/</link><description><![CDATA[Time for me to pack up and never ever contribute to Redox ever againâ€¦ Just kidding. This isnâ€™t goodbye, you canâ€™t get rid of me that easily Iâ€™m afraid. Iâ€™ll definitely want to contribute more, canâ€™t however say with certainty how much time Iâ€™ll get, for school is approaching, quickly]]></description><guid isPermaLink="false">ab387870-cbed-4f6d-b1e2-22d2c2686de4</guid><pubDate>Sat, 11 Aug 2018 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>RSoC: FAT32 Filesystem in Redox - 3</title><link>https://www.redox-os.org/news/rsoc-fat32-3/</link><description><![CDATA[The previous blog post discusses how raw disk reads were implemented in the loader stub. The next step was to implement a clean read API which can be used by different filesystem libraries in order to read their respective filesystems. Since the raw reads from the BIOS interrupt had a granularity in terms of sectors(each sector being 512 bytes), the reads had to be translated in order to provide byte level granularity. The clone_from_slice function ensures that a direct call to memcopy is not required. The refined read function is here.]]></description><guid isPermaLink="false">6f2abec2-1096-4a82-90db-b1962a2876f7</guid><pubDate>Thu,  9 Aug 2018 00:00:00 +0000</pubDate><dc:creator>Deepak Sirone</dc:creator></item><item><title>RSoC: Porting Redox to ARM (AArch64) â€” 0x02</title><link>https://medium.com/@wizofe/rsoc-porting-redox-to-arm-aarch64-0x02-c566ee22f377</link><description><![CDATA[At the time of writing the previous blog the plan was to target the Raspberry Pi 3 (Cortex A53) as a development platform because of its availability, popularity and community. Sadly, it seems that Broadcom went through a lot of shortcuts while implementing this specific design, which means features like GIC are half-there or completely missing, like in this case.

After a discussion with @microcolonel, he proposed and kindly sent me a HiKey960 reference SoC from the awesome Linaro 96Boards initiative. The quality of this board is definitely a lot better than the Raspberry Pi and the documentation is detailed and open. Great stuff.]]></description><guid isPermaLink="false">382f988d-9fe3-4525-9b21-0c6cb4373303</guid><pubDate>Sun,  5 Aug 2018 22:39:42 +0000</pubDate><dc:creator>ioannis valasakis</dc:creator></item><item><title>The State of Rust on Haiku</title><link>https://www.haiku-os.org/blog/nielx/2018-07-05_the_state_of_rust_on_haiku/</link><description><![CDATA[With the recent addition of Rust 1.27.0 in the HaikuPorts repository, I thought it would be good to do a short, public write-up of the current state of Rust on Haiku, and some insight into the future.]]></description><guid isPermaLink="false">415e9361-8fad-4317-ae02-7abeb1faad3d</guid><pubDate>Thu,  5 Jul 2018 07:31:51 +0200</pubDate><dc:creator>nielx</dc:creator></item><item><title>RSoC: FAT32 Filesystem in Redox - 2</title><link>https://www.redox-os.org/news/rsoc-fat32-2/</link><description><![CDATA[This is the second blog post about implementing a FAT32 filesystem in Redox.]]></description><guid isPermaLink="false">87ea8aa4-a134-4f8a-8ff2-fc33f4832020</guid><pubDate>Tue,  3 Jul 2018 00:00:00 +0000</pubDate><dc:creator>Deepak Sirone</dc:creator></item><item><title>Signal Hook: Unix signal handling in Rust</title><link>https://vorner.github.io/2018/06/28/signal-hook.html</link><description><![CDATA[As promised in the previous article (thanks for all the valuable feedback â€’ I didnâ€™t have the time to act on it yet, but I will), this talks about Unix signal handling.

Long story short, I wasnâ€™t happy about the signal handling story in Rust and this is my attempt at improving it.]]></description><guid isPermaLink="false">a721af0b-e469-40ba-8ddc-f5f2a305483f</guid><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Michal &apos;vorner&apos; Vaner</dc:creator></item><item><title>Nebulet: More answers</title><link>https://lsneff.me/more-answers.html</link><description><![CDATA[Over the last couple of weeks, Nebulet has progressed signifigantly. Because of that, I think itâ€™s time to talk about why I made certain decisions when designing and writing Nebulet.]]></description><guid isPermaLink="false">3b9229a6-90a7-48f7-983f-c2eb1117115e</guid><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Lachlan Sneff</dc:creator></item><item><title>RSoC: Porting Redox to AArch64â€“0x01</title><link>https://medium.com/@wizofe/rsoc-porting-redox-to-aarch64-0x01-3dee87644c97</link><description><![CDATA[All excited. A first calendar entry to describe my attempt on arm64 support in Redox OS. Specifically, looking into the Raspberry Pi2/3b/3+(all of them having a Cortex-A53 ARMv8 64-bit microprocessor, although for all my experiments I am going to use the Raspberry Pi 3b.]]></description><guid isPermaLink="false">44759beb-04e0-4524-898b-5ba007a80e10</guid><pubDate>Tue, 26 Jun 2018 17:26:31 +0000</pubDate><dc:creator>ioannis valasakis</dc:creator></item><item><title>Writing an OS in Rust: Double Faults</title><link>https://os.phil-opp.com/double-fault-exceptions/</link><description><![CDATA[In this post we explore double faults in detail. We also set up an Interrupt Stack Table to catch double faults on a separate kernel stack. This way, we can completely prevent triple faults, even on kernel stack overflow.]]></description><guid isPermaLink="false">e11a6e53-3315-44c0-a23f-7f0217019c55</guid><pubDate>Mon, 18 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Writing an OS in Rust: CPU Exceptions</title><link>https://os.phil-opp.com/cpu-exceptions/</link><description><![CDATA[In this post, we start exploring CPU exceptions. Exceptions occur in various erroneous situations, for example when accessing an invalid memory address or when dividing by zero. To catch them, we have to set up an interrupt descriptor table that provides handler functions. At the end of this post, our kernel will be able to catch breakpoint exceptions and to resume normal execution afterwards.]]></description><guid isPermaLink="false">e75667af-3d07-40cb-a610-4c7a6786064b</guid><pubDate>Sun, 17 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Writing an OS in Rust: Integration Tests</title><link>https://os.phil-opp.com/integration-tests/</link><description><![CDATA[In this post we complete the testing picture by implementing a basic integration test framework, which allows us to run tests on the target system. The idea is to run tests inside QEMU and report the results back to the host through the serial port.]]></description><guid isPermaLink="false">d8b1216b-bc74-43c1-9ce3-958e0e2b4154</guid><pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>RSoC: Porting tokio to redox - week 3</title><link>https://www.redox-os.org/news/rsoc-porting-tokio-3/</link><description><![CDATA[Last week I ended off stating that the redox netstack might soon switch to an edge-triggered model. Well, I ended up feeling bad about the idea of letting others do my work and decided to stop being lazy and just do it myself.]]></description><guid isPermaLink="false">54270fa0-69d3-4ec1-8aca-c77191e164e5</guid><pubDate>Wed,  6 Jun 2018 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>A Rust-based Unikernel</title><link>https://hermitcore.org/2018/06/06/A-Rust-based-Unikernel/</link><description><![CDATA[Rust is an extremely interesting language for the development of system software. This was the motivation to evaluate Rust for HermitCore and to develop an experimental version of our libOS in Rust. Components like the IP stack and uhyve (our unikernel hypervisor) are still written in C. In addition, the user applications are still compiled by our cross-compiler, which is based on gcc and supports C, C++, Fortran, and Go. The core of the kernel, however, is now written in Rust and published at GitHub. Our experiences so far are really good and we are looking into possibly new Rust activities, e.g., the support for Rustâ€™s userland.]]></description><guid isPermaLink="false">d70a58d9-d528-41e3-a91c-605c58465d45</guid><pubDate>Wed,  6 Jun 2018 00:00:00 +0000</pubDate><dc:creator>Stefan Lankes</dc:creator></item><item><title>RSoC: Porting Redox to AArch64 - 0x01</title><link>https://www.redox-os.org/news/rsoc-arm64-0x01/</link><description><![CDATA[A first calendar entry to describe my attempt on ARM64 support in Redox OS. Specifically, looking into the Raspberry Pi2/3(B)/3+ (all of them having a Cortex-A53 ARMv8 64-bit microprocessor, although for all my experiments I am going to use the Raspberry Pi 3(B)).]]></description><guid isPermaLink="false">49d19c19-5c1c-4a2e-9b5f-fa17c81e2ed3</guid><pubDate>Wed, 30 May 2018 00:00:00 +0000</pubDate><dc:creator>wizofe</dc:creator></item><item><title>RSoC: Implementing a FAT32 Filesystem in Redox</title><link>https://www.redox-os.org/news/rsoc-fat32-1/</link><description><![CDATA[This is a blog post about the work which I have done so far in implementing a FAT32 filesystem in Redox. Currently the Redox bootloader as well as the userspace filesystem daemon supports only RedoxFS.]]></description><guid isPermaLink="false">b9a686f1-3136-4307-a6ac-0f596babc6b5</guid><pubDate>Tue, 29 May 2018 00:00:00 +0000</pubDate><dc:creator>Deepak Sirone</dc:creator></item><item><title>RSoC: Porting tokio to Redox</title><link>https://www.redox-os.org/news/rsoc-porting-tokio-to-redox/</link><description><![CDATA[This is the weekly summary for my Redox Summer of Code project: Porting tokio to redox. Most of the time was spent on one bug, and after that one was figured out and fixed it ended up being relatively easy! As of now, 11â„13 tokio examples seem to work on redox. The remaining examples are UDP and seem to fail because of something either with the rust standard library or my setup.]]></description><guid isPermaLink="false">4c951443-54b3-4187-8791-b27502ff193b</guid><pubDate>Mon, 21 May 2018 00:00:00 +0000</pubDate><dc:creator>jD91mZM2</dc:creator></item><item><title>Writing an OS in Rust: Unit Testing</title><link>https://os.phil-opp.com/unit-testing/</link><description><![CDATA[This post explores unit testing in no_std executables using Rust's built-in test framework. We will adjust our code so that cargo test works and add some basic unit tests to our VGA buffer module.]]></description><guid isPermaLink="false">18f0f723-af8c-4415-9ea4-6578a641729a</guid><pubDate>Sun, 29 Apr 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Redox Summer of Code</title><link>https://www.redox-os.org/rsoc/</link><description><![CDATA[Redox OS is running its own Summer of Code this year, after the Microkernel devroom did not get accepted into GSoC 2018. We are looking for both Students and Sponsors who want to help Redox OS grow. At the moment, Redox OS has $10,800 in donations from various platforms to use to fund students. This will give us three students working for three months, if each student requests $1200 per month on average as described in Payment.

In order to fund more students, we are looking for sponsors who are willing to fund RSoC. Donations can be made on the Donate page. All donations will be used to fund Redox OS activities, with about 90% of those over the past year currently allocated to RSoC.]]></description><guid isPermaLink="false">a4be83a4-b126-479a-bfca-81e7d612d2b3</guid><pubDate>Sat, 14 Apr 2018 21:10:05 +0000</pubDate><dc:creator>Jeremy Soller</dc:creator></item><item><title>New Pop!_OS Testing Release with Rust based Linux installer &quot;distinst&quot;</title><link>https://system76.com/pop/testing</link><description><![CDATA[Our second iteration of the 18.04 ISO is ready for testing. Testing the new installer and Optimus switching is our priority for this test release. Please test installing on a variety of hardware and provide feedback on any issues you encounter. If you run into any bugs, you can file them at https://github.com/pop-os/pop/issues.]]></description><guid isPermaLink="false">63444a58-4cbd-4441-b5c3-5f216560e276</guid><pubDate>Fri, 13 Apr 2018 21:05:51 +0000</pubDate><dc:creator>System76</dc:creator></item><item><title>Writing CloudABI applications in Rust</title><link>https://cloudabi.org/write/rust/</link><description><![CDATA[Installing a toolchain for Rust is very easy, as support for CloudABI has been upstreamed into the Rust codebase. Automated builds are performed by the Rust developers. As there hasnâ€™t been a stable release of Rust to include CloudABI support yet, you must for now make use of Rustâ€™s nightly track.]]></description><guid isPermaLink="false">7f54a4c5-d312-4b64-9d90-4945dd6d1b72</guid><pubDate>Fri, 13 Apr 2018 05:18:57 +0000</pubDate><dc:creator>CloudABI</dc:creator></item><item><title>Writing an OS in Pure Rust</title><link>https://os.phil-opp.com/news/2018-03-09-pure-rust/</link><description><![CDATA[Over the past six months we've been working on a second edition of this blog. Our goals for this new version are numerous and we are still not done yet, but today we reached a major milestone: It is now possible to build the OS natively on Windows, macOS, and Linux without any non-Rust dependendencies.]]></description><guid isPermaLink="false">f6bf64c8-3a31-4614-ba91-f5c16a0986b5</guid><pubDate>Fri,  9 Mar 2018 00:00:00 +0000</pubDate><dc:creator>Philipp Oppermann</dc:creator></item><item><title>Writing eBPF tracing tools in Rust</title><link>https://jvns.ca/blog/2018/02/05/rust-bcc/</link><description><![CDATA[Writing eBPF tracing tools in Rust]]></description><guid isPermaLink="false">92664a59-08e0-4185-aab2-cd0a29f303f8</guid><pubDate>Mon,  5 Feb 2018 10:23:44 +0000</pubDate><dc:creator>Julia Evans</dc:creator></item><item><title>PoC: compiling to eBPF from Rust</title><link>https://unhandledexpression.com/2018/02/02/poc-compiling-to-ebpf-from-rust/</link><description><![CDATA[I have been playing with eBPF (extended Berkeley Packet Filters), a neat feature present in recent Linux versions (it evolved from the much older BPF filters). It is a virtual machine running in thâ€¦]]></description><guid isPermaLink="false">444386e2-51fc-488e-ac19-0aa71a4d89a3</guid><pubDate>Fri,  2 Feb 2018 20:33:08 +0000</pubDate><dc:creator>Geoffroy Couprie</dc:creator></item></channel></rss>