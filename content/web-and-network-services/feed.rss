<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Web and Network Services</title><link>https://readrust.net/</link><description>Web and Network Services posts on Read Rust</description><item><title>Sample REST API in Rust and Go</title><link>https://jmmv.dev/2019/09/rest-api-rust-go.html</link><description><![CDATA[Over the summer, I prototyped a bunch of web apps whose ideas had been floating in my mind for a long time. I spent quite a bit of time learning about REST APIs and, as part of these exercises, implemented skeletons of REST servers in both Go and Rust. The app prototypes have gone nowhere but I thought of sharing the skeletons I built if only to serve as templates for myself in future work. Thus, in this post, I will cover these skeleton demos and I will compare them.]]></description><guid isPermaLink="false">dcbe1901-b9b1-4eec-a44e-d6be0dcdd958</guid><pubDate>Fri, 27 Sep 2019 06:45:40 +0500</pubDate><dc:creator>Julio Merino</dc:creator></item><item><title>How to use routers in Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-use-routers-in-Rust-Frontend</link><description><![CDATA[In the previous post How to use a modal in Rust, we learnt how to write a simple image modal with Rust frontend. We could find that we can build components visible only in specific conditions. In this post, we will learn how to use routers in Rust frontend with Yew. You will find that it is easy with an example.]]></description><guid isPermaLink="false">4da678ba-45e7-444f-b5da-20e2893bb4d6</guid><pubDate>Tue, 27 Aug 2019 23:46:31 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Picking Rust for web</title><link>https://abe-winter.github.io/wisdom/2019/08/26/rust-for-web.html</link><description><![CDATA[Iâ€™ve been staring at this energy efficiency across programming languages table for days. It canâ€™t be right (why is typescript so much worse than javascript?) but a lot of it tracks with things Iâ€™ve observed from using these languages IRL. Also this web framework benchmarks project. Bottom line: Iâ€™m thinking about using rust as the backend for a small one-person web project. Hereâ€™s everything I said to myself while researching reasons not to.]]></description><guid isPermaLink="false">5d8d151f-18fd-4aa2-8a3d-eb5620394f36</guid><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Abe Winter</dc:creator></item><item><title>Building with async/await in Rust</title><link>https://ragona.com/posts/clobber_async_await</link><description><![CDATA[As you might have heard, async/await is coming to Rust soon. This is a big deal. Rust has already has popular crates (tokio, actix) that provide asynchronous concurrency, but the async syntax coming to stable in 1.39 is much, much more approachable. My experience has been that you can produce and reason about application flow much more easily, which has made me significantly more productive when dealing with highly concurrent systems. To kick the tires of this new syntax I dug into the nightly branch, and built a high-performance TCP client called clobber. In this post I'll talk about why I think async/await in Rust is a big deal, and walk you some of the code in clobber.]]></description><guid isPermaLink="false">b577a6bb-429a-454b-8d2b-77175dba68c8</guid><pubDate>Wed, 21 Aug 2019 00:00:00 +0000</pubDate><dc:creator>Ryan Ragona</dc:creator></item><item><title>Rustacean Terminal Chat App in Rust</title><link>https://www.pubnub.com/blog/build-realtime-rust-chat-app-cursive-tui/</link><description><![CDATA[Build a basic chat app with the Rust Programming Language.]]></description><guid isPermaLink="false">e21ad158-7d23-47c3-82a4-0f76f651c6d9</guid><pubDate>Fri,  9 Aug 2019 17:31:52 +0000</pubDate><dc:creator>Samba Diallo</dc:creator></item><item><title>Practical Networked Applications in Rust, Part 2: Networked Key-Value Store</title><link>https://arveknudsen.com/posts/practical-networked-applications-in-rust/module-2/</link><description><![CDATA[Welcome to the second installation in my series on taking the Practical Networked Applications in Rust course, kindly provided by the PingCAP company, where you develop a networked and multithreaded/asynchronous key-value store in the amazing Rust language. In the previous, and initial, post I implemented the course module of making the fundamental key-value store functionality, based around the Bitcask algorithm, which would only allow for local usage on your own computer. In the second module of my course work, I add networking functionality, dividing the application into a client/server architecture so that clients can connect to servers across the network.]]></description><guid isPermaLink="false">09df4bbd-96fe-49af-8811-407f98c3108e</guid><pubDate>Sun,  4 Aug 2019 01:00:00 +0200</pubDate><dc:creator>Arve Knudsen</dc:creator></item><item><title>Low-level TCP server in Rust with MIO</title><link>https://sergey-melnychuk.github.io/2019/08/01/rust-mio-tcp-server/</link><description><![CDATA[It is time to get acquainted with Metal IO, low-level cross-platform abstraction over epoll/kqueue written in Rust. In this article I will show and explain how to write simple single-threaded asynchronous TCP server, then teach it to mock HTTP protocol, and then benchmark it with ab/wrk. The results are about to be impressive.]]></description><guid isPermaLink="false">94dd1a96-2b38-4556-bb32-5064f803e5b6</guid><pubDate>Thu,  1 Aug 2019 22:25:42 +0000</pubDate><dc:creator>Sergey Melnychuk</dc:creator></item><item><title>Practical Networked Applications in Rust, Part 1: Non-Networked Key-Value Store</title><link>https://arveknudsen.com/posts/practical-networked-applications-in-rust/module-1/</link><description><![CDATA[The PingCAP company, makers of the TiDB NewSQL database and the TiKV key-value store, have kindly made publicly available, as well as open-sourced, a set of training courses that they call the "PingCAP Talent Plan". These courses train programmers in writing distributed systems in the Go and Rust languages. They are originally intended by PingCAP to train students, new employees and new contributors to TiDB and TiKV and focus as such on subjects relevant to those projects, but are still appropriate to anyone with an interest in learning to make distributed systems in Go and/or Rust.]]></description><guid isPermaLink="false">faca5f20-8895-4d5b-850c-d2a8b4149876</guid><pubDate>Tue, 23 Jul 2019 13:00:00 +0200</pubDate><dc:creator>Arve Knudsen</dc:creator></item><item><title>How to write Full Stack Rust code</title><link>https://www.steadylearner.com/blog/read/How-to-write-Full-Stack-Rust-code</link><description><![CDATA[In the previous post How to modulize your Rust Frontend, we learnt how to use impl, functions and Yew components. They help you to find errors and organize your Rust frontend project. In this post, we will include server side code with ws-rs. It will help us to build complete Rust Full Stack chat app similar to what we made at How to start Rust Chat App.]]></description><guid isPermaLink="false">ca7ab50b-0ea0-4d8f-9f38-74945bc33900</guid><pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>How to modulize your Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-modulize-your-Rust-Frontend</link><description><![CDATA[In the previous post How to use markdown with Rust Frontend, we learnt how to render markdown in Rust frontend and include CSS files from your previous frontend project. You can use a text, image, video, markdown or any HTML elements you want for your Rust frontend. In this post, we will learn how to modulize your Rust Yew frontend app. It will be easy after you learn how to use impl, function, and components for that.]]></description><guid isPermaLink="false">5784cd2f-f28c-4746-8c85-c39ee718c4a0</guid><pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Announcing Ballista - Distributed Compute with Rust, Apache Arrow, and Kubernetes</title><link>https://andygrove.io/2019/07/announcing-ballista/</link><description><![CDATA[After taking a break from working on Arrow and DataFusion for a couple of months to focus on some deliverables at work, I have now started a new PoC project to have a second attempt at building a distributed platform with Rust, and this time around I have the advantage of already having some foundational pieces in place, namely Arrow and DataFusion. I have also been gaining experience with Kubernetes recently and I could clearly see how this would simplify the creation of a distributed platform. The pieces really are starting to fall into place.

The new project is called Ballista and is a fast moving PoC taking a top down approach to building a distributed platform.]]></description><guid isPermaLink="false">f47a9bfe-394d-44b0-a4b1-683976a2cee2</guid><pubDate>Tue, 16 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Andy Grove</dc:creator></item><item><title>Rust in one of the biggest music festival Atlas Weekend 2019</title><link>https://www.reddit.com/r/rust/comments/cdg5b4/rust_in_the_on_of_the_biggest_music_festival/</link><description><![CDATA[I'm happy to announce, that we've just finished one of the biggest European music festival Atlas Weekend which took place in Kyiv, Ukraine. As a year ago, backend for technical purposes of festival is written with Rust: Tickets exchange, entrance control, powerful user management with distributed configurable permissions, backstage pass, control of security workers, their work time, cars entrance, warehouse system for rfid bracelets with full history and control of each rfid. This year we registered more than 6000 workers, each of them has full info tied to bracelet: name, phone, photo, available permissions, time to access festival.]]></description><guid isPermaLink="false">0026c42e-9e3b-4a14-96dc-1fe3609e8957</guid><pubDate>Mon, 15 Jul 2019 00:00:00 +0000</pubDate><dc:creator>/u/maxfrai</dc:creator></item><item><title>Rust as the new C. Part 1: building and combining native libs into C API</title><link>http://hotforknowledge.com/2019/07/14/6-rust-the-new-c/</link><description><![CDATA[In this blog series, I will experiment with Rust as a safer and simpler C/C++ replacement. The idea is to combine a couple of C dependencies in Rust, to do some work using the dependencies in Rust and to expose a final API from a Rust library via C ABI. Then I will consume the same exported Rust methods from a number of modern languages/platforms such as C#, Python, Java, Nodejs, R, Go and even back from C/C++.]]></description><guid isPermaLink="false">342aba54-6554-4ec9-9d92-cd93edfbc8a2</guid><pubDate>Sun, 14 Jul 2019 16:12:00 +0300</pubDate><dc:creator>Victor Baybekov</dc:creator></item><item><title>How to use NPM packages with Rust Frontend</title><link>https://www.steadylearner.com/blog/read/How-to-use-NPM-packages-with-Rust-Frontend</link><description><![CDATA[In the previous post full-stack Rust with Yew, we learnt how to prepare minimal files to build a full stack Rust web app. You can do whatever Rust allows with it.]]></description><guid isPermaLink="false">4979dc89-2295-48da-ae2b-cb84dc37fd8c</guid><pubDate>Sun, 14 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Fullstack Rust with Yew</title><link>https://www.steadylearner.com/blog/read/Fullstack-Rust-with-Yew</link><description><![CDATA[In the previous post How to use Rust Yew, we learnt how to prepare minimal files to build webassembly files with Yew for Rust frontend. We will advance it with some Rust server side code and write a bash file to automate the process.]]></description><guid isPermaLink="false">28d2b0b9-8bfb-4541-b2f5-f84ed2670d56</guid><pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Collecting broadcast UDP packets using async networking in Rust</title><link>https://medium.com/tresorit-engineering/collecting-broadcast-udp-packets-using-async-networking-in-rust-7fd93a631eac</link><description><![CDATA[Creating a simple console application in Rust for fun and profit, including some nice tricks to push async programming to the limits.]]></description><guid isPermaLink="false">66342269-5693-4c70-a15c-917b7818dc07</guid><pubDate>Mon,  8 Jul 2019 10:39:21 +0000</pubDate><dc:creator>PÃ©ter Budai</dc:creator></item><item><title>Create Dev&apos;s offline page with Rust and WebAssembly ðŸ¦„ðŸ’¡âœ¨</title><link>https://dev.to/sendilkumarn/create-dev-s-offline-page-with-rust-and-webassembly-21gn</link><description><![CDATA[Dev's offline page is fun. Can we do that with Rust and WebAssembly? The answer is yes. Let us do it.]]></description><guid isPermaLink="false">b5b706cb-863b-4856-843d-6a894a7fc280</guid><pubDate>Wed,  3 Jul 2019 23:14:51 +0000</pubDate><dc:creator>Sendil Kumar N</dc:creator></item><item><title>Increase Rust and WebAssembly performance</title><link>https://dev.to/sendilkumarn/increase-rust-and-webassembly-performance-382h</link><description><![CDATA[What are we gonna do? Create a WebAssembly application that takes a string in markdown format and converts that into HTML.]]></description><guid isPermaLink="false">faa1d1ec-2bcd-4363-832a-2e03e35d8124</guid><pubDate>Tue,  2 Jul 2019 00:40:25 +0000</pubDate><dc:creator>Sendil Kumar N</dc:creator></item><item><title>Rust WebAssembly Hello World - Deep Dive with wasm-bindgen and wasm2wat</title><link>https://www.webassemblyman.com/rust_webassembly_hello_world.html</link><description><![CDATA[In this article we are going to create a WebAssembly Hello World program with Rust. You might be thinking that a WebAssembly Hello World tutorial could be found almost everywhere, including one on Mozilla website and rustwasm.github.io.]]></description><guid isPermaLink="false">247efda7-549d-4c38-8af1-733755fc4aa7</guid><pubDate>Tue,  2 Jul 2019 00:00:00 +0000</pubDate><dc:creator>nicole</dc:creator></item><item><title>How to use Rust Yew</title><link>https://www.steadylearner.com/blog/read/How-to-use-Rust-Yew</link><description><![CDATA[In this post, we will prepare development environment for Rust Yew. Then, we will write minimal code with it and learn how to deploy it in your website also.]]></description><guid isPermaLink="false">db9d60ca-f153-4abf-9654-ac53ec91472e</guid><pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Wasm By Example</title><link>https://wasmbyexample.dev/</link><description><![CDATA[A hands-on introduction into WebAssembly ( Wasm ). Containing simple examples and tutorials on how to implement concepts and various tasks using Wasm.]]></description><guid isPermaLink="false">2c73c05a-7fb3-494d-8fb3-896cf3a343b3</guid><pubDate>Wed, 26 Jun 2019 03:28:00 +0000</pubDate><dc:creator>Aaron Turner</dc:creator></item><item><title>Writing a proxy in Rust and why it is the language of the future</title><link>https://medium.com/swlh/writing-a-proxy-in-rust-and-why-it-is-the-language-of-the-future-265d8bf7c6d2</link><description><![CDATA[Itâ€™s been a year since I wrote a little proxy with Rust, it is one of my first projects with this language and I learned a lot writing it. To sum up a bit, the main goal of this proxy is to be really simple to use and easy to extend with middlewares. It targets HTTP APIs and can be used in front of a lot of services. This proxy has been used in multiple projects, with microservices architecture and so onâ€¦]]></description><guid isPermaLink="false">ae8feddf-191a-444f-9423-e7a3e0b4b356</guid><pubDate>Tue, 25 Jun 2019 14:43:21 +0000</pubDate><dc:creator>Terry Raimondo</dc:creator></item><item><title>Implementing HTSP in Rust</title><link>https://www.rubdos.be/rust/async/programming/2019/06/22/implementing-htsp-in-rust.html</link><description><![CDATA[As with most hobby projects, my htsp-rs implementation became a side-side-side project, and it will probably stay that way. Another property of those hobby projects is that I now-and-then pick them up again, and htsp-rs has come to that point now. The reason for picking it up again is different from the reason of its existence though, and thatâ€™s a good thing: it means I have multiple reasons for the crateâ€™s existence. Initially, I wanted it as a back-end for a livestreaming app on SailfishOS. Today, I want it as back-end for mpdâ€™s TVHeadend support.]]></description><guid isPermaLink="false">0770f016-861d-4bc1-9ce0-cad6b6e374f2</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Ruben De Smet</dc:creator></item><item><title>Collaborative Editor in Rust</title><link>https://caolan.org/posts/collaborative_editor_in_rust.html</link><description><![CDATA[I've been experimenting with techniques for collaborative editing in Rust recently and I'd like to share my first functional prototype with you. The demo uses Rust and WebAssembly, and I implemented it using a conflict-free replicated data type (CRDT) based on LOGOOT, which I modified to work with variable-sized strings rather than individual characters or lines.]]></description><guid isPermaLink="false">54d40e7f-c5c5-4c69-86e2-9913c6a88200</guid><pubDate>Fri, 21 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Caolan McMahon</dc:creator></item><item><title>Asyncifying an Actix Web App and Upgrading it to 1.0 - zupzup</title><link>https://zupzup.org/asyncify-rust-webapp/</link><description><![CDATA[In a previous post, we created an Actix 0.7 Web App, which was not fully non-blocking. In this post, we'll become fully non-blocking and upgrade the app to Actix 1.0]]></description><guid isPermaLink="false">a5730863-ff70-4122-8595-81c11ee59697</guid><pubDate>Thu, 20 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Mario Zupan</dc:creator></item><item><title>Makepad, a live Rust authoring tool for 2D vector design, shaders and animation</title><link>https://github.com/makepad/makepad</link><description><![CDATA[The vision is to build a livecoding / design hybrid program, where procedural design and code are fused in one environment. If you have missed 'learnable programming' please check this out: http://worrydream.com/LearnableProgramming/ Makepad aims to fulfill (some) of these ideas using a completely from-scratch renderstack built on the GPU and Rust. It will be like an IDE meets a vector designtool, and had offspring. Direct manipulation of the vectors modifies the code, the code modifies the vectors.

However before we can make this awesome application, we need to build a UI stack. The aim of this toolkit is to be our stepping stone into building a livecoding IDE and designtools that don't suck or fall to pieces along the way.]]></description><guid isPermaLink="false">87146592-5c10-431e-8655-5272eec53ed9</guid><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><dc:creator>makepad</dc:creator></item><item><title>Auth Web Microservice with rust using Actix-Web 1.0 - Complete Tutorial</title><link>https://gill.net.in/posts/auth-microservice-rust-actix-web1.0-diesel-complete-tutorial/</link><description><![CDATA[We are going to create a web-server in rust that only deals with user registration and authentication. I will be explaining the steps in each file as we go. The complete project code is here repo. Please take all this with a pinch of salt as Iâ€™m a still a noob to rust ðŸ˜‰.]]></description><guid isPermaLink="false">5150f924-ef3f-4327-a3ba-c5f16076a22b</guid><pubDate>Sun,  9 Jun 2019 00:00:00 +0000</pubDate><dc:creator>Harry Gill</dc:creator></item><item><title>Actix - Actor System and Web Framework for Rust</title><link>https://actix.rs/</link><description><![CDATA[Actix web 1.0.0 is released - a small, pragmatic, and extremely fast web framework.]]></description><guid isPermaLink="false">ae6027ab-b71f-4bce-9ab8-e1853aa24030</guid><pubDate>Wed,  5 Jun 2019 15:38:00 +0000</pubDate><dc:creator>Nikolay Kim</dc:creator></item><item><title>Gopher Server in Rust</title><link>https://gkbrk.com/2019/06/gopher-server/</link><description><![CDATA[I find Gopher really cool. I think itâ€™s a really nice way to organize information into trees and hierarchies, and as we all know programmers canâ€™t resist trees. So recently I took an interest in Gopher and started writing my own server.

But recently itâ€™s been gaining traction; so we should provide a decent landscape for new gophers, full of oxidised servers. Since I started using Gopher more often, itâ€™s beneficial for me if thereâ€™s more content out there. So Iâ€™m writing this blog post to walk you through how to write your own server. Weâ€™ll be doing this in Rust.]]></description><guid isPermaLink="false">91ae37e0-3d4f-4c78-879d-47e635f8fbda</guid><pubDate>Sun,  2 Jun 2019 01:00:00 +0100</pubDate><dc:creator>Gokberk Yaltirakli</dc:creator></item><item><title>Creating a Static HTTP Server with Rust â€“ Part 2</title><link>http://concisecoder.io/2019/05/27/creating-a-static-http-server-with-rust-part-2/</link><description><![CDATA[In this series, we are creating a basic static HTTP 1.0 server with Rust. If you havenâ€™t seen Part 1 yet, go do that first. At the end of Part 2, our server will do the following: Read and serve files from a predefined directory on the host server, Generate appropriate HTTP responses to incoming requests, Log information about the response to standard output.]]></description><guid isPermaLink="false">4e723122-0527-43dc-b95b-ff4fd5cd5d28</guid><pubDate>Mon, 27 May 2019 13:25:29 +0000</pubDate><dc:creator>Levi Payne</dc:creator></item><item><title>Programming Servo: Zen and the art of removing blocks from your system</title><link>https://medium.com/@polyglot_factotum/programming-servo-zen-and-the-art-of-removing-blocks-from-your-system-51c1b7d404e3</link><description><![CDATA[It all started with a simple issue, a â€œquick fixâ€, or so I thought.]]></description><guid isPermaLink="false">0cc7297b-a14f-443d-a02a-073685c663a3</guid><pubDate>Sun, 26 May 2019 09:41:02 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Blockchain-Flavored WASI</title><link>https://medium.com/oasislabs/blockchain-flavored-wasi-50e3612b8eba</link><description><![CDATA[General purpose computation on the blockchain using Web Assembly System Interface (WASI).]]></description><guid isPermaLink="false">fe48ce77-ad77-4983-a08d-1fb9cf951bb1</guid><pubDate>Thu, 23 May 2019 04:07:55 +0000</pubDate><dc:creator>Nick Hynes</dc:creator></item><item><title>Running WebAssembly on the Kernel</title><link>https://medium.com/wasmer/running-webassembly-on-the-kernel-8e04761f1d8e</link><description><![CDATA[This is the story of our journey running Wasmer on the Linux kernel.]]></description><guid isPermaLink="false">ef3c5cdb-f130-4211-83a1-1550ea15d73f</guid><pubDate>Thu, 16 May 2019 22:37:36 +0000</pubDate><dc:creator>Heyang Zhou</dc:creator></item><item><title>How to start a Rust Chat App</title><link>https://www.steadylearner.com/blog/read/How-to-start-Rust-Chat-App</link><description><![CDATA[In this post, we will learn how to build simple chat app in your local machine with Rust and simple JavaScript.]]></description><guid isPermaLink="false">e25cac18-f4ca-4872-babe-c4614327e076</guid><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Introducing Packem: a super fast experimental bundler written in Rust</title><link>https://medium.freecodecamp.org/introducing-packem-a-super-fast-experimental-bundler-written-in-rust-e981af875517</link><description><![CDATA[Packem is an experimental precompiled JavaScript module bundler primarily implemented in Rust. It can also handle a variety of other file types like YAML/TOML, fragment shader files and a lot more.]]></description><guid isPermaLink="false">3eb814d5-d467-4e34-ba31-e0a55da4da36</guid><pubDate>Wed, 15 May 2019 16:36:27 +0000</pubDate><dc:creator>Bukhari Muhammad</dc:creator></item><item><title>Creating a Static HTTP Server with Rust - Part 1</title><link>http://concisecoder.io/2019/05/11/creating-a-static-http-server-with-rust-part-1/</link><description><![CDATA[In this series, we will create a basic static HTTP 1.0 server with Rust. At the end of Part 1 of this tutorial, our server will do the following: Listen for and handle TCP connections on a specific port, Accept HTTP 1.0 GET requests, Parse and validate requests for further use, Log incoming requests. We will avoid using libraries that make this trivial (i.e. the http crate) and focus on the fundamentals of how a server works.]]></description><guid isPermaLink="false">25d9490f-05e3-4f5c-a407-19d78b0fb6d4</guid><pubDate>Sat, 11 May 2019 17:17:46 +0000</pubDate><dc:creator>Levi Payne</dc:creator></item><item><title>Unit testing Rust using Chrome</title><link>https://medium.com/visly/unit-testing-rust-using-chrome-b8b93572a91d</link><description><![CDATA[Stretch is a cross-platform Flexbox engine written in Rust. At Visly we are building a design tool for front-end engineers and we needed to ensure components looked the same across web, iOS, and Android without making use of WebViews. This meant replicating the web layout system on mobile.

In this post, Iâ€™ll cover the test setup we use in Stretch, how and why we need to generate unit dynamically. Iâ€™ll also cover an example of contributing another test to Stretch, and finally Iâ€™ll walk through how we also make use of this system for benchmarking.]]></description><guid isPermaLink="false">ffeaa8e5-849b-4924-9c9f-1ac6adc15a8e</guid><pubDate>Mon,  6 May 2019 16:25:41 +0000</pubDate><dc:creator>Emil SjÃ¶lander</dc:creator></item><item><title>WebAssembly -Part II.A | Wasm with Rust</title><link>https://medium.com/tech-lah/webassembly-part-ii-a-wasm-with-rust-2356dbc6526e</link><description><![CDATA[This article is more of a how-to on getting up and running with a production-grade web project which incorporates Rust (or any other language for that matter) and WebAssembly into your web pages.]]></description><guid isPermaLink="false">e3fadb7b-df84-47a1-b6ca-47186b2b9418</guid><pubDate>Sun,  5 May 2019 13:27:01 +0000</pubDate><dc:creator>Francisco Vilches</dc:creator></item><item><title>Introducing Lightbeam: An Optimising Streaming WebAssembly Compiler</title><link>http://troubles.md/posts/lightbeam/</link><description><![CDATA[Lightbeam is a new streaming compiler for WebAssembly, designed to produce the best possible assembly while still being fast enough to produce assembly faster than the WebAssembly is received over the wire.]]></description><guid isPermaLink="false">f6902c1c-3975-454f-891e-d39b071d66d4</guid><pubDate>Sat,  4 May 2019 10:10:34 +0100</pubDate><dc:creator>troubles.md</dc:creator></item><item><title>Building Simple APIs with Hyper and Usher</title><link>https://whitfin.io/building-simple-apis-with-hyper-and-usher/</link><description><![CDATA[When writing a web service, I often lean towards using tools that are as minimal as possible. One pretty obvious reason for this is the avoidance of dependencies you either don't want or don't need in your project. Whilst I'm not someone who goes out of their way to avoid dependencies, this is a pain point particularly in Rust because of the cost of building them repeatedly rather than shipping extra interpreted files around (especially if you use "pure" build environments).]]></description><guid isPermaLink="false">728cc414-7e29-41ce-86af-0181095c3ec6</guid><pubDate>Fri,  3 May 2019 16:56:26 +0000</pubDate><dc:creator>Isaac Whitfield</dc:creator></item><item><title>Explained: Futures in Rust for Web Development</title><link>https://dev.to/gruberb/explained-rust-futures-for-web-development-a10</link><description><![CDATA[If you are coming from NodeJS, Futures in Rust don't make much sense. In NodeJS, everything happens asynchronously. Therefore for you to be able to say "Hey, I really need to wait for the answer for this GET HTTP call", you are putting.then() on a Promise, so you can make sure you just execute the code inside the .then() when the HTTP call is finished.

In Rust, everything is blocking and synchronous by default, so you might ask yourself: "Why bothering with the complexity, that's exactly what I wanted in the first place!"]]></description><guid isPermaLink="false">9152c867-9b24-49d0-ac2c-d85775162eb4</guid><pubDate>Thu,  2 May 2019 00:00:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Hawk: Image Recognition Application using Rust and AWS Services</title><link>https://blog.knoldus.com/hawk-image-recognition-project-using-rust-and-aws-services/</link><description><![CDATA[Rust is one of the newest kid on the block in the modern programming languages. We tried to take advantage of its great features by using it in an Image Recognition blueprint project. This project can be traded with any existing security system deployed at any organization. Hawk uses AWS services integrated with Rust.]]></description><guid isPermaLink="false">dd64813c-9380-4cd5-b689-ae31cd1c0405</guid><pubDate>Wed,  1 May 2019 11:14:44 +0000</pubDate><dc:creator>muditchhabra6125</dc:creator></item><item><title>Using Wasmer for Plugins Part 4</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-4/index.html</link><description><![CDATA[In the last three posts of this series we covered all of the things we would need to use Wasmer as the base for a plugin system. In part one we went over the basics of passing simple data in and out of a web assembly module, in part two we dug deeper into how you might do the same with more complicated data. In the last part we eased the experience of plugin developers by encapsulating all of our work into a library that exports a procedural macro. In this post we are going to explore what it would take to extend an existing plugin system to allow for wasm plugins.]]></description><guid isPermaLink="false">16c5eef8-5844-4408-8ab5-42319757ecef</guid><pubDate>Wed,  1 May 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Gotham - From Start to Heroku</title><link>https://blog.codeship.com/gotham-from-start-to-heroku/</link><description><![CDATA[In this article, weâ€™ll implement and deploy a Gotham full-stack web framework using the Tera template system, Webpack for a complete front-end asset management, a minimal VueJS and CoffeeScript web app and deploy to Heroku. Gotham is a Rust framework which is focused on safety, speed, concurrency and async everything. Webpack is a NodeJS website asset preprocessor and bundler which can let you use any of your favorite front end technologies. Combining these technologies allow for a small footprint on the server, which means saving money on infrastructure, very fast performance in page load for higher visitor retention and the full flexibility of client side code available to you for web design without limitations.]]></description><guid isPermaLink="false">4136ae31-0128-4937-9c8b-91f064c0d8d6</guid><pubDate>Tue, 30 Apr 2019 15:15:20 +0000</pubDate><dc:creator>Daniel P. Clark</dc:creator></item><item><title>Rolling your own Router with Smithy v0.0.3</title><link>https://medium.com/@robert.balicki_2494/rolling-your-own-router-with-smithy-v0-0-3-2de17cdbb49</link><description><![CDATA[Build a WebAssembly application with a hash router using Smithy.]]></description><guid isPermaLink="false">4cc7ac88-4ef9-40fd-b235-bee8151e059d</guid><pubDate>Mon, 29 Apr 2019 15:25:25 +0000</pubDate><dc:creator>Robert Balicki</dc:creator></item><item><title>Simple Chat using Sonr-extras</title><link>https://hagsteel.com/posts/simple-chat/</link><description><![CDATA[Using sonr-extras to build a very basic chat using the provided connection handling objects.]]></description><guid isPermaLink="false">c9e2beae-20d5-4c7a-b8de-01f52b18aec1</guid><pubDate>Wed, 24 Apr 2019 00:00:00 +0200</pubDate><dc:creator>Jonas</dc:creator></item><item><title>Using Wasmer for Plugins Part 3</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-3/index.html</link><description><![CDATA[In the last two posts of this series we covered all of the things we would need to use Wasmer as the base for a plugin system. In part one we went over the basics of passing simple data in and out of a web assembly module, in part two we dug deeper into how you might do the same with more complicated data. In this part we are going to explore how we might ease the experience for people developing plugins for our application.]]></description><guid isPermaLink="false">bd3e3e37-90f2-4941-ba7c-00fdae65bdac</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Plume: Federated blogging application</title><link>https://github.com/Plume-org/Plume</link><description><![CDATA[Plume is a federated blogging engine, based on ActivityPub. It uses the Rocket framework, and Diesel to interact with the database.]]></description><guid isPermaLink="false">3d938fcd-0108-499a-9929-841d1999db4b</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Plume Developers</dc:creator></item><item><title>Using Wasmer for Plugins Part 2</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-2</link><description><![CDATA[In this post we are going to cover how we could pass more complicated data from the wasm module back to the runner.]]></description><guid isPermaLink="false">899be7d9-392f-4467-aa75-85b2d3e913f7</guid><pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Using Wasmer for Plugins Part 1</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-1</link><description><![CDATA[A few months ago, the Wasmer team announced a Web Assembly (aka wasm) interpreter that could be embedded into rust programs. This is particularly exciting for anyone looking to add plugins to their project and since Rust provides a way to directly compile programs to wasm, it seems like a perfect option. In this series of blog posts we are going to investigate what building a plugin system using wasmer and rust would take.]]></description><guid isPermaLink="false">d11c58e5-419a-4c3e-923d-b2bac810d445</guid><pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Web Development with Rust â€” 03/x: Create a REST API</title><link>https://dev.to/gruberb/web-development-with-rust-03-x-create-a-rest-api-3i82</link><description><![CDATA[The most common pattern for creating APIs is REST. We will discover how we can build an API in Rust which conforms with the REST pattern.]]></description><guid isPermaLink="false">f2b4f953-be42-4454-b073-1804aa4a8bb6</guid><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Face Detection with Actix Web</title><link>https://cetra3.github.io/blog/face-detection-with-actix-web/</link><description><![CDATA[Last article I wrote about how to use tensorflow with rust. This time we're going to take what we've built on, and serve it as an HTTP API call. As Actix Web is nearing its inevitable 1.0 release, I thought it would be a great time to build something with it.]]></description><guid isPermaLink="false">ea434653-4ba2-47c0-bc91-ba9c521dc419</guid><pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate><dc:creator>cetra3</dc:creator></item><item><title>Rust Actix Web + Magic link authentication</title><link>https://blog.approveapi.com/tutorials/rust-actix-web-approveapi-magic-login-link/</link><description><![CDATA[In this tutorial, we'll create web app using the Rust actix-web framework and implement magic link authentication powered by ApproveAPI's Rust library.]]></description><guid isPermaLink="false">98a6bda4-dcb1-419a-bf9a-6be8f4b88b8b</guid><pubDate>Tue,  9 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Alex Grinman</dc:creator></item><item><title>A Basic Web Application with Rust and Actix-web</title><link>https://zupzup.org/rust-webapp/</link><description><![CDATA[As a first little project in Rust I thought I'd do something familiar, so I created a small web application, which we'll check out in this post.]]></description><guid isPermaLink="false">dcd70897-0b31-4930-b57d-3fc567e64c98</guid><pubDate>Sun,  7 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Mario Zupan</dc:creator></item><item><title>Linkerd v2: How Lessons from Production Adoption Resulted in a Rewrite of the Service Mesh</title><link>https://www.infoq.com/articles/linkerd-v2-production-adoption</link><description><![CDATA[Linkerd 2.0 introduced a substantial rewrite of the widely adopted service mesh, using a split between Go and Rust. In this article, we discuss the lessons learned in the "cauldron of production adoption", and how those lessons became the basis of Linkerd 2.xâ€™s philosophy, design, and implementation.]]></description><guid isPermaLink="false">cbaf5407-81db-4367-9b58-ff9cc668b1a3</guid><pubDate>Fri,  5 Apr 2019 00:00:00 +0000</pubDate><dc:creator>William Morgan</dc:creator></item><item><title>Ocypod: Redis-backed job queue server with an easy to use HTTP interface</title><link>https://ocypod.readthedocs.io/</link><description><![CDATA[Ocypod is a language-agnostic, Redis-backed job queue server with an easy to use HTTP interface. Its focus is on handling and monitoring long running jobs.]]></description><guid isPermaLink="false">4fb7d3bc-05c5-4c23-abaa-70294fa23715</guid><pubDate>Wed,  3 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Dave Challis</dc:creator></item><item><title>WASI example using Rust and Lucet</title><link>https://hermanradtke.com/2019/04/01/wasi-example-using-rust-and-lucet.html</link><description><![CDATA[Lucet is Fastlyâ€™s native WebAssembly compiler and runtime. Using the Lucet runtime and Rustâ€™s wasm32-unknown-wasi target, we can create a WASM program that runs on the server.]]></description><guid isPermaLink="false">6d648c86-cd0a-4f11-ac22-af2fe977f6d6</guid><pubDate>Mon,  1 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Herman J. Radtke III</dc:creator></item><item><title>Introducing Smithyâ€Šâ€”â€ŠWebAssembly framework for Rust</title><link>https://medium.com/@robert.balicki_2494/introducing-smithy-webassembly-framework-for-rust-679d8fe9c16</link><description><![CDATA[Iâ€™m extremely excited to announce the 0.0.2 release of Smithy, a web development framework for Rust! While it is a very pre-alpha version, it should be functional enough for others to start playing around with. Please, get your feet wet and provide feedback.]]></description><guid isPermaLink="false">a1396ee1-4c3f-47c5-b99c-d7af8ea455a0</guid><pubDate>Thu, 28 Mar 2019 22:28:07 +0000</pubDate><dc:creator>Robert Balicki</dc:creator></item><item><title>The Wrangler CLI: Deploying Rust with WASM on Cloudflare Workers</title><link>https://blog.cloudflare.com/introducing-wrangler-cli/</link><description><![CDATA[Today, we're open sourcing and announcing wrangler, a CLI tool for building, previewing, and publishing Rust and WebAssembly Cloudflare Workers. If that sounds like some word salad to you, that's a reasonable reaction.]]></description><guid isPermaLink="false">5643e56a-6a6f-435e-8625-b58ebb5dca22</guid><pubDate>Thu, 28 Mar 2019 16:08:45 +0000</pubDate><dc:creator>Ashley Williams</dc:creator></item><item><title>Announcing Lucet: Fastlyâ€™s native WebAssembly compiler and runtime</title><link>https://www.fastly.com/blog/announcing-lucet-fastly-native-webassembly-compiler-runtime</link><description><![CDATA[Today, we are thrilled to announce the open sourcing of Lucet, Fastlyâ€™s native WebAssembly compiler and runtime. WebAssembly is a technology created to enable web browsers to safely execute programs at near-native speeds. It has been shipping in the four major browsers since early 2017.]]></description><guid isPermaLink="false">900ee12b-4a68-4987-a635-980b9105da76</guid><pubDate>Thu, 28 Mar 2019 16:00:00 +0000</pubDate><dc:creator>Pat Hickey</dc:creator></item><item><title>Gloo Update: Onion Layers, Timers, and Events</title><link>https://rustwasm.github.io/2019/03/26/gloo-onion-layers.html</link><description><![CDATA[About two weeks ago, we kicked off our effort to collectively build Gloo, a modular toolkit for building fast and reliable Web apps and libraries with Rust and Wasm. We knew we wanted to explicitly cultivate the Rust and Wasm library ecosystem by spinning out reusable, standalone libraries: things that would help you out whether you were writing a green-field Web app in pure-Rust, building your own framework, or surgically inserting some Rust-generated Wasm into an existing JavaScript project. What was still fuzzy, and which we didnâ€™t know yet, was how we were going design and expose these reusable bits.]]></description><guid isPermaLink="false">9ea71842-a6ca-41c6-8384-89c6a05d17cb</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Seed: A frontend framework for Rust, via WebAssembly</title><link>https://seed-rs.org/</link><description><![CDATA[I'm distinguishing Seed through clear examples and documentation, and using wasm-bindgen/web-sys internally. I started this project after being unable to get existing frameworks working due to lack of documented examples, and inconsistency between documentation and published versions. My intent is for anyone who's proficient in a frontend framework to get a standalone app working in the browser within a few minutes, using just the quickstart guide.

Seed's different approach to view syntax also distinguishes it: rather than use an HTML-like markup similar to JSX, it uses Rust builtin types, thinly-wrapped by macros that allow flexible composition. This decision will not appeal to everyone, but I think it integrates more naturally with the language.]]></description><guid isPermaLink="false">2da4fac1-5cb0-463b-9654-427f70d25255</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>David O&apos;Connor</dc:creator></item><item><title>tarssh: An async Rust SSH tarpit</title><link>https://hur.st/projects/tarssh/</link><description><![CDATA[tarssh is an SSH tarpit â€” a server that trickles an endlessly repeating introductory banner to clients for as long as it remains connected, in order to expend the resources of attackers. It's based on the same concept as Chris Wellons' Endlessh, a similar service written in C.]]></description><guid isPermaLink="false">9a041284-284c-472d-97c0-0e0cd407bb44</guid><pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Hurst</dc:creator></item><item><title>Web Development with Rust: Deploy your first App</title><link>https://dev.to/gruberb/web-programming-in-rust-02x-deploy-your-first-app-1k05</link><description><![CDATA[If you learn something new, always have an updated version of your project in production. It keeps you motivated. We cover the most common options of how to do this in and with Rust.]]></description><guid isPermaLink="false">6d82f826-46bb-4cb3-ba49-3a18c736f5ab</guid><pubDate>Tue, 19 Mar 2019 20:13:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Building and augmenting libraries by calling Rust from JavaScript</title><link>https://opensource.com/article/19/3/calling-rust-javascript</link><description><![CDATA[Explore how to use WebAssembly (Wasm) to embed Rust inside JavaScript.]]></description><guid isPermaLink="false">208250d2-7529-4548-b658-0b76353e05de</guid><pubDate>Mon, 18 Mar 2019 03:02:00 -0400</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>Fast, Bump-Allocated Virtual DOMs with Rust and Wasm</title><link>https://hacks.mozilla.org/2019/03/fast-bump-allocated-virtual-doms-with-rust-and-wasm/</link><description><![CDATA[Dodrio is a virtual DOM library written in Rust and WebAssembly. It takes advantage of both Wasmâ€™s linear memory and Rustâ€™s low-level control by designing virtual DOM rendering around bump allocation. Preliminary benchmark results suggest it has best-in-class performance.]]></description><guid isPermaLink="false">23efff3a-8be9-443e-bc32-9de200d2e173</guid><pubDate>Thu, 14 Mar 2019 16:54:44 +0000</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Introducing @now/rust</title><link>https://zeit.co/blog/introducing-now-rust</link><description><![CDATA[ZEIT is proud to announce official support for Rust on Now through `@now/rust`. Our mission at ZEIT is to make cloud computing accessible for all. Rust has seen rapid growth in its adoption, and we're proud to be able to support the community.]]></description><guid isPermaLink="false">ad39fd8f-6ca7-499e-bebb-f8a35d3d0a66</guid><pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate><dc:creator>ZEIT</dc:creator></item><item><title>WASP, a Lisp dialect for performant, concise Web Assembly modules</title><link>https://medium.com/@nbaltunian/wasp-a-lisp-dialect-for-performant-concise-web-assembly-modules-29f5f7282b6a</link><description><![CDATA[WASP is â€˜a LISP programming language for extremely performant and concise web assembly modules.â€™ That means that you can use WASP to generate WASM modules.]]></description><guid isPermaLink="false">356cc6f0-1e2a-4060-8b81-df1d1d6cd911</guid><pubDate>Sat,  9 Mar 2019 04:24:29 +0000</pubDate><dc:creator>Noah</dc:creator></item><item><title>Resize images from S3 with AWS Lambda and Rust</title><link>https://matsimitsu.com/blog/2019-03-09-resize-images-from-s3-with-aws-lambda-and-rust/</link><description><![CDATA[Using Rust and AWS Lambda to thumbnail images, cheaply, relablity, and quickly.]]></description><guid isPermaLink="false">3ad2e4d8-ffb5-4dcc-870e-e5c8dae3ca2a</guid><pubDate>Sat,  9 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Robert Beekman</dc:creator></item><item><title>Why should you use Rust in WebAssembly?</title><link>https://opensource.com/article/19/2/why-use-rust-webassembly</link><description><![CDATA[WebAssembly (Wasm) is a technology that has the chance to reshape how we build apps for the browser. Not only will it allow us to build whole new classes of web applications, but it will also allow us to make existing apps written in JavaScript even more performant.

In this article about the state of the Rust and Wasm ecosystem, I'll try to explain why Rust is the language that can unlock the true potential of WebAssembly.]]></description><guid isPermaLink="false">9496d523-3ad4-42ac-a6eb-183ed3d55713</guid><pubDate>Fri, 15 Feb 2019 03:01:00 -0500</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>Replacing a hot path in your app&apos;s JavaScript with WebAssembly</title><link>https://developers.google.com/web/updates/2019/02/hotpath-with-wasm</link><description><![CDATA[In my previous articles I talked about how WebAssembly allows you to bring the library ecosystem of C/C++ to the web. One app that makes extensive use of C/C++ libraries is squoosh, our web app that allows you compress images with a variety of codecs that have been compiled from C++ to WebAssembly.

In my experience, most performance problems on the web are caused by forced layout and excessive paint but every now and then an app needs to do a computationally expensive task that takes a lot of time. WebAssembly can help here.]]></description><guid isPermaLink="false">09067d7b-54fc-4555-9e1f-a6622ea5e390</guid><pubDate>Fri, 15 Feb 2019 07:38:00 +0000</pubDate><dc:creator>Surma</dc:creator></item><item><title>Introducing swc (speedy web compiler) 1.0</title><link>https://swc-project.github.io/blog/2019/02/08/Introducing-swc-1.0</link><description><![CDATA[swc(speedy web compiler) is a super-fast javascript to javascript compiler. It can transpile typescript / jsx / ecmascript 2019 to browser-compatible javascript. It's 16x - 20x faster than babel even on single-core synchronous benchmark. Note that actual performance gap is larger because swc works on worker thread while babel works on event loop thread.]]></description><guid isPermaLink="false">a3541593-fc72-40c3-a4b8-7fdad4cab8fe</guid><pubDate>Fri,  8 Feb 2019 00:00:00 +0000</pubDate><dc:creator>DongYoon Kang</dc:creator></item><item><title>Comparing C and Rust network protocol exercises - Ayende @ Rahien</title><link>https://ayende.com/blog/185859-A/comparing-c-and-rust-network-protocol-exercises?Key=bd1ba87d-6e7e-4739-824d-0ca6fc232b05</link><description><![CDATA[Almost by accident, it turned out that I implemented a pretty simple, but non trivial task in both C and Rust and blogged about them. Now that Iâ€™m done with both of them, I thought it would be interesting to talk about the differences in the experiences. The Rust version clocks at exactly 400 lines of code and uses 12 external crates. The C version has 911 lines of C code and another 140 lines in headers and depends on libuv and openssl.]]></description><guid isPermaLink="false">756d2f52-51dd-4408-ae79-3b17c02849e3</guid><pubDate>Tue,  5 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Ayende Rahien</dc:creator></item><item><title>Announcing OOProxy, a reverse OpenID and OAuth2 proxy</title><link>https://medium.com/hal24k-techblog/announcing-ooproxy-b041bab2bc85</link><description><![CDATA[At HAL24K, we benefit a lot from open source software. That is why, to contribute back, weâ€™ve started an internal program to open source some of the internal tools and libraries weâ€™ve used to build our platform and machine learning solutions, starting with OOProxy. OOProxy is a reverse OpenID and OAuth2 proxy that we use to protect our HTTP-based machine learning APIs.]]></description><guid isPermaLink="false">d430867d-388e-4cfb-9e42-698d80876f1c</guid><pubDate>Wed, 30 Jan 2019 14:10:08 +0000</pubDate><dc:creator>Tim Stokman</dc:creator></item><item><title>Embedding WebAssembly in your Rust application</title><link>https://medium.com/wasmer/executing-webassembly-in-your-rust-application-d5cd32e8ce46</link><description><![CDATA[Wasmer is a WebAssembly runtime designed to run both standalone and embedded. The crate wasmer-runtime exposes an easy to use and safe api for compiling, creating imports, and calling WebAssembly from your own library. This tutorial goes over how to make a simple wasm application and run it using the wasmer-runtime!]]></description><guid isPermaLink="false">94fdb740-ae30-402f-9dc5-3f98b6a2753a</guid><pubDate>Thu, 24 Jan 2019 17:20:46 +0000</pubDate><dc:creator>Brandon Fish and Lachlan Sneff</dc:creator></item><item><title>Enjoy a slice of QUIC, and Rust!</title><link>https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/</link><description><![CDATA[During last yearâ€™s Birthday Week we announced early support for QUIC, the next generation encrypted-by-default network transport protocol designed to secure and accelerate web traffic on the Internet.

We are not quite ready to make this feature available to every Cloudflare customer yet, but while you wait we thought you might enjoy a slice of quiche, our own open-source implementation of the QUIC protocol written in Rust.]]></description><guid isPermaLink="false">2810bb3d-7b68-42f0-ba5f-5c7a5956caf7</guid><pubDate>Tue, 22 Jan 2019 16:26:07 +0000</pubDate><dc:creator>Alessandro Ghedini</dc:creator></item><item><title>Exporting Serde types to TypeScript</title><link>http://timryan.org/2019/01/22/exporting-serde-types-to-typescript.html</link><description><![CDATA[I built my first web application with Rust and WebAssembly back in 2017. At the time, support for compiling Rust with the wasm32-unknown-unknown target had just landed, letting you run Rust code in the browser with few modifications. The downside was that loading and interacting with WebAssembly might require you to explicitly allocate and track memory. You might even need to manually decode UTF-8 strings in JavaScript:]]></description><guid isPermaLink="false">76ad8f41-d0b9-4789-b45a-5cfa550aa7c3</guid><pubDate>Tue, 22 Jan 2019 16:00:00 +0000</pubDate><dc:creator>Tim Ryan</dc:creator></item><item><title>WebGL + Rust: Basic Water Tutorial</title><link>http://www.chinedufn.com/3d-webgl-basic-water-tutorial/</link><description><![CDATA[In this tutorial weâ€™ll discuss the ideas and concepts behind rendering water and then talk through some demo code.]]></description><guid isPermaLink="false">0cba574e-769b-491e-83de-cfa070b1b942</guid><pubDate>Sun,  6 Jan 2019 13:00:00 -0500</pubDate><dc:creator>Chinedu Francis Nwafili</dc:creator></item><item><title>Rust and WebAssembly in 2019</title><link>http://fitzgeraldnick.com/2018/12/14/rust-and-webassembly-in-2019.html</link><description><![CDATA[Compiling Rust to WebAssembly should be the best choice for fast, reliable code for the Web. Additionally, the same way that Rust integrates with C calling conventions and libraries on native targets, Rust should also integrate with JavaScript and HTML5 on the Web. These are the Rust and WebAssembly domain working groupâ€™s core values. In 2018, we made it possible to surgically replace performance-sensitive JavaScript with Rust-generated WebAssembly. I propose that we make larger-scale adoption of Rust and WebAssembly practical in 2019.]]></description><guid isPermaLink="false">f12043be-3b2d-4ab3-8ce1-51463ffad905</guid><pubDate>Fri, 14 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Async in Rust, circa 2018</title><link>https://rust-lang-nursery.github.io/wg-net/2018/12/13/async-update.html</link><description><![CDATA[Rust 2018 has shipped, and weâ€™re closing in on the end of the year. While we didnâ€™t manage to ship async/await as part of the edition itself, the community has made quite a lot of progress toward that goal. This post summarizes the state of play, and announces the publication of several crates intended to facilitate use of async/await on the nightly ecosystem.]]></description><guid isPermaLink="false">53c9e07b-f4d5-423f-8a84-05e119814fda</guid><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Edge programming with Rust and WebAssembly</title><link>https://www.fastly.com/blog/edge-programming-rust-web-assembly</link><description><![CDATA[Take a developer deep dive into Terrarium, our multi-language, browser-based editor and deployment platform at the edge. Learn how to compile Rust programs to WebAssembly right on your local machine, interact with the Terrarium system, and explore some applications weâ€™ve built with it.]]></description><guid isPermaLink="false">78791a3b-395e-4d3b-b091-66aa2fa2c577</guid><pubDate>Wed, 12 Dec 2018 16:00:00 +0000</pubDate><dc:creator>Pat Hickey</dc:creator></item><item><title>Using Web Assembly in the Browser</title><link>https://ljcode.org/blog/wasm-part1/</link><description><![CDATA[WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. This essentially means that is is fast, because the program is compiled to a much more compact format, making it faster to parse. Wasm can be written by hand if you're looking for a challenge, but is primarily meant to be written in another language, and then compiled to Wasm. You may know a little about Assembly language and how it works - here's a quick refresher in-case you're rusty.]]></description><guid isPermaLink="false">27a7e602-da8a-4c0b-9ec1-81cc22c00df9</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Luke Jones</dc:creator></item><item><title>Rocket v0.4: Typed URIs, Database Support, Revamped Queries, &amp; More!</title><link>https://rocket.rs/v0.4/news/2018-12-08-version-0.4/</link><description><![CDATA[I am elated to announce that the next major release of Rocket is now available! Rocket 0.4 is a step forward in every direction: it is packed with features and improvements that increase developer productivity, improve application security and robustness, provide new opportunities for extensibility, and deliver a renewed degree of toolchain stability.]]></description><guid isPermaLink="false">9e21d91f-ef59-43f5-98c9-ba96d003fcb3</guid><pubDate>Sat,  8 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Sergio Benitez</dc:creator></item><item><title>Reflecting on Rust and WebAssembly in 2018</title><link>https://rustwasm.github.io/2018/12/06/reflecting-on-rust-and-wasm-in-2018.html</link><description><![CDATA[ðŸŽ‰ The 2018 edition of Rust has officially shipped, and the initial Rust and WebAssembly development story along with it! ðŸŽ‰ To see how far weâ€™ve come, letâ€™s reflect on the Rust and WebAssembly story a year ago: rustc could emit WebAssembly binaries for you, but that was about it. As far as communication with JavaScript went, you had to work with raw wasm imports and exports yourself. That meant you could only pass 32- and 64-bit integers and floats back and forth. No Rust structs, JavaScript objects, strings, or slices could be passed back forth. And distributing your libraryâ€™s .wasm so that other downstream projects could depend on it? Good luck.]]></description><guid isPermaLink="false">c0eb769f-4785-436d-b0b9-4bff16b30ef8</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Rust and WebAssembly</dc:creator></item><item><title>Wherefore art thou Romio?</title><link>http://boats.gitlab.io/blog/post/romio/</link><description><![CDATA[This blog post is about a project called Romio that Iâ€™ve been working on over the past two or three weeks. Romio is a port of a small part of the Tokio project to the newer futures APIs.

I started the project to get some experience porting code from the old futures API to the new API. However, we realized that this code could also be useful to other people who want to experiment with networking code using the new async/await syntax, so with the help of others we polished it up during the RustFest Rome â€œimpl daysâ€ and now its being released for people to experiment with.]]></description><guid isPermaLink="false">deadc4e1-1e13-49ca-b62b-cd8af455a164</guid><pubDate>Wed,  5 Dec 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Safe Web Services with Actix and Sentry</title><link>https://blog.sentry.io/2018/12/04/safe-web-services-actix-sentry</link><description><![CDATA[Enjoy this quick introduction to creating a web server with Actix and monitoring it with Sentry.]]></description><guid isPermaLink="false">05ee17e8-44f9-41c4-9f29-b4a5be430158</guid><pubDate>Tue,  4 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jan Michael Auer</dc:creator></item><item><title>CFG Game: Put your CS skills to good use and craft burgers</title><link>http://rickyhan.com/jekyll/update/2018/12/03/make-burgers-context-free-grammar.html</link><description><![CDATA[This past weekend I made a game for Ludum Dare 43. Tools used: Aseprite, quicksilver. Inspired by Zachtronics. It is written in Rust and compiled to WebAssembly.]]></description><guid isPermaLink="false">5493161b-6e7d-4b81-887f-af80a0d2c410</guid><pubDate>Mon,  3 Dec 2018 04:37:02 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>Dice.rs: Rust on Lambda</title><link>https://kellenfujimoto.com/posts/dicers-rust-on-lambda/</link><description><![CDATA[Rust support on AWS Lambda was recently released, which seems like as good an opportunity as any to share some code and the solutions to challenges I encountered along the way â˜º. Iâ€™ve decided to create a little diceware service, and the lambda-runtime crate provides a great API to make this a breeze.]]></description><guid isPermaLink="false">c52eda57-1761-4ec3-9e59-c4c45d665574</guid><pubDate>Sun,  2 Dec 2018 14:18:59 +0100</pubDate><dc:creator>Kellen Frodelius-Fujimoto</dc:creator></item><item><title>Creating my first AWS Lambda using Rust</title><link>https://medium.com/@kkostov/rust-aws-lambda-30a1b92d4009</link><description><![CDATA[Taking advantage of AWS Lambda Runtime support for Rust]]></description><guid isPermaLink="false">7df2b166-e70e-4b15-bf6e-9475a81096e9</guid><pubDate>Sun,  2 Dec 2018 12:40:16 +0000</pubDate><dc:creator>Konstantin</dc:creator></item><item><title>Rust Runtime for AWS Lambda</title><link>https://aws.amazon.com/blogs/opensource/rust-runtime-for-aws-lambda/</link><description><![CDATA[AWS Lambda, which makes it easy for developers to run code for virtually any type of application or backend service with zero administration, has just announced the Runtime APIs. The Runtime APIs define an HTTP-based specification of the Lambda programming model which can be implemented in any programming language. To accompany the API launch, we have open sourced a runtime for the Rust language.]]></description><guid isPermaLink="false">48218be5-130b-4274-b41a-7bfa20086f0d</guid><pubDate>Thu, 29 Nov 2018 18:02:27 +0000</pubDate><dc:creator>Stefano Buliani</dc:creator></item><item><title>Serverless HTTP in Rust</title><link>https://medium.com/@softprops/serverless-http-9a58f9b2df60</link><description><![CDATA[Throw down your main! Rustlang Serverless HTTP applications wonâ€™t need them where theyâ€™re going]]></description><guid isPermaLink="false">c1576100-8199-418d-bd9a-03c71f1b5559</guid><pubDate>Wed, 28 Nov 2018 11:11:52 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Rust Web Survey Results 2018</title><link>https://rust-lang-nursery.github.io/wg-net/2018/11/28/wg-net-survey.html</link><description><![CDATA[We recently sent out a survey regarding the state of the current Rust web ecosystem and we got over a 1000 responses! We really appreciate the feedback from the community. This will help us continue to improve upon the state of the Rust web ecosystem. Today, we would like to go over the responses and understand the results.]]></description><guid isPermaLink="false">881d8c07-ccf4-48be-ab22-bd76cc7c848d</guid><pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Bhargav Voleti</dc:creator></item><item><title>Tideâ€™s evolving middleware approach</title><link>https://rust-lang-nursery.github.io/wg-net/2018/11/27/tide-middleware-evolution.html</link><description><![CDATA[Since the last post on Tide, there have been a number of excellent contributions from a bunch of new contributors! In this post, I want to talk about the work that @tirr-c has done to substantially improve the middleware story.]]></description><guid isPermaLink="false">abba07ed-5ffb-4b29-ba29-f1e6dbdce718</guid><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Generating Sudoku Boards pt. 3: Rust for WebAssembly</title><link>https://medium.com/@rossharrison/generating-sudoku-boards-pt-3-rust-for-webassembly-85bd7294c34a</link><description><![CDATA[Adjusting an existing Rust project to build a native binary and library for WASM, load in JS. Details on working through build issues.]]></description><guid isPermaLink="false">108e3952-7d7b-4fcc-9c76-073646f2ddee</guid><pubDate>Mon, 26 Nov 2018 00:18:40 +0000</pubDate><dc:creator>Ross Harrison</dc:creator></item><item><title>Generic Methods in Rust: How Exonum Shifted from Iron to Actix-web</title><link>https://medium.com/meetbitfury/generic-methods-in-rust-how-exonum-shifted-from-iron-to-actix-web-7a2752171388</link><description><![CDATA[In this article, we describe how we ported the Exonum framework to actix-web using generic programming.]]></description><guid isPermaLink="false">c5b56719-bdcd-4d91-8b61-85a27cd5315c</guid><pubDate>Wed, 21 Nov 2018 10:51:32 +0000</pubDate><dc:creator>Exonum</dc:creator></item><item><title>Bringing Elmâ€™s architecture to Rust and Webassembly</title><link>https://sindrejohansen.no/blog/willow/rust/elm/2018/11/16/willow-elm-in-rust.html</link><description><![CDATA[I really like Elm. It is a delightful language with an amazing ecosystem. It has an interesting architecture called TEA, The Elm Architecture. Another language I like is Rust. On paper, Rust is completely different from Elm, but in using them both, I have seen some resemblance. Having used both Elm and Rust I had something I wanted to try. Would it be possible to create The Elm Architecture in Rust?]]></description><guid isPermaLink="false">ad136bed-3540-4ced-8a77-448b94426ba3</guid><pubDate>Fri, 16 Nov 2018 16:35:22 +0000</pubDate><dc:creator>Sindre</dc:creator></item><item><title>Running Rust natively in AWS Lambda and testing it locally</title><link>https://medium.com/@bernardo.belchior1/running-rust-natively-in-aws-lambda-and-testing-it-locally-57080421426d</link><description><![CDATA[Abusing Go runtime in AWS to run Rust binaries]]></description><guid isPermaLink="false">97715a00-432f-4cfa-9c11-92f0d74ff60e</guid><pubDate>Mon, 12 Nov 2018 14:23:33 +0000</pubDate><dc:creator>Bernardo Belchior</dc:creator></item><item><title>Serve archived static files over HTTP</title><link>https://deterministic.space/serve-archived-static-files-over-http.html</link><description><![CDATA[Say you want to store a huge number of very small filesthat you will only access over HTTP.For example:You are using rustdoc to render the documentation of a library.Without much work youâ€™ll end up with about 100k HTML filesthat are about 10kB each.As it turns out,this number of small files is very annoying for any kind of file system performance.Best case: making copies/backups is slow.Worst case: Youâ€™re using an anti virus software and it takes ages.]]></description><guid isPermaLink="false">b2687a6e-55b3-4d3b-a025-fc9e7c592e8e</guid><pubDate>Sun, 11 Nov 2018 00:00:00 +0100</pubDate><dc:creator>Pascal Hertleif</dc:creator></item><item><title>Middleware in Tide</title><link>https://rust-lang-nursery.github.io/wg-net/2018/11/07/tide-middleware.html</link><description><![CDATA[After the positive response to the routing and extraction proposal in Tide, Iâ€™m pleased to say that an initial implementation is available on GitHub! As a testament to the strong foundation that Rustâ€™s ecosystem provides, the basic framework implementation took only about 1,000 lines of code.]]></description><guid isPermaLink="false">b8931a7e-08d1-406b-b751-6bd27a9d4d67</guid><pubDate>Wed,  7 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Serverless Rust</title><link>https://medium.com/@softprops/serverless-rust-318732a3596</link><description><![CDATA[This is going to be the first post ( and hopefully not last ) in a series of posts about writing (and thinking about) serverless applications in Rust. Stay tunedâ€¦]]></description><guid isPermaLink="false">4b5e36d0-0775-48da-a6f9-ab19ce9a5aae</guid><pubDate>Tue, 30 Oct 2018 02:08:22 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item></channel></rss>