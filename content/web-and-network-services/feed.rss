<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Read Rust - Web and Network Services</title><link>https://readrust.net/</link><description>Web and Network Services posts on Read Rust</description><item><title>Gopher Server in Rust</title><link>https://gkbrk.com/2019/06/gopher-server/</link><description><![CDATA[I find Gopher really cool. I think itâ€™s a really nice way to organize information into trees and hierarchies, and as we all know programmers canâ€™t resist trees. So recently I took an interest in Gopher and started writing my own server.

But recently itâ€™s been gaining traction; so we should provide a decent landscape for new gophers, full of oxidised servers. Since I started using Gopher more often, itâ€™s beneficial for me if thereâ€™s more content out there. So Iâ€™m writing this blog post to walk you through how to write your own server. Weâ€™ll be doing this in Rust.]]></description><guid isPermaLink="false">91ae37e0-3d4f-4c78-879d-47e635f8fbda</guid><pubDate>Sun,  2 Jun 2019 01:00:00 +0100</pubDate><dc:creator>Gokberk Yaltirakli</dc:creator></item><item><title>Creating a Static HTTP Server with Rust â€“ Part 2</title><link>http://concisecoder.io/2019/05/27/creating-a-static-http-server-with-rust-part-2/</link><description><![CDATA[In this series, we are creating a basic static HTTP 1.0 server with Rust. If you havenâ€™t seen Part 1 yet, go do that first. At the end of Part 2, our server will do the following: Read and serve files from a predefined directory on the host server, Generate appropriate HTTP responses to incoming requests, Log information about the response to standard output.]]></description><guid isPermaLink="false">4e723122-0527-43dc-b95b-ff4fd5cd5d28</guid><pubDate>Mon, 27 May 2019 13:25:29 +0000</pubDate><dc:creator>Levi Payne</dc:creator></item><item><title>Programming Servo: Zen and the art of removing blocks from your system</title><link>https://medium.com/@polyglot_factotum/programming-servo-zen-and-the-art-of-removing-blocks-from-your-system-51c1b7d404e3</link><description><![CDATA[It all started with a simple issue, a â€œquick fixâ€, or so I thought.]]></description><guid isPermaLink="false">0cc7297b-a14f-443d-a02a-073685c663a3</guid><pubDate>Sun, 26 May 2019 09:41:02 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Blockchain-Flavored WASI</title><link>https://medium.com/oasislabs/blockchain-flavored-wasi-50e3612b8eba</link><description><![CDATA[General purpose computation on the blockchain using Web Assembly System Interface (WASI).]]></description><guid isPermaLink="false">fe48ce77-ad77-4983-a08d-1fb9cf951bb1</guid><pubDate>Thu, 23 May 2019 04:07:55 +0000</pubDate><dc:creator>Nick Hynes</dc:creator></item><item><title>Running WebAssembly on the Kernel</title><link>https://medium.com/wasmer/running-webassembly-on-the-kernel-8e04761f1d8e</link><description><![CDATA[This is the story of our journey running Wasmer on the Linux kernel.]]></description><guid isPermaLink="false">ef3c5cdb-f130-4211-83a1-1550ea15d73f</guid><pubDate>Thu, 16 May 2019 22:37:36 +0000</pubDate><dc:creator>Heyang Zhou</dc:creator></item><item><title>How to start a Rust Chat App</title><link>https://www.steadylearner.com/blog/read/How-to-start-Rust-Chat-App</link><description><![CDATA[In this post, we will learn how to build simple chat app in your local machine with Rust and simple JavaScript.]]></description><guid isPermaLink="false">e25cac18-f4ca-4872-babe-c4614327e076</guid><pubDate>Thu, 16 May 2019 00:00:00 +0000</pubDate><dc:creator>Steadylearner</dc:creator></item><item><title>Introducing Packem: a super fast experimental bundler written in Rust</title><link>https://medium.freecodecamp.org/introducing-packem-a-super-fast-experimental-bundler-written-in-rust-e981af875517</link><description><![CDATA[Packem is an experimental precompiled JavaScript module bundler primarily implemented in Rust. It can also handle a variety of other file types like YAML/TOML, fragment shader files and a lot more.]]></description><guid isPermaLink="false">3eb814d5-d467-4e34-ba31-e0a55da4da36</guid><pubDate>Wed, 15 May 2019 16:36:27 +0000</pubDate><dc:creator>Bukhari Muhammad</dc:creator></item><item><title>Creating a Static HTTP Server with Rust - Part 1</title><link>http://concisecoder.io/2019/05/11/creating-a-static-http-server-with-rust-part-1/</link><description><![CDATA[In this series, we will create a basic static HTTP 1.0 server with Rust. At the end of Part 1 of this tutorial, our server will do the following: Listen for and handle TCP connections on a specific port, Accept HTTP 1.0 GET requests, Parse and validate requests for further use, Log incoming requests. We will avoid using libraries that make this trivial (i.e. the http crate) and focus on the fundamentals of how a server works.]]></description><guid isPermaLink="false">25d9490f-05e3-4f5c-a407-19d78b0fb6d4</guid><pubDate>Sat, 11 May 2019 17:17:46 +0000</pubDate><dc:creator>Levi Payne</dc:creator></item><item><title>Unit testing Rust using Chrome</title><link>https://medium.com/visly/unit-testing-rust-using-chrome-b8b93572a91d</link><description><![CDATA[Stretch is a cross-platform Flexbox engine written in Rust. At Visly we are building a design tool for front-end engineers and we needed to ensure components looked the same across web, iOS, and Android without making use of WebViews. This meant replicating the web layout system on mobile.

In this post, Iâ€™ll cover the test setup we use in Stretch, how and why we need to generate unit dynamically. Iâ€™ll also cover an example of contributing another test to Stretch, and finally Iâ€™ll walk through how we also make use of this system for benchmarking.]]></description><guid isPermaLink="false">ffeaa8e5-849b-4924-9c9f-1ac6adc15a8e</guid><pubDate>Mon,  6 May 2019 16:25:41 +0000</pubDate><dc:creator>Emil SjÃ¶lander</dc:creator></item><item><title>WebAssembly -Part II.A | Wasm with Rust</title><link>https://medium.com/tech-lah/webassembly-part-ii-a-wasm-with-rust-2356dbc6526e</link><description><![CDATA[This article is more of a how-to on getting up and running with a production-grade web project which incorporates Rust (or any other language for that matter) and WebAssembly into your web pages.]]></description><guid isPermaLink="false">e3fadb7b-df84-47a1-b6ca-47186b2b9418</guid><pubDate>Sun,  5 May 2019 13:27:01 +0000</pubDate><dc:creator>Francisco Vilches</dc:creator></item><item><title>Building Simple APIs with Hyper and Usher</title><link>https://whitfin.io/building-simple-apis-with-hyper-and-usher/</link><description><![CDATA[When writing a web service, I often lean towards using tools that are as minimal as possible. One pretty obvious reason for this is the avoidance of dependencies you either don't want or don't need in your project. Whilst I'm not someone who goes out of their way to avoid dependencies, this is a pain point particularly in Rust because of the cost of building them repeatedly rather than shipping extra interpreted files around (especially if you use "pure" build environments).]]></description><guid isPermaLink="false">728cc414-7e29-41ce-86af-0181095c3ec6</guid><pubDate>Fri,  3 May 2019 16:56:26 +0000</pubDate><dc:creator>Isaac Whitfield</dc:creator></item><item><title>Explained: Futures in Rust for Web Development</title><link>https://dev.to/gruberb/explained-rust-futures-for-web-development-a10</link><description><![CDATA[If you are coming from NodeJS, Futures in Rust don't make much sense. In NodeJS, everything happens asynchronously. Therefore for you to be able to say "Hey, I really need to wait for the answer for this GET HTTP call", you are putting.then() on a Promise, so you can make sure you just execute the code inside the .then() when the HTTP call is finished.

In Rust, everything is blocking and synchronous by default, so you might ask yourself: "Why bothering with the complexity, that's exactly what I wanted in the first place!"]]></description><guid isPermaLink="false">9152c867-9b24-49d0-ac2c-d85775162eb4</guid><pubDate>Thu,  2 May 2019 00:00:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Hawk: Image Recognition Application using Rust and AWS Services</title><link>https://blog.knoldus.com/hawk-image-recognition-project-using-rust-and-aws-services/</link><description><![CDATA[Rust is one of the newest kid on the block in the modern programming languages. We tried to take advantage of its great features by using it in an Image Recognition blueprint project. This project can be traded with any existing security system deployed at any organization. Hawk uses AWS services integrated with Rust.]]></description><guid isPermaLink="false">dd64813c-9380-4cd5-b689-ae31cd1c0405</guid><pubDate>Wed,  1 May 2019 11:14:44 +0000</pubDate><dc:creator>muditchhabra6125</dc:creator></item><item><title>Using Wasmer for Plugins Part 4</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-4/index.html</link><description><![CDATA[In the last three posts of this series we covered all of the things we would need to use Wasmer as the base for a plugin system. In part one we went over the basics of passing simple data in and out of a web assembly module, in part two we dug deeper into how you might do the same with more complicated data. In the last part we eased the experience of plugin developers by encapsulating all of our work into a library that exports a procedural macro. In this post we are going to explore what it would take to extend an existing plugin system to allow for wasm plugins.]]></description><guid isPermaLink="false">16c5eef8-5844-4408-8ab5-42319757ecef</guid><pubDate>Wed,  1 May 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Rolling your own Router with Smithy v0.0.3</title><link>https://medium.com/@robert.balicki_2494/rolling-your-own-router-with-smithy-v0-0-3-2de17cdbb49</link><description><![CDATA[Build a WebAssembly application with a hash router using Smithy.]]></description><guid isPermaLink="false">4cc7ac88-4ef9-40fd-b235-bee8151e059d</guid><pubDate>Mon, 29 Apr 2019 15:25:25 +0000</pubDate><dc:creator>Robert Balicki</dc:creator></item><item><title>Simple Chat using Sonr-extras</title><link>https://hagsteel.com/posts/simple-chat/</link><description><![CDATA[Using sonr-extras to build a very basic chat using the provided connection handling objects.]]></description><guid isPermaLink="false">c9e2beae-20d5-4c7a-b8de-01f52b18aec1</guid><pubDate>Wed, 24 Apr 2019 00:00:00 +0200</pubDate><dc:creator>Jonas</dc:creator></item><item><title>Using Wasmer for Plugins Part 3</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-3/index.html</link><description><![CDATA[In the last two posts of this series we covered all of the things we would need to use Wasmer as the base for a plugin system. In part one we went over the basics of passing simple data in and out of a web assembly module, in part two we dug deeper into how you might do the same with more complicated data. In this part we are going to explore how we might ease the experience for people developing plugins for our application.]]></description><guid isPermaLink="false">bd3e3e37-90f2-4941-ba7c-00fdae65bdac</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Plume: Federated blogging application</title><link>https://github.com/Plume-org/Plume</link><description><![CDATA[Plume is a federated blogging engine, based on ActivityPub. It uses the Rocket framework, and Diesel to interact with the database.]]></description><guid isPermaLink="false">3d938fcd-0108-499a-9929-841d1999db4b</guid><pubDate>Mon, 22 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Plume Developers</dc:creator></item><item><title>Using Wasmer for Plugins Part 2</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-2</link><description><![CDATA[In this post we are going to cover how we could pass more complicated data from the wasm module back to the runner.]]></description><guid isPermaLink="false">899be7d9-392f-4467-aa75-85b2d3e913f7</guid><pubDate>Sat, 20 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Using Wasmer for Plugins Part 1</title><link>https://wiredforge.com/blog/wasmer-plugin-pt-1</link><description><![CDATA[A few months ago, the Wasmer team announced a Web Assembly (aka wasm) interpreter that could be embedded into rust programs. This is particularly exciting for anyone looking to add plugins to their project and since Rust provides a way to directly compile programs to wasm, it seems like a perfect option. In this series of blog posts we are going to investigate what building a plugin system using wasmer and rust would take.]]></description><guid isPermaLink="false">d11c58e5-419a-4c3e-923d-b2bac810d445</guid><pubDate>Fri, 19 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Robert Masen</dc:creator></item><item><title>Web Development with Rust â€” 03/x: Create a REST API</title><link>https://dev.to/gruberb/web-development-with-rust-03-x-create-a-rest-api-3i82</link><description><![CDATA[The most common pattern for creating APIs is REST. We will discover how we can build an API in Rust which conforms with the REST pattern.]]></description><guid isPermaLink="false">f2b4f953-be42-4454-b073-1804aa4a8bb6</guid><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Face Detection with Actix Web</title><link>https://cetra3.github.io/blog/face-detection-with-actix-web/</link><description><![CDATA[Last article I wrote about how to use tensorflow with rust. This time we're going to take what we've built on, and serve it as an HTTP API call. As Actix Web is nearing its inevitable 1.0 release, I thought it would be a great time to build something with it.]]></description><guid isPermaLink="false">ea434653-4ba2-47c0-bc91-ba9c521dc419</guid><pubDate>Thu, 11 Apr 2019 00:00:00 +0000</pubDate><dc:creator>cetra3</dc:creator></item><item><title>Rust Actix Web + Magic link authentication</title><link>https://blog.approveapi.com/tutorials/rust-actix-web-approveapi-magic-login-link/</link><description><![CDATA[In this tutorial, we'll create web app using the Rust actix-web framework and implement magic link authentication powered by ApproveAPI's Rust library.]]></description><guid isPermaLink="false">98a6bda4-dcb1-419a-bf9a-6be8f4b88b8b</guid><pubDate>Tue,  9 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Alex Grinman</dc:creator></item><item><title>A Basic Web Application with Rust and Actix-web</title><link>https://zupzup.org/rust-webapp/</link><description><![CDATA[As a first little project in Rust I thought I'd do something familiar, so I created a small web application, which we'll check out in this post.]]></description><guid isPermaLink="false">dcd70897-0b31-4930-b57d-3fc567e64c98</guid><pubDate>Sun,  7 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Mario Zupan</dc:creator></item><item><title>Linkerd v2: How Lessons from Production Adoption Resulted in a Rewrite of the Service Mesh</title><link>https://www.infoq.com/articles/linkerd-v2-production-adoption</link><description><![CDATA[Linkerd 2.0 introduced a substantial rewrite of the widely adopted service mesh, using a split between Go and Rust. In this article, we discuss the lessons learned in the "cauldron of production adoption", and how those lessons became the basis of Linkerd 2.xâ€™s philosophy, design, and implementation.]]></description><guid isPermaLink="false">cbaf5407-81db-4367-9b58-ff9cc668b1a3</guid><pubDate>Fri,  5 Apr 2019 00:00:00 +0000</pubDate><dc:creator>William Morgan</dc:creator></item><item><title>Ocypod: Redis-backed job queue server with an easy to use HTTP interface</title><link>https://ocypod.readthedocs.io/</link><description><![CDATA[Ocypod is a language-agnostic, Redis-backed job queue server with an easy to use HTTP interface. Its focus is on handling and monitoring long running jobs.]]></description><guid isPermaLink="false">4fb7d3bc-05c5-4c23-abaa-70294fa23715</guid><pubDate>Wed,  3 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Dave Challis</dc:creator></item><item><title>WASI example using Rust and Lucet</title><link>https://hermanradtke.com/2019/04/01/wasi-example-using-rust-and-lucet.html</link><description><![CDATA[Lucet is Fastlyâ€™s native WebAssembly compiler and runtime. Using the Lucet runtime and Rustâ€™s wasm32-unknown-wasi target, we can create a WASM program that runs on the server.]]></description><guid isPermaLink="false">6d648c86-cd0a-4f11-ac22-af2fe977f6d6</guid><pubDate>Mon,  1 Apr 2019 00:00:00 +0000</pubDate><dc:creator>Herman J. Radtke III</dc:creator></item><item><title>Introducing Smithyâ€Šâ€”â€ŠWebAssembly framework for Rust</title><link>https://medium.com/@robert.balicki_2494/introducing-smithy-webassembly-framework-for-rust-679d8fe9c16</link><description><![CDATA[Iâ€™m extremely excited to announce the 0.0.2 release of Smithy, a web development framework for Rust! While it is a very pre-alpha version, it should be functional enough for others to start playing around with. Please, get your feet wet and provide feedback.]]></description><guid isPermaLink="false">a1396ee1-4c3f-47c5-b99c-d7af8ea455a0</guid><pubDate>Thu, 28 Mar 2019 22:28:07 +0000</pubDate><dc:creator>Robert Balicki</dc:creator></item><item><title>The Wrangler CLI: Deploying Rust with WASM on Cloudflare Workers</title><link>https://blog.cloudflare.com/introducing-wrangler-cli/</link><description><![CDATA[Today, we're open sourcing and announcing wrangler, a CLI tool for building, previewing, and publishing Rust and WebAssembly Cloudflare Workers. If that sounds like some word salad to you, that's a reasonable reaction.]]></description><guid isPermaLink="false">5643e56a-6a6f-435e-8625-b58ebb5dca22</guid><pubDate>Thu, 28 Mar 2019 16:08:45 +0000</pubDate><dc:creator>Ashley Williams</dc:creator></item><item><title>Announcing Lucet: Fastlyâ€™s native WebAssembly compiler and runtime</title><link>https://www.fastly.com/blog/announcing-lucet-fastly-native-webassembly-compiler-runtime</link><description><![CDATA[Today, we are thrilled to announce the open sourcing of Lucet, Fastlyâ€™s native WebAssembly compiler and runtime. WebAssembly is a technology created to enable web browsers to safely execute programs at near-native speeds. It has been shipping in the four major browsers since early 2017.]]></description><guid isPermaLink="false">900ee12b-4a68-4987-a635-980b9105da76</guid><pubDate>Thu, 28 Mar 2019 16:00:00 +0000</pubDate><dc:creator>Pat Hickey</dc:creator></item><item><title>Gloo Update: Onion Layers, Timers, and Events</title><link>https://rustwasm.github.io/2019/03/26/gloo-onion-layers.html</link><description><![CDATA[About two weeks ago, we kicked off our effort to collectively build Gloo, a modular toolkit for building fast and reliable Web apps and libraries with Rust and Wasm. We knew we wanted to explicitly cultivate the Rust and Wasm library ecosystem by spinning out reusable, standalone libraries: things that would help you out whether you were writing a green-field Web app in pure-Rust, building your own framework, or surgically inserting some Rust-generated Wasm into an existing JavaScript project. What was still fuzzy, and which we didnâ€™t know yet, was how we were going design and expose these reusable bits.]]></description><guid isPermaLink="false">9ea71842-a6ca-41c6-8384-89c6a05d17cb</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Seed: A frontend framework for Rust, via WebAssembly</title><link>https://seed-rs.org/</link><description><![CDATA[I'm distinguishing Seed through clear examples and documentation, and using wasm-bindgen/web-sys internally. I started this project after being unable to get existing frameworks working due to lack of documented examples, and inconsistency between documentation and published versions. My intent is for anyone who's proficient in a frontend framework to get a standalone app working in the browser within a few minutes, using just the quickstart guide.

Seed's different approach to view syntax also distinguishes it: rather than use an HTML-like markup similar to JSX, it uses Rust builtin types, thinly-wrapped by macros that allow flexible composition. This decision will not appeal to everyone, but I think it integrates more naturally with the language.]]></description><guid isPermaLink="false">2da4fac1-5cb0-463b-9654-427f70d25255</guid><pubDate>Tue, 26 Mar 2019 00:00:00 +0000</pubDate><dc:creator>David O&apos;Connor</dc:creator></item><item><title>tarssh: An async Rust SSH tarpit</title><link>https://hur.st/projects/tarssh/</link><description><![CDATA[tarssh is an SSH tarpit â€” a server that trickles an endlessly repeating introductory banner to clients for as long as it remains connected, in order to expend the resources of attackers. It's based on the same concept as Chris Wellons' Endlessh, a similar service written in C.]]></description><guid isPermaLink="false">9a041284-284c-472d-97c0-0e0cd407bb44</guid><pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Thomas Hurst</dc:creator></item><item><title>Web Development with Rust: Deploy your first App</title><link>https://dev.to/gruberb/web-programming-in-rust-02x-deploy-your-first-app-1k05</link><description><![CDATA[If you learn something new, always have an updated version of your project in production. It keeps you motivated. We cover the most common options of how to do this in and with Rust.]]></description><guid isPermaLink="false">6d82f826-46bb-4cb3-ba49-3a18c736f5ab</guid><pubDate>Tue, 19 Mar 2019 20:13:00 +0000</pubDate><dc:creator>Bastian Gruber</dc:creator></item><item><title>Building and augmenting libraries by calling Rust from JavaScript</title><link>https://opensource.com/article/19/3/calling-rust-javascript</link><description><![CDATA[Explore how to use WebAssembly (Wasm) to embed Rust inside JavaScript.]]></description><guid isPermaLink="false">208250d2-7529-4548-b658-0b76353e05de</guid><pubDate>Mon, 18 Mar 2019 03:02:00 -0400</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>Fast, Bump-Allocated Virtual DOMs with Rust and Wasm</title><link>https://hacks.mozilla.org/2019/03/fast-bump-allocated-virtual-doms-with-rust-and-wasm/</link><description><![CDATA[Dodrio is a virtual DOM library written in Rust and WebAssembly. It takes advantage of both Wasmâ€™s linear memory and Rustâ€™s low-level control by designing virtual DOM rendering around bump allocation. Preliminary benchmark results suggest it has best-in-class performance.]]></description><guid isPermaLink="false">23efff3a-8be9-443e-bc32-9de200d2e173</guid><pubDate>Thu, 14 Mar 2019 16:54:44 +0000</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Introducing @now/rust</title><link>https://zeit.co/blog/introducing-now-rust</link><description><![CDATA[ZEIT is proud to announce official support for Rust on Now through `@now/rust`. Our mission at ZEIT is to make cloud computing accessible for all. Rust has seen rapid growth in its adoption, and we're proud to be able to support the community.]]></description><guid isPermaLink="false">ad39fd8f-6ca7-499e-bebb-f8a35d3d0a66</guid><pubDate>Tue, 12 Mar 2019 00:00:00 +0000</pubDate><dc:creator>ZEIT</dc:creator></item><item><title>WASP, a Lisp dialect for performant, concise Web Assembly modules</title><link>https://medium.com/@nbaltunian/wasp-a-lisp-dialect-for-performant-concise-web-assembly-modules-29f5f7282b6a</link><description><![CDATA[WASP is â€˜a LISP programming language for extremely performant and concise web assembly modules.â€™ That means that you can use WASP to generate WASM modules.]]></description><guid isPermaLink="false">356cc6f0-1e2a-4060-8b81-df1d1d6cd911</guid><pubDate>Sat,  9 Mar 2019 04:24:29 +0000</pubDate><dc:creator>Noah</dc:creator></item><item><title>Resize images from S3 with AWS Lambda and Rust</title><link>https://matsimitsu.com/blog/2019-03-09-resize-images-from-s3-with-aws-lambda-and-rust/</link><description><![CDATA[Using Rust and AWS Lambda to thumbnail images, cheaply, relablity, and quickly.]]></description><guid isPermaLink="false">3ad2e4d8-ffb5-4dcc-870e-e5c8dae3ca2a</guid><pubDate>Sat,  9 Mar 2019 00:00:00 +0000</pubDate><dc:creator>Robert Beekman</dc:creator></item><item><title>Why should you use Rust in WebAssembly?</title><link>https://opensource.com/article/19/2/why-use-rust-webassembly</link><description><![CDATA[WebAssembly (Wasm) is a technology that has the chance to reshape how we build apps for the browser. Not only will it allow us to build whole new classes of web applications, but it will also allow us to make existing apps written in JavaScript even more performant.

In this article about the state of the Rust and Wasm ecosystem, I'll try to explain why Rust is the language that can unlock the true potential of WebAssembly.]]></description><guid isPermaLink="false">9496d523-3ad4-42ac-a6eb-183ed3d55713</guid><pubDate>Fri, 15 Feb 2019 03:01:00 -0500</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>Replacing a hot path in your app&apos;s JavaScript with WebAssembly</title><link>https://developers.google.com/web/updates/2019/02/hotpath-with-wasm</link><description><![CDATA[In my previous articles I talked about how WebAssembly allows you to bring the library ecosystem of C/C++ to the web. One app that makes extensive use of C/C++ libraries is squoosh, our web app that allows you compress images with a variety of codecs that have been compiled from C++ to WebAssembly.

In my experience, most performance problems on the web are caused by forced layout and excessive paint but every now and then an app needs to do a computationally expensive task that takes a lot of time. WebAssembly can help here.]]></description><guid isPermaLink="false">09067d7b-54fc-4555-9e1f-a6622ea5e390</guid><pubDate>Fri, 15 Feb 2019 07:38:00 +0000</pubDate><dc:creator>Surma</dc:creator></item><item><title>Introducing swc (speedy web compiler) 1.0</title><link>https://swc-project.github.io/blog/2019/02/08/Introducing-swc-1.0</link><description><![CDATA[swc(speedy web compiler) is a super-fast javascript to javascript compiler. It can transpile typescript / jsx / ecmascript 2019 to browser-compatible javascript. It's 16x - 20x faster than babel even on single-core synchronous benchmark. Note that actual performance gap is larger because swc works on worker thread while babel works on event loop thread.]]></description><guid isPermaLink="false">a3541593-fc72-40c3-a4b8-7fdad4cab8fe</guid><pubDate>Fri,  8 Feb 2019 00:00:00 +0000</pubDate><dc:creator>DongYoon Kang</dc:creator></item><item><title>Comparing C and Rust network protocol exercises - Ayende @ Rahien</title><link>https://ayende.com/blog/185859-A/comparing-c-and-rust-network-protocol-exercises?Key=bd1ba87d-6e7e-4739-824d-0ca6fc232b05</link><description><![CDATA[Almost by accident, it turned out that I implemented a pretty simple, but non trivial task in both C and Rust and blogged about them. Now that Iâ€™m done with both of them, I thought it would be interesting to talk about the differences in the experiences. The Rust version clocks at exactly 400 lines of code and uses 12 external crates. The C version has 911 lines of C code and another 140 lines in headers and depends on libuv and openssl.]]></description><guid isPermaLink="false">756d2f52-51dd-4408-ae79-3b17c02849e3</guid><pubDate>Tue,  5 Feb 2019 00:00:00 +0000</pubDate><dc:creator>Ayende Rahien</dc:creator></item><item><title>Announcing OOProxy, a reverse OpenID and OAuth2 proxy</title><link>https://medium.com/hal24k-techblog/announcing-ooproxy-b041bab2bc85</link><description><![CDATA[At HAL24K, we benefit a lot from open source software. That is why, to contribute back, weâ€™ve started an internal program to open source some of the internal tools and libraries weâ€™ve used to build our platform and machine learning solutions, starting with OOProxy. OOProxy is a reverse OpenID and OAuth2 proxy that we use to protect our HTTP-based machine learning APIs.]]></description><guid isPermaLink="false">d430867d-388e-4cfb-9e42-698d80876f1c</guid><pubDate>Wed, 30 Jan 2019 14:10:08 +0000</pubDate><dc:creator>Tim Stokman</dc:creator></item><item><title>Embedding WebAssembly in your Rust application</title><link>https://medium.com/wasmer/executing-webassembly-in-your-rust-application-d5cd32e8ce46</link><description><![CDATA[Wasmer is a WebAssembly runtime designed to run both standalone and embedded. The crate wasmer-runtime exposes an easy to use and safe api for compiling, creating imports, and calling WebAssembly from your own library. This tutorial goes over how to make a simple wasm application and run it using the wasmer-runtime!]]></description><guid isPermaLink="false">94fdb740-ae30-402f-9dc5-3f98b6a2753a</guid><pubDate>Thu, 24 Jan 2019 17:20:46 +0000</pubDate><dc:creator>Brandon Fish and Lachlan Sneff</dc:creator></item><item><title>Enjoy a slice of QUIC, and Rust!</title><link>https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/</link><description><![CDATA[During last yearâ€™s Birthday Week we announced early support for QUIC, the next generation encrypted-by-default network transport protocol designed to secure and accelerate web traffic on the Internet.

We are not quite ready to make this feature available to every Cloudflare customer yet, but while you wait we thought you might enjoy a slice of quiche, our own open-source implementation of the QUIC protocol written in Rust.]]></description><guid isPermaLink="false">2810bb3d-7b68-42f0-ba5f-5c7a5956caf7</guid><pubDate>Tue, 22 Jan 2019 16:26:07 +0000</pubDate><dc:creator>Alessandro Ghedini</dc:creator></item><item><title>Exporting Serde types to TypeScript</title><link>http://timryan.org/2019/01/22/exporting-serde-types-to-typescript.html</link><description><![CDATA[I built my first web application with Rust and WebAssembly back in 2017. At the time, support for compiling Rust with the wasm32-unknown-unknown target had just landed, letting you run Rust code in the browser with few modifications. The downside was that loading and interacting with WebAssembly might require you to explicitly allocate and track memory. You might even need to manually decode UTF-8 strings in JavaScript:]]></description><guid isPermaLink="false">76ad8f41-d0b9-4789-b45a-5cfa550aa7c3</guid><pubDate>Tue, 22 Jan 2019 16:00:00 +0000</pubDate><dc:creator>Tim Ryan</dc:creator></item><item><title>WebGL + Rust: Basic Water Tutorial</title><link>http://www.chinedufn.com/3d-webgl-basic-water-tutorial/</link><description><![CDATA[In this tutorial weâ€™ll discuss the ideas and concepts behind rendering water and then talk through some demo code.]]></description><guid isPermaLink="false">0cba574e-769b-491e-83de-cfa070b1b942</guid><pubDate>Sun,  6 Jan 2019 13:00:00 -0500</pubDate><dc:creator>Chinedu Francis Nwafili</dc:creator></item><item><title>Rust and WebAssembly in 2019</title><link>http://fitzgeraldnick.com/2018/12/14/rust-and-webassembly-in-2019.html</link><description><![CDATA[Compiling Rust to WebAssembly should be the best choice for fast, reliable code for the Web. Additionally, the same way that Rust integrates with C calling conventions and libraries on native targets, Rust should also integrate with JavaScript and HTML5 on the Web. These are the Rust and WebAssembly domain working groupâ€™s core values. In 2018, we made it possible to surgically replace performance-sensitive JavaScript with Rust-generated WebAssembly. I propose that we make larger-scale adoption of Rust and WebAssembly practical in 2019.]]></description><guid isPermaLink="false">f12043be-3b2d-4ab3-8ce1-51463ffad905</guid><pubDate>Fri, 14 Dec 2018 00:00:00 -0800</pubDate><dc:creator>Nick Fitzgerald</dc:creator></item><item><title>Async in Rust, circa 2018</title><link>https://rust-lang-nursery.github.io/wg-net/2018/12/13/async-update.html</link><description><![CDATA[Rust 2018 has shipped, and weâ€™re closing in on the end of the year. While we didnâ€™t manage to ship async/await as part of the edition itself, the community has made quite a lot of progress toward that goal. This post summarizes the state of play, and announces the publication of several crates intended to facilitate use of async/await on the nightly ecosystem.]]></description><guid isPermaLink="false">53c9e07b-f4d5-423f-8a84-05e119814fda</guid><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Edge programming with Rust and WebAssembly</title><link>https://www.fastly.com/blog/edge-programming-rust-web-assembly</link><description><![CDATA[Take a developer deep dive into Terrarium, our multi-language, browser-based editor and deployment platform at the edge. Learn how to compile Rust programs to WebAssembly right on your local machine, interact with the Terrarium system, and explore some applications weâ€™ve built with it.]]></description><guid isPermaLink="false">78791a3b-395e-4d3b-b091-66aa2fa2c577</guid><pubDate>Wed, 12 Dec 2018 16:00:00 +0000</pubDate><dc:creator>Pat Hickey</dc:creator></item><item><title>Using Web Assembly in the Browser</title><link>https://ljcode.org/blog/wasm-part1/</link><description><![CDATA[WebAssembly (abbreviated Wasm) is a binary instruction format for a stack-based virtual machine. This essentially means that is is fast, because the program is compiled to a much more compact format, making it faster to parse. Wasm can be written by hand if you're looking for a challenge, but is primarily meant to be written in another language, and then compiled to Wasm. You may know a little about Assembly language and how it works - here's a quick refresher in-case you're rusty.]]></description><guid isPermaLink="false">27a7e602-da8a-4c0b-9ec1-81cc22c00df9</guid><pubDate>Mon, 10 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Luke Jones</dc:creator></item><item><title>Rocket v0.4: Typed URIs, Database Support, Revamped Queries, &amp; More!</title><link>https://rocket.rs/v0.4/news/2018-12-08-version-0.4/</link><description><![CDATA[I am elated to announce that the next major release of Rocket is now available! Rocket 0.4 is a step forward in every direction: it is packed with features and improvements that increase developer productivity, improve application security and robustness, provide new opportunities for extensibility, and deliver a renewed degree of toolchain stability.]]></description><guid isPermaLink="false">9e21d91f-ef59-43f5-98c9-ba96d003fcb3</guid><pubDate>Sat,  8 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Sergio Benitez</dc:creator></item><item><title>Reflecting on Rust and WebAssembly in 2018</title><link>https://rustwasm.github.io/2018/12/06/reflecting-on-rust-and-wasm-in-2018.html</link><description><![CDATA[ðŸŽ‰ The 2018 edition of Rust has officially shipped, and the initial Rust and WebAssembly development story along with it! ðŸŽ‰ To see how far weâ€™ve come, letâ€™s reflect on the Rust and WebAssembly story a year ago: rustc could emit WebAssembly binaries for you, but that was about it. As far as communication with JavaScript went, you had to work with raw wasm imports and exports yourself. That meant you could only pass 32- and 64-bit integers and floats back and forth. No Rust structs, JavaScript objects, strings, or slices could be passed back forth. And distributing your libraryâ€™s .wasm so that other downstream projects could depend on it? Good luck.]]></description><guid isPermaLink="false">c0eb769f-4785-436d-b0b9-4bff16b30ef8</guid><pubDate>Thu,  6 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Rust and WebAssembly</dc:creator></item><item><title>Wherefore art thou Romio?</title><link>http://boats.gitlab.io/blog/post/romio/</link><description><![CDATA[This blog post is about a project called Romio that Iâ€™ve been working on over the past two or three weeks. Romio is a port of a small part of the Tokio project to the newer futures APIs.

I started the project to get some experience porting code from the old futures API to the new API. However, we realized that this code could also be useful to other people who want to experiment with networking code using the new async/await syntax, so with the help of others we polished it up during the RustFest Rome â€œimpl daysâ€ and now its being released for people to experiment with.]]></description><guid isPermaLink="false">deadc4e1-1e13-49ca-b62b-cd8af455a164</guid><pubDate>Wed,  5 Dec 2018 00:00:00 +0000</pubDate><dc:creator>withoutboats</dc:creator></item><item><title>Safe Web Services with Actix and Sentry</title><link>https://blog.sentry.io/2018/12/04/safe-web-services-actix-sentry</link><description><![CDATA[Enjoy this quick introduction to creating a web server with Actix and monitoring it with Sentry.]]></description><guid isPermaLink="false">05ee17e8-44f9-41c4-9f29-b4a5be430158</guid><pubDate>Tue,  4 Dec 2018 00:00:00 +0000</pubDate><dc:creator>Jan Michael Auer</dc:creator></item><item><title>CFG Game: Put your CS skills to good use and craft burgers</title><link>http://rickyhan.com/jekyll/update/2018/12/03/make-burgers-context-free-grammar.html</link><description><![CDATA[This past weekend I made a game for Ludum Dare 43. Tools used: Aseprite, quicksilver. Inspired by Zachtronics. It is written in Rust and compiled to WebAssembly.]]></description><guid isPermaLink="false">5493161b-6e7d-4b81-887f-af80a0d2c410</guid><pubDate>Mon,  3 Dec 2018 04:37:02 +0000</pubDate><dc:creator>Ricky Han</dc:creator></item><item><title>Dice.rs: Rust on Lambda</title><link>https://kellenfujimoto.com/posts/dicers-rust-on-lambda/</link><description><![CDATA[Rust support on AWS Lambda was recently released, which seems like as good an opportunity as any to share some code and the solutions to challenges I encountered along the way â˜º. Iâ€™ve decided to create a little diceware service, and the lambda-runtime crate provides a great API to make this a breeze.]]></description><guid isPermaLink="false">c52eda57-1761-4ec3-9e59-c4c45d665574</guid><pubDate>Sun,  2 Dec 2018 14:18:59 +0100</pubDate><dc:creator>Kellen Frodelius-Fujimoto</dc:creator></item><item><title>Creating my first AWS Lambda using Rust</title><link>https://medium.com/@kkostov/rust-aws-lambda-30a1b92d4009</link><description><![CDATA[Taking advantage of AWS Lambda Runtime support for Rust]]></description><guid isPermaLink="false">7df2b166-e70e-4b15-bf6e-9475a81096e9</guid><pubDate>Sun,  2 Dec 2018 12:40:16 +0000</pubDate><dc:creator>Konstantin</dc:creator></item><item><title>Rust Runtime for AWS Lambda</title><link>https://aws.amazon.com/blogs/opensource/rust-runtime-for-aws-lambda/</link><description><![CDATA[AWS Lambda, which makes it easy for developers to run code for virtually any type of application or backend service with zero administration, has just announced the Runtime APIs. The Runtime APIs define an HTTP-based specification of the Lambda programming model which can be implemented in any programming language. To accompany the API launch, we have open sourced a runtime for the Rust language.]]></description><guid isPermaLink="false">48218be5-130b-4274-b41a-7bfa20086f0d</guid><pubDate>Thu, 29 Nov 2018 18:02:27 +0000</pubDate><dc:creator>Stefano Buliani</dc:creator></item><item><title>Serverless HTTP in Rust</title><link>https://medium.com/@softprops/serverless-http-9a58f9b2df60</link><description><![CDATA[Throw down your main! Rustlang Serverless HTTP applications wonâ€™t need them where theyâ€™re going]]></description><guid isPermaLink="false">c1576100-8199-418d-bd9a-03c71f1b5559</guid><pubDate>Wed, 28 Nov 2018 11:11:52 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Rust Web Survey Results 2018</title><link>https://rust-lang-nursery.github.io/wg-net/2018/11/28/wg-net-survey.html</link><description><![CDATA[We recently sent out a survey regarding the state of the current Rust web ecosystem and we got over a 1000 responses! We really appreciate the feedback from the community. This will help us continue to improve upon the state of the Rust web ecosystem. Today, we would like to go over the responses and understand the results.]]></description><guid isPermaLink="false">881d8c07-ccf4-48be-ab22-bd76cc7c848d</guid><pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Bhargav Voleti</dc:creator></item><item><title>Tideâ€™s evolving middleware approach</title><link>https://rust-lang-nursery.github.io/wg-net/2018/11/27/tide-middleware-evolution.html</link><description><![CDATA[Since the last post on Tide, there have been a number of excellent contributions from a bunch of new contributors! In this post, I want to talk about the work that @tirr-c has done to substantially improve the middleware story.]]></description><guid isPermaLink="false">abba07ed-5ffb-4b29-ba29-f1e6dbdce718</guid><pubDate>Tue, 27 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Generating Sudoku Boards pt. 3: Rust for WebAssembly</title><link>https://medium.com/@rossharrison/generating-sudoku-boards-pt-3-rust-for-webassembly-85bd7294c34a</link><description><![CDATA[Adjusting an existing Rust project to build a native binary and library for WASM, load in JS. Details on working through build issues.]]></description><guid isPermaLink="false">108e3952-7d7b-4fcc-9c76-073646f2ddee</guid><pubDate>Mon, 26 Nov 2018 00:18:40 +0000</pubDate><dc:creator>Ross Harrison</dc:creator></item><item><title>Generic Methods in Rust: How Exonum Shifted from Iron to Actix-web</title><link>https://medium.com/meetbitfury/generic-methods-in-rust-how-exonum-shifted-from-iron-to-actix-web-7a2752171388</link><description><![CDATA[In this article, we describe how we ported the Exonum framework to actix-web using generic programming.]]></description><guid isPermaLink="false">c5b56719-bdcd-4d91-8b61-85a27cd5315c</guid><pubDate>Wed, 21 Nov 2018 10:51:32 +0000</pubDate><dc:creator>Exonum</dc:creator></item><item><title>Bringing Elmâ€™s architecture to Rust and Webassembly</title><link>https://sindrejohansen.no/blog/willow/rust/elm/2018/11/16/willow-elm-in-rust.html</link><description><![CDATA[I really like Elm. It is a delightful language with an amazing ecosystem. It has an interesting architecture called TEA, The Elm Architecture. Another language I like is Rust. On paper, Rust is completely different from Elm, but in using them both, I have seen some resemblance. Having used both Elm and Rust I had something I wanted to try. Would it be possible to create The Elm Architecture in Rust?]]></description><guid isPermaLink="false">ad136bed-3540-4ced-8a77-448b94426ba3</guid><pubDate>Fri, 16 Nov 2018 16:35:22 +0000</pubDate><dc:creator>Sindre</dc:creator></item><item><title>Running Rust natively in AWS Lambda and testing it locally</title><link>https://medium.com/@bernardo.belchior1/running-rust-natively-in-aws-lambda-and-testing-it-locally-57080421426d</link><description><![CDATA[Abusing Go runtime in AWS to run Rust binaries]]></description><guid isPermaLink="false">97715a00-432f-4cfa-9c11-92f0d74ff60e</guid><pubDate>Mon, 12 Nov 2018 14:23:33 +0000</pubDate><dc:creator>Bernardo Belchior</dc:creator></item><item><title>Serve archived static files over HTTP</title><link>https://deterministic.space/serve-archived-static-files-over-http.html</link><description><![CDATA[Say you want to store a huge number of very small filesthat you will only access over HTTP.For example:You are using rustdoc to render the documentation of a library.Without much work youâ€™ll end up with about 100k HTML filesthat are about 10kB each.As it turns out,this number of small files is very annoying for any kind of file system performance.Best case: making copies/backups is slow.Worst case: Youâ€™re using an anti virus software and it takes ages.]]></description><guid isPermaLink="false">b2687a6e-55b3-4d3b-a025-fc9e7c592e8e</guid><pubDate>Sun, 11 Nov 2018 00:00:00 +0100</pubDate><dc:creator>Pascal Hertleif</dc:creator></item><item><title>Middleware in Tide</title><link>https://rust-lang-nursery.github.io/wg-net/2018/11/07/tide-middleware.html</link><description><![CDATA[After the positive response to the routing and extraction proposal in Tide, Iâ€™m pleased to say that an initial implementation is available on GitHub! As a testament to the strong foundation that Rustâ€™s ecosystem provides, the basic framework implementation took only about 1,000 lines of code.]]></description><guid isPermaLink="false">b8931a7e-08d1-406b-b751-6bd27a9d4d67</guid><pubDate>Wed,  7 Nov 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Serverless Rust</title><link>https://medium.com/@softprops/serverless-rust-318732a3596</link><description><![CDATA[This is going to be the first post ( and hopefully not last ) in a series of posts about writing (and thinking about) serverless applications in Rust. Stay tunedâ€¦]]></description><guid isPermaLink="false">4b5e36d0-0775-48da-a6f9-ab19ce9a5aae</guid><pubDate>Tue, 30 Oct 2018 02:08:22 +0000</pubDate><dc:creator>Doug Tangren</dc:creator></item><item><title>Announcing Gotham 0.3</title><link>https://gotham.rs/blog/release/2018/10/29/gotham-0.3.html</link><description><![CDATA[First of all, hello there! This is the first announcement after the call for maintainers back in summer, and includes the efforts of several new faces: @whitfin, @nyarly, @colinbankier. Together, as well as input from the original authors @bradleybeddoes and @smangelsdorf, we are the new maintainers of the Gotham project. Today weâ€™re excited to announce the release of Gotham 0.3, which follows the evolution of the broader Rust ecosystem.]]></description><guid isPermaLink="false">77d7a663-c11c-476c-a180-a84d0edf2975</guid><pubDate>Mon, 29 Oct 2018 15:31:00 +0000</pubDate><dc:creator>@whitfin, @nyarly, @colinbankier</dc:creator></item><item><title>Auth Web Microservice with rust using Actix-Web - Part 2</title><link>https://hgill.io/posts/auth-microservice-rust-actix-web-diesel-complete-tutorial-part-2/</link><description><![CDATA[Picking up from part one, we now have as server that takes an email address from a request and spits out a JSON response with an invitation object. In part one I said that we will send an email to the user, after some thought and feedback, we will be skipping this part now (look out for part 3). For now we will use the http response from the server to verify the email so to speak.]]></description><guid isPermaLink="false">268e1717-7988-4cb0-83e4-f4c902a969a8</guid><pubDate>Sun, 28 Oct 2018 13:02:37 +0100</pubDate><dc:creator>Harry Gill</dc:creator></item><item><title>10x Your JavaScript With WASM And Rust</title><link>https://blog.x5ff.xyz/blog/azure-functions-wasm-rust-ai/</link><description><![CDATA[This is part four in a series of Rust on Azure Functions. The other parts are about performance comparisons (part 1 and part 2), and explaining the PMX algorithm (part 3). If you want to learn more about Genetic Algorithms be sure to read part 3 first).]]></description><guid isPermaLink="false">8c9a2022-1124-47da-94c4-a85e808a257c</guid><pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Claus</dc:creator></item><item><title>Multithreading Rust and Wasm</title><link>https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html</link><description><![CDATA[When WebAssembly was first shipped it was an MVP which, while minimal, has spawned a huge number of exciting projects which work today across all major browsers. Rust has capitalized on the wasm MVPâ€™s success as well with tools like wasm-bindgen and wasm-pack by making the MVP feel less minimal. WebAssembly is yet more ambitious, though! Since inception itâ€™s always been intended to extend the WebAssembly specification with new features and functionality.]]></description><guid isPermaLink="false">1025ea91-d834-4f58-97cc-dabcee3b86df</guid><pubDate>Wed, 24 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Alex Crichton</dc:creator></item><item><title>Serverless Rust with AWS Lambda and WebAssembly</title><link>https://blog.scottlogic.com/2018/10/18/serverless-rust.html</link><description><![CDATA[In this post, I look at how WebAssembly can be used to create serverless functions and demonstrate an AWS Lambda function written entirely in Rust.]]></description><guid isPermaLink="false">c1a9ce3b-fd19-4285-b465-ab7607792297</guid><pubDate>Thu, 18 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Colin Eberhardt</dc:creator></item><item><title>Serverless Rust with Cloudflare Workers</title><link>https://blog.cloudflare.com/cloudflare-workers-as-a-serverless-rust-platform/</link><description><![CDATA[It's exciting times for Rust developers. Cloudflare's Serverless Platform, Cloudflare Workers, allows you to compile your code to WASM, upload to 150+ data centers and invoke those functions just as easily as if they were JavaScript functions. Today I'm going to convert my lipsum generator to use Rust and explore the developer experience (hint: it's already pretty nice).]]></description><guid isPermaLink="false">0c92d9d7-26ba-4152-9820-08ef1011689d</guid><pubDate>Tue, 16 Oct 2018 12:00:00 +0000</pubDate><dc:creator>Steven Pack</dc:creator></item><item><title>Routing and extraction in Tide: a first sketch</title><link>https://rust-lang-nursery.github.io/wg-net/2018/10/16/tide-routing.html</link><description><![CDATA[This post continues the series on Tide, sketching a possible design for routing and extraction that combines some of the best ideas from frameworks like Rocket, Actix, and Gotham.]]></description><guid isPermaLink="false">7141f981-74d7-4df6-9ce2-b857fff58557</guid><pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Pi-hole: Announcing Our RESTful API</title><link>https://pi-hole.net/2018/10/15/announcing-our-restful-api-contributions-welcome/</link><description><![CDATA[The API is written in Rust, a language new to the Pi-hole project. Rust is a safe and fast language which matches well with our goals for the API. It is statically typed and prevents whole categories of errors while being productive and extendable.]]></description><guid isPermaLink="false">0c44f78b-c47a-4be2-9e30-4fa129304a9c</guid><pubDate>Mon, 15 Oct 2018 13:00:33 +0000</pubDate><dc:creator>Pi-hole</dc:creator></item><item><title>Auth Web Microservice with rust using Actix-Web</title><link>https://hgill.io/posts/auth-microservice-rust-actix-web-diesel-complete-tutorial-part-1/</link><description><![CDATA[We are going to create a web-server in rust that only deals with user registration and authentication. I will be explaining the steps in each file as we go. The complete project code is here repo. Please take all this with a pinch of salt as Iâ€™m a still a noob to Rust.]]></description><guid isPermaLink="false">d418a0ea-dbef-4bfa-bc74-827185aef57c</guid><pubDate>Mon,  8 Oct 2018 13:02:37 +0100</pubDate><dc:creator>Harry Gill</dc:creator></item><item><title>WebAssembly and Dynamic Memory</title><link>https://frehberg.wordpress.com/webassembly-and-dynamic-memory/</link><description><![CDATA[WebAssembly is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable target for compilation of high-level languages like C/C++/Rust, enabling deployment on the web for client and server applications.

These high-level languages like C/C++/Rust (+Javascript) deal with different allocations of memory, such as static memory, stack memory and dynamic memory.]]></description><guid isPermaLink="false">cba35bca-a821-4ba9-81d8-3cee56f5e199</guid><pubDate>Thu,  4 Oct 2018 03:19:18 +0000</pubDate><dc:creator>Frank Rehberger</dc:creator></item><item><title>Introducing Ruukh Framework</title><link>https://sharadchand.com/2018/10/03/ruukh-framework.html</link><description><![CDATA[Rust has its goals set on to be a primary WASM language and it would be awesome to use it both in backend and frontend web. Ruukh is one of such efforts to realise that dream. Ruukh, a frontend web framework, is inspired by both VueJS and ReactJS.]]></description><guid isPermaLink="false">217f309f-bfff-4997-8ff7-faddf10b670f</guid><pubDate>Wed,  3 Oct 2018 12:38:00 +0000</pubDate><dc:creator>Sharad Chand</dc:creator></item><item><title>Lessons learned on writing web applications completely in Rust</title><link>https://medium.com/@saschagrunert/lessons-learned-on-writing-web-applications-completely-in-rust-2080d0990287</link><description><![CDATA[This blog post is an update to the preceeding article â€œA web application completely written in Rustâ€ and summarizes the projectsâ€™ progress over the last months.]]></description><guid isPermaLink="false">7de9ba6b-a3ae-4db5-a911-15126a264b26</guid><pubDate>Wed,  3 Oct 2018 11:59:12 +0000</pubDate><dc:creator>Sascha Grunert</dc:creator></item><item><title>Tower Web 0.3 â€” async/await and template support</title><link>https://medium.com/@carllerche/tower-web-0-3-async-await-and-template-support-e0bb8ed47941</link><description><![CDATA[Today, Tower Web 0.3 has been released and it comes with two major new features: Experimental support for async/await. Support for using templates to render responses.]]></description><guid isPermaLink="false">fa23119f-23c8-404c-9aaa-5a75da99d131</guid><pubDate>Fri, 28 Sep 2018 17:32:13 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>Programming WebAssembly with Rust â€” The Book!</title><link>https://medium.com/@KevinHoffman/programming-webassembly-with-rust-the-book-7c4a890fcf97</link><description><![CDATA[I am proud to announce that Iâ€™m working on a book for the Pragmatic Programmers. The title hasnâ€™t been set in stone yet, but the book will be about programming WebAssembly with Rust.]]></description><guid isPermaLink="false">38d1a807-a596-4423-a458-beab7d9df074</guid><pubDate>Fri, 28 Sep 2018 13:25:42 +0000</pubDate><dc:creator>Kevin Hoffman</dc:creator></item><item><title>Announcing the web-sys crate!</title><link>https://rustwasm.github.io/2018/09/26/announcing-web-sys.html</link><description><![CDATA[We are pleased to announce the first release of the web-sys crate! It provides raw bindings to all the Webâ€™s APIs: everything from DOM manipulation to WebGL to Web Audio to timers to fetch and more!]]></description><guid isPermaLink="false">27dd6f1a-6659-43d5-aa7b-2e0ee21c7173</guid><pubDate>Wed, 26 Sep 2018 00:00:00 +0000</pubDate><dc:creator>rustwasm</dc:creator></item><item><title>eBPF, ingrained in Rust</title><link>https://blog.redsift.com/labs/ebpf-ingrained-in-rust/</link><description><![CDATA[Today we are releasing RedBPF and ingraind, our eBPF toolkit that integrates with StatsD and S3, to gather feedback, and see where others in the Rust community might take this framework. If you are looking to up your companyâ€™s monitoring game, gather more data about your Raspberry Pi cluster at home, or just have a strong academic interest in Rust and low-level bit shepherding, you might want to read on.]]></description><guid isPermaLink="false">ba0468b9-b0dd-40d1-b253-9fa70cb05ddf</guid><pubDate>Tue, 25 Sep 2018 14:45:44 +0000</pubDate><dc:creator>Peter Parkanyi</dc:creator></item><item><title>Smithy progress update: How I decreased WebAssembly bundle size by 90%</title><link>https://medium.com/@robert.balicki_2494/smithy-progress-update-how-i-decreased-webassembly-bundle-size-by-90-e7fe194b2f58</link><description><![CDATA[Smithy, a web development framework written in Rust that compiles to WebAssembly. In the mean time, there has been substantial progress, and Smithy is on the verge of being ready for alpha use! In this post, I want to describe the improvements that have been made, and whatâ€™s on the Smithy roadmap!]]></description><guid isPermaLink="false">21440a24-a7da-4c72-8232-df22c7438b09</guid><pubDate>Mon, 24 Sep 2018 03:36:53 +0000</pubDate><dc:creator>Robert Balicki</dc:creator></item><item><title>Announcing Linkerd 2.0: from service mesh to service sidecar</title><link>https://blog.linkerd.io/2018/09/18/announcing-linkerd-2-0/</link><description><![CDATA[The 2.0 release of Linkerd brings two very significant changes. First, weâ€™ve completely rewritten Linkerd to be orders of magnitude faster and smaller than Linkerd 1.x. Linkerd 2.0â€™s data plane is comprised of ultralight Rust proxies which consume around 10mb of RSS and have a p99 latency of <1ms. Linkerdâ€™s minimalist control plane (written in Go) is similarly designed for speed and low resource footprint.]]></description><guid isPermaLink="false">cf201dba-76a2-49e1-a4d9-b28093189901</guid><pubDate>Tue, 18 Sep 2018 17:00:00 +0000</pubDate><dc:creator>William Morgan</dc:creator></item><item><title>Rust and JavaScript Interop â†”ï¸</title><link>https://blog.ryanlevick.com/posts/wasm-bindgen-interop/</link><description><![CDATA[In recent projects of mine, Iâ€™ve been using WebAssembly quite a bit. WebAssembly (Wasm) is â€œa new binary instruction format for a stack based virtual machineâ€ that lets you use languages besides JavaScript to run code on a web page - usually either for performance reasons or to run code youâ€™d like to share across different platforms. In my opinion, the most promising of these languages, due to its lack of a need for a runtime and great tooling is Rust.]]></description><guid isPermaLink="false">d72f5483-1247-46d8-8764-7ac5ec0fb2d3</guid><pubDate>Wed, 12 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Ryan Levick</dc:creator></item><item><title>Rising Tide: building a modular web framework in the open</title><link>https://rust-lang-nursery.github.io/wg-net/2018/09/11/tide.html</link><description><![CDATA[The Network Services Working Group aims to improve the story for web development this year in several respects: by bolstering foundations like async/await, by improving the ecosystem of web-related crates, and by pulling these pieces together into a framework and book called Tide. The name â€œTideâ€ refers to â€œa rising tide lifts all boatsâ€; the intent is to improve sharing, compatibility, and improvements across all web development and frameworks in Rust.]]></description><guid isPermaLink="false">1461a8b4-863b-40c1-bb2d-0ff077d738e1</guid><pubDate>Tue, 11 Sep 2018 00:00:00 +0000</pubDate><dc:creator>Aaron Turon</dc:creator></item><item><title>Tower Web â€” Expanding the middleware stack</title><link>https://medium.com/@carllerche/tower-web-expanding-the-middleware-stack-f9bf55bfa109</link><description><![CDATA[tower-web version 0.2.2 has been released. It comes with a number of new features, which I will talk about in this post. Primarily, the middleware story is starting to come together. I will be expanding some on how middleware fits into Tower and web in general.]]></description><guid isPermaLink="false">e7fbc029-a108-4209-bbf4-9e152701d9a6</guid><pubDate>Fri,  7 Sep 2018 14:21:28 +0000</pubDate><dc:creator>Carl Lerche</dc:creator></item><item><title>Programming Servo: A generic â€œworker event-loopâ€</title><link>https://medium.com/programming-servo/programming-servo-a-generic-worker-event-loop-400a6f113a60</link><description><![CDATA[Letâ€™s take a look at how in Rust you can have an algorithm generic over T, where T is further bound by a trait, which itself is generic over one of several parameters.]]></description><guid isPermaLink="false">850319b3-4515-4f9c-b833-67a391d5ab26</guid><pubDate>Sun,  2 Sep 2018 07:03:47 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Benchmarking a Rust web application</title><link>https://klausi.github.io/rustnish/2018/08/31/benchmarking-a-rust-web-application.html</link><description><![CDATA[I set out out my goal 9 for Rustnish: Write benchmark code that compares runtime performance of Rustnish against Varnish. Use cargo bench to execute the benchmarks.

The basic idea of a performance test here is to send many HTTP requests to the web service (the reverse proxy in this case) and measure how fast the responses arrive back. Comparing the results from Rustnish and Varnish should give us an idea if our performance expectations are holding up.]]></description><guid isPermaLink="false">715ee4bf-9164-4c58-aa4f-93f088859281</guid><pubDate>Fri, 31 Aug 2018 00:00:00 +0000</pubDate><dc:creator>klausi</dc:creator></item><item><title>Using WebAssembly to Accelerate Markdown Rendering</title><link>https://engineering.spideroak.com/2018/08/29/using-webassembly-to-speed-up-message-rendering/</link><description><![CDATA[Markdown rendering is very important to the performance of Semaphor - every message you send and read is a Markdown document - so we're always looking for ways to improve the performance of rendering Markdown. A couple months ago Jonathan Moore and I wondered how easy it would be to integrate WebAssembly into a React component, replacing the render() function, and we thought that moving Markdown parsing into Rust would be a great way to test this idea out.]]></description><guid isPermaLink="false">bb052dfe-fdb1-4848-9fdf-28c7c5023d93</guid><pubDate>Wed, 29 Aug 2018 10:10:00 +0000</pubDate><dc:creator>Chip Black and Jonathan Moore</dc:creator></item><item><title>Programming Servo: the makings of a task-queue</title><link>https://medium.com/programming-servo/programming-servo-the-makings-of-a-task-queue-b4138cd246ca</link><description><![CDATA[In Servo, task-sources are implemented via a channel, whose sender is cloned for each specific task-source, and where tasks are messages sent on the channel and containing a closure representing the actual task.]]></description><guid isPermaLink="false">ed925df2-a1c7-4125-a27c-7cbda8dbac71</guid><pubDate>Tue, 28 Aug 2018 10:11:58 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>From Rust to beyond: The ASM.js galaxy</title><link>https://mnt.io/2018/08/28/from-rust-to-beyond-the-asm-js-galaxy/</link><description><![CDATA[The second galaxy that our Rust parser will explore is the ASM.js galaxy. This post will explain what ASM.js is, how to compile the parser into ASM.js, and how to use the ASM.js module with Javascript in a browser. The goal is to use ASM.js as a fallback to WebAssembly when it is not available. I highly recommend to read the previous episode about WebAssembly since they have a lot in common.]]></description><guid isPermaLink="false">10c577b9-fdf3-4aa3-80dd-78c6e4abb8c7</guid><pubDate>Tue, 28 Aug 2018 07:39:03 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Oxidizing sourmash: WebAssembly</title><link>https://blog.luizirber.org/2018/08/27/sourmash-wasm/</link><description><![CDATA[In "Oxidizing sourmash: Python and FFI" I described my road to learn Rust, but something that I omitted was that around the same time the WebAssembly support in Rust started to look better and better and was a huge influence in my decision to learn Rust. Reimplementing the sourmash C++ extension in Rust and use the same codebase in the browser sounded very attractive, and now that it was working I started looking into how to use the WebAssembly target in Rust.]]></description><guid isPermaLink="false">a7804e3a-d98b-4135-9d38-e75aeb294961</guid><pubDate>Mon, 27 Aug 2018 15:30:00 -0300</pubDate><dc:creator>Luiz Irber</dc:creator></item><item><title>From Rust to beyond: The WebAssembly galaxy</title><link>https://mnt.io/2018/08/22/from-rust-to-beyond-the-webassembly-galaxy/</link><description><![CDATA[The first galaxy that our Rust parser will explore is the WebAssembly (WASM) galaxy. This post will explain what WebAssembly is, how to compile the parser into WebAssembly, and how to use the WebAssembly binary with Javascript in a browser and with NodeJS.]]></description><guid isPermaLink="false">b1b8abb7-362a-4004-8b6c-913ca1c85773</guid><pubDate>Wed, 22 Aug 2018 07:46:27 +0000</pubDate><dc:creator>Ivan Enderlin</dc:creator></item><item><title>Programming Servo: Anatomy of a Fetch</title><link>https://medium.com/programming-servo/anatomy-of-a-fetch-8872a5c843cd</link><description><![CDATA[Today, letâ€™s go through an entire fetch in Servo, starting with an example in JS.]]></description><guid isPermaLink="false">8b803f70-9098-40d0-97af-5cdff0cde756</guid><pubDate>Fri, 17 Aug 2018 22:29:36 +0000</pubDate><dc:creator>Gregory Terzian</dc:creator></item><item><title>Rust GraphQL webserver with Warp, Juniper and MongoDB</title><link>http://alex.amiran.it/post/2018-08-16-rust-graphql-webserver-with-warp-juniper-and-mongodb.html</link><description><![CDATA[Rust's web frameworks ecosystem is in constant change, but recently a new framework called warp came out implementing a new, original way to solve the old problem of transforming a request into a response, and I wanted to give it a try.

And, as I use GraphQL massively at work, I also wanted to check how well Juniper implements it. To add some spice, I used MongoDB as a storage engine instead of the ubiquitous and well-supported SQL databases.]]></description><guid isPermaLink="false">1921a96e-ad32-410f-b0a7-c72dc16d3cde</guid><pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate><dc:creator>/dev/random</dc:creator></item></channel></rss>